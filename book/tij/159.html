<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="content-type" content="text/html;charset=utf-8">
    <meta charset="utf-8">
<meta name="360-site-verification" content="cabcfb5a0f4c0d28d604e8a69e6c0cdb" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="baidu-site-verification" content="HknqsD2zhn" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>java编程思想(thinking in java)-编码助手网</title>
      <meta content="为编码人员提供在线文档、模板等帮助，提升解决问题效率" name="description">
			<meta content="java编程思想(thinking in java) Java, spring, tomcat, servlet, jsp, api doc, bootstrap" name="keywords">
<meta name="sogou_site_verification" content="42nApEZFKO"/>


    <!-- Bootstrap Core CSS -->
    <link href="../../css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="../../css/heroic-features.css" rel="stylesheet">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
		<script>
		var _hmt = _hmt || [];
		(function() {
		  var hm = document.createElement("script");
		  hm.src = "//hm.baidu.com/hm.js?dd1361ca20a10cc161e72d4bc4fef6df";
		  var s = document.getElementsByTagName("script")[0];
		  s.parentNode.insertBefore(hm, s);
		})();
		</script>

</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">编码助手网</a>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav">
                    <li>
                        <a href="/">首页</a>
                    </li>
										<li>
                        <a href="/template.html">模板</a>
                    </li>
										<li>
												<a href="/doc.html">文档</a>
										</li>
                    <li>
                        <a href="/contact.html">联系我们</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Content -->
    <div class="container">

			<div class="row">
					<div class="col-xs-4">
						<h4>java编程思想(thinking in java)</h4>
						<h6>感谢quanke.name提供内容</h6>
<ul><li><a href='./0.html'>Introduction</a></li><li><a href='./1.html'>写在前面的话</a></li><li><a href='./2.html'>引言</a></li><li><a href='./3.html'>第1章 对象入门</a></li><li><ul><li><a href='./4.html'>1.1 抽象的进步</a></li><li><a href='./5.html'>1.2 对象的接口</a></li><li><a href='./6.html'>1.3 实现方案的隐藏</a></li><li><a href='./7.html'>1.4 方案的重复使用</a></li><li><a href='./8.html'>1.5 继承：重新使用接口</a></li><li><a href='./9.html'>1.6 多形对象的互换使用</a></li><li><a href='./10.html'>1.7 对象的创建和存在时间</a></li><li><a href='./11.html'>1.8 违例控制：解决错误</a></li><li><a href='./12.html'>1.9 多线程</a></li><li><a href='./13.html'>1.10 永久性</a></li><li><a href='./14.html'>1.11 Java和因特网</a></li><li><a href='./15.html'>1.12 分析和设计</a></li><li><a href='./16.html'>1.13 Java还是C++</a></li></ul></li><li><a href='./17.html'>第2章 一切都是对象</a></li><li><ul><li><a href='./18.html'>2.1 用句柄操纵对象</a></li><li><a href='./19.html'>2.2 所有对象都必须创建</a></li><li><a href='./20.html'>2.3 绝对不要清除对象</a></li><li><a href='./21.html'>2.4 新建数据类型：类</a></li><li><a href='./22.html'>2.5 方法、自变量和返回值</a></li><li><a href='./23.html'>2.6 构建Java程序</a></li><li><a href='./24.html'>2.7 我们的第一个Java程序</a></li><li><a href='./25.html'>2.8 注释和嵌入文档</a></li><li><a href='./26.html'>2.9 编码样式</a></li><li><a href='./27.html'>2.10 总结</a></li><li><a href='./28.html'>2.11 练习</a></li></ul></li><li><a href='./29.html'>第3章 控制程序流程</a></li><li><ul><li><a href='./30.html'>3.1 使用Java运算符</a></li><li><a href='./31.html'>3.2 执行控制</a></li><li><a href='./32.html'>3.3 总结</a></li><li><a href='./33.html'>3.4 练习</a></li></ul></li><li><a href='./34.html'>第4章 初始化和清除</a></li><li><ul><li><a href='./35.html'>4.1 用构建器自动初始化</a></li><li><a href='./36.html'>4.2 方法过载</a></li><li><a href='./37.html'>4.3 清除：收尾和垃圾收集</a></li><li><a href='./38.html'>4.4 成员初始化</a></li><li><a href='./39.html'>4.5 数组初始化</a></li><li><a href='./40.html'>4.6 总结</a></li><li><a href='./41.html'>4.7 练习</a></li></ul></li><li><a href='./42.html'>第5章 隐藏实施过程</a></li><li><ul><li><a href='./43.html'>5.1 包：库单元</a></li><li><a href='./44.html'>5.2 Java访问指示符</a></li><li><a href='./45.html'>5.3 接口与实现</a></li><li><a href='./46.html'>5.4 类访问</a></li><li><a href='./47.html'>5.5 总结</a></li><li><a href='./48.html'>5.6 练习</a></li></ul></li><li><a href='./49.html'>第6章 类再生</a></li><li><ul><li><a href='./50.html'>6.1 合成的语法</a></li><li><a href='./51.html'>6.2 继承的语法</a></li><li><a href='./52.html'>6.3 合成与继承的结合</a></li><li><a href='./53.html'>6.4 到底选择合成还是继承</a></li><li><a href='./54.html'>6.5 protected</a></li><li><a href='./55.html'>6.6 累积开发</a></li><li><a href='./56.html'>6.7 上溯造型</a></li><li><a href='./57.html'>6.8 final关键字</a></li><li><a href='./58.html'>6.9 初始化和类装载</a></li><li><a href='./59.html'>6.10 总结</a></li><li><a href='./60.html'>6.11 练习</a></li></ul></li><li><a href='./61.html'>第7章 多形性</a></li><li><ul><li><a href='./62.html'>7.1 上溯造型</a></li><li><a href='./63.html'>7.2 深入理解</a></li><li><a href='./64.html'>7.3 覆盖与过载</a></li><li><a href='./65.html'>7.4 抽象类和方法</a></li><li><a href='./66.html'>7.5 接口</a></li><li><a href='./67.html'>7.6 内部类</a></li><li><a href='./68.html'>7.7 构建器和多形性</a></li><li><a href='./69.html'>7.8 通过继承进行设计</a></li><li><a href='./70.html'>7.9 总结</a></li><li><a href='./71.html'>7.10 练习</a></li></ul></li><li><a href='./72.html'>第8章 对象的容纳</a></li><li><ul><li><a href='./73.html'>8.1 数组</a></li><li><a href='./74.html'>8.2 集合</a></li><li><a href='./75.html'>8.3 枚举器（反复器）</a></li><li><a href='./76.html'>8.4 集合的类型</a></li><li><a href='./77.html'>8.5 排序</a></li><li><a href='./78.html'>8.6 通用集合库</a></li><li><a href='./79.html'>8.7 新集合</a></li><li><a href='./80.html'>8.8 总结</a></li><li><a href='./81.html'>8.9 练习</a></li></ul></li><li><a href='./82.html'>第9章 违例差错控制</a></li><li><ul><li><a href='./83.html'>9.1 基本违例</a></li><li><a href='./84.html'>9.2 违例的捕获</a></li><li><a href='./85.html'>9.3 标准Java违例</a></li><li><a href='./86.html'>9.4 创建自己的违例</a></li><li><a href='./87.html'>9.5 违例的限制</a></li><li><a href='./88.html'>9.6 用finally清除</a></li><li><a href='./89.html'>9.7 构建器</a></li><li><a href='./90.html'>9.8 违例匹配</a></li><li><a href='./91.html'>9.9 总结</a></li><li><a href='./92.html'>9.10 练习</a></li></ul></li><li><a href='./93.html'>第10章 Java IO系统</a></li><li><ul><li><a href='./94.html'>10.1 输入和输出</a></li><li><a href='./95.html'>10.2 增添属性和有用的接口</a></li><li><a href='./96.html'>10.3 本身的缺陷：RandomAccessFile</a></li><li><a href='./97.html'>10.4 File类</a></li><li><a href='./98.html'>10.5 IO流的典型应用</a></li><li><a href='./99.html'>10.6 StreamTokenizer</a></li><li><a href='./100.html'>10.7 Java 1.1的IO流</a></li><li><a href='./101.html'>10.8 压缩</a></li><li><a href='./102.html'>10.9 对象序列化</a></li><li><a href='./103.html'>10.10 总结</a></li><li><a href='./104.html'>10.11 练习</a></li></ul></li><li><a href='./105.html'>第11章 运行期类型鉴定</a></li><li><ul><li><a href='./106.html'>11.1 对RTTI的需要</a></li><li><a href='./107.html'>11.2 RTTI语法</a></li><li><a href='./108.html'>11.3 反射：运行期类信息</a></li><li><a href='./109.html'>11.4 总结</a></li><li><a href='./110.html'>11.5 练习</a></li></ul></li><li><a href='./111.html'>第12章 传递和返回对象</a></li><li><ul><li><a href='./112.html'>12.1 传递句柄</a></li><li><a href='./113.html'>12.2 制作本地副本</a></li><li><a href='./114.html'>12.3 克隆的控制</a></li><li><a href='./115.html'>12.4 只读类</a></li><li><a href='./116.html'>12.5 总结</a></li><li><a href='./117.html'>12.6 练习</a></li></ul></li><li><a href='./118.html'>第13章 创建窗口和程序片</a></li><li><a href='./119.html'>第14章 多线程</a></li><li><ul><li><a href='./120.html'>14.1 反应灵敏的用户界面</a></li><li><a href='./121.html'>14.2 共享有限的资源</a></li><li><a href='./122.html'>14.3 堵塞</a></li><li><a href='./123.html'>14.4 优先级</a></li><li><a href='./124.html'>14.5 回顾runnable</a></li><li><a href='./125.html'>14.6 总结</a></li><li><a href='./126.html'>14.7 练习</a></li></ul></li><li><a href='./127.html'>第15章 网络编程</a></li><li><ul><li><a href='./128.html'>15.1 机器的标识</a></li><li><a href='./129.html'>15.2 套接字</a></li><li><a href='./130.html'>15.3 服务多个客户</a></li><li><a href='./131.html'>15.4 数据报</a></li><li><a href='./132.html'>15.5 一个Web应用</a></li><li><a href='./133.html'>15.6 Java与CGI的沟通</a></li><li><a href='./134.html'>15.7 用JDBC连接数据库</a></li><li><a href='./135.html'>15.8 远程方法</a></li><li><a href='./136.html'>15.9 总结</a></li><li><a href='./137.html'>15.10 练习</a></li></ul></li><li><a href='./138.html'>第16章 设计范式</a></li><li><ul><li><a href='./139.html'>16.1 范式的概念</a></li><li><a href='./140.html'>16.2 观察器范式</a></li><li><a href='./141.html'>16.3 模拟垃圾回收站</a></li><li><a href='./142.html'>16.4 改进设计</a></li><li><a href='./143.html'>16.5 抽象的应用</a></li><li><a href='./144.html'>16.6 多重派遣</a></li><li><a href='./145.html'>16.7 访问器范式</a></li><li><a href='./146.html'>16.8 RTTI真的有害吗</a></li><li><a href='./147.html'>16.9 总结</a></li><li><a href='./148.html'>16.10 练习</a></li></ul></li><li><a href='./149.html'>第17章 项目</a></li><li><ul><li><a href='./150.html'>17.1 文字处理</a></li><li><a href='./151.html'>17.2 方法查找工具</a></li><li><a href='./152.html'>17.3 复杂性理论</a></li><li><a href='./153.html'>17.4 总结</a></li><li><a href='./154.html'>17.5 练习</a></li></ul></li><li><a href='./155.html'>附录A 使用非JAVA代码</a></li><li><a href='./156.html'>附录B 对比C++和Java</a></li><li><a href='./157.html'>附录C Java编程规则</a></li><li><a href='./158.html'>附录D 性能</a></li><li><a href='./159.html'>附录E 关于垃圾收集的一些话</a></li><li><a href='./160.html'>附录F 推荐读物</a></li><li></li>
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
<div class="col-xs-8">
	<nav>
		<ul class="pager">
			<li class='previous'><a href='158.html'>&larr; 附录D 性能</a></li>
		<li class='next'><a href='160.html'>附录F 推荐读物&rarr;</a></li>
		</ul>
	</nav>
			<div class="row"><div class="col-xs-12"># 附录E 关于垃圾收集的一些话<br><br><br>“很难相信Java居然能和C++一样快，甚至还能更快一些。”<br><br>据我自己的实践，这种说法确实成立。然而，我也发现许多关于速度的怀疑都来自一些早期的实现方式。由于这些方式并非特别有效，所以没有一个模型可供参考，不能解释Java速度快的原因。<br><br>我之所以想到速度，部分原因是由于C++模型。C++将自己的主要精力放在编译期间“静态”发生的所有事情上，所以程序的运行期版本非常短小和快速。C++也直接建立在C模型的基础上（主要为了向后兼容），但有时仅仅由于它在C中能按特定的方式工作，所以也是C++中最方便的一种方法。最重要的一种情况是C和C++对内存的管理方式，它是某些人觉得Java速度肯定慢的重要依据：在Java中，所有对象都必须在内存“堆”里创建。<br><br>而在C++中，对象是在堆栈中创建的。这样可达到更快的速度，因为当我们进入一个特定的作用域时，堆栈指针会向下移动一个单位，为那个作用域内创建的、以堆栈为基础的所有对象分配存储空间。而当我们离开作用域的时候（调用完毕所有局部构建器后），堆栈指针会向上移动一个单位。然而，在C++里创建“内存堆”（Heap）对象通常会慢得多，因为它建立在C的内存堆基础上。这种内存堆实际是一个大的内存池，要求必须进行再循环（再生）。在C++里调用delete以后，释放的内存会在堆里留下一个洞，所以再调用new的时候，存储分配机制必须进行某种形式的搜索，使对象的存储与堆内任何现成的洞相配，否则就会很快用光堆的存储空间。之所以内存堆的分配会在C++里对性能造成如此重大的性能影响，对可用内存的搜索正是一个重要的原因。所以创建基于堆栈的对象要快得多。<br><br>同样地，由于C++如此多的工作都在编译期间进行，所以必须考虑这方面的因素。但在Java的某些地方，事情的发生却要显得“动态”得多，它会改变模型。创建对象的时候，垃圾收集器的使用对于提高对象创建的速度产生了显著的影响。从表面上看，这种说法似乎有些奇怪——存储空间的释放会对存储空间的分配造成影响，但它正是JVM采取的重要手段之一，这意味着在Java中为堆对象分配存储空间几乎能达到与C++中在堆栈里创建存储空间一样快的速度。<br><br>可将C++的堆（以及更慢的Java堆）想象成一个庭院，每个对象都拥有自己的一块地皮。在以后的某个时间，这种“不动产”会被抛弃，而且必须再生。但在某些JVM里，Java堆的工作方式却是颇有不同的。它更象一条传送带：每次分配了一个新对象后，都会朝前移动。这意味着对象存储空间的分配可以达到非常快的速度。“堆指针”简单地向前移至处女地，所以它与C++的堆栈分配方式几乎是完全相同的（当然，在数据记录上会多花一些开销，但要比搜索存储空间快多了）。<br><br>现在，大家可能注意到了堆事实并非一条传送带。如按那种方式对待它，最终就要求进行大量的页交换（这对性能的发挥会产生巨大干扰），这样终究会用光内存，出现内存分页错误。所以这儿必须采取一个技巧，那就是著名的“垃圾收集器”。它在收集“垃圾”的同时，也负责压缩堆里的所有对象，将“堆指针”移至尽可能靠近传送带开头的地方，远离发生（内存）分页错误的地点。垃圾收集器会重新安排所有东西，使其成为一个高速、无限自由的堆模型，同时游刃有余地分配存储空间。<br><br>为真正掌握它的工作原理，我们首先需要理解不同垃圾收集器（GC）采取的工作方案。一种简单、但速度较慢的GC技术是引用计数。这意味着每个对象都包含了一个引用计数器。每当一个句柄同一个对象连接起来时，引用计数器就会增值。每当一个句柄超出自己的作用域，或者设为null时，引用计数就会减值。这样一来，只要程序处于运行状态，就需要连续进行引用计数管理——尽管这种管理本身的开销比较少。垃圾收集器会在整个对象列表中移动巡视，一旦它发现其中一个引用计数成为0，就释放它占据的存储空间。但这样做也有一个缺点：若对象相互之间进行循环引用，那么即使引用计数不是0，仍有可能属于应收掉的“垃圾”。为了找出这种自引用的组，要求垃圾收集器进行大量额外的工作。引用计数属于垃圾收集的一种类型，但它看起来并不适合在所有JVM方案中采用。<br><br>在速度更快的方案里，垃圾收集并不建立在引用计数的基础上。相反，它们基于这样一个原理：所有非死锁的对象最终都肯定能回溯至一个句柄，该句柄要么存在于堆栈中，要么存在于静态存储空间。这个回溯链可能经历了几层对象。所以，如果从堆栈和静态存储区域开始，并经历所有句柄，就能找出所有活动的对象。对于自己找到的每个句柄，都必须跟踪到它指向的那个对象，然后跟随那个对象中的所有句柄，“跟踪追击”到它们指向的对象……等等，直到遍历了从堆栈或静态存储区域中的句柄发起的整个链接网路为止。中途移经的每个对象都必须仍处于活动状态。注意对于那些特殊的自引用组，并不会出现前述的问题。由于它们根本找不到，所以会自动当作垃圾处理。<br><br>在这里阐述的方法中，JVM采用一种“自适应”的垃圾收集方案。对于它找到的那些活动对象，具体采取的操作取决于当前正在使用的是什么变体。其中一个变体是“停止和复制”。这意味着由于一些不久之后就会非常明显的原因，程序首先会停止运行（并非一种后台收集方案）。随后，已找到的每个活动对象都会从一个内存堆复制到另一个，留下所有的垃圾。除此以外，随着对象复制到新堆，它们会一个接一个地聚焦在一起。这样可使新堆显得更加紧凑（并使新的存储区域可以简单地抽离末尾，就象前面讲述的那样）。<br><br>当然，将一个对象从一处挪到另一处时，指向那个对象的所有句柄（引用）都必须改变。对于那些通过跟踪内存堆的对象而获得的句柄，以及那些静态存储区域，都可以立即改变。但在“遍历”过程中，还有可能遇到指向这个对象的其他句柄。一旦发现这个问题，就当即进行修正（可想象一个散列表将老地址映射成新地址）。<br><br>有两方面的问题使复制收集器显得效率低下。第一个问题是我们拥有两个堆，所有内存都在这两个独立的堆内来回移动，要求付出的管理量是实际需要的两倍。为解决这个问题，有些JVM根据需要分配内存堆，并将一个堆简单地复制到另一个。<br><br>第二个问题是复制。随着程序变得越来越“健壮”，它几乎不产生或产生很少的垃圾。尽管如此，一个副本收集器仍会将所有内存从一处复制到另一处，这显得非常浪费。为避免这个问题，有些JVM能侦测是否没有产生新的垃圾，并随即改换另一种方案（这便是“自适应”的缘由）。另一种方案叫作“标记和清除”，Sun公司的JVM一直采用的都是这种方案。对于常规性的应用，标记和清除显得非常慢，但一旦知道自己不产生垃圾，或者只产生很少的垃圾，它的速度就会非常快。<br><br>标记和清除采用相同的逻辑：从堆栈和静态存储区域开始，并跟踪所有句柄，寻找活动对象。然而，每次发现一个活动对象的时候，就会设置一个标记，为那个对象作上“记号”。但此时尚不收集那个对象。只有在标记过程结束，清除过程才正式开始。在清除过程中，死锁的对象会被释放然而，不会进行任何形式的复制，所以假若收集器决定压缩一个断续的内存堆，它通过移动周围的对象来实现。<br><br>“停止和复制”向我们表明这种类型的垃圾收集并不是在后台进行的；相反，一旦发生垃圾收集，程序就会停止运行。在Sun公司的文档库中，可发现许多地方都将垃圾收集定义成一种低优先级的后台进程，但它只是一种理论上的实验，实际根本不能工作。在实际应用中，Sun的垃圾收集器会在内存减少时运行。除此以外，“标记和清除”也要求程序停止运行。<br><br>正如早先指出的那样，在这里介绍的JVM中，内存是按大块分配的。若分配一个大块头对象，它会获得自己的内存块。严格的“停止和复制”要求在释放旧堆之前，将每个活动的对象从源堆复制到一个新堆，此时会涉及大量的内存转换工作。通过内存块，垃圾收集器通常可利用死块复制对象，就象它进行收集时那样。每个块都有一个生成计数，用于跟踪它是否依然“存活”。通常，只有自上次垃圾收集以来创建的块才会得到压缩；对于其他所有块，如果已从其他某些地方进行了引用，那么生成计数都会溢出。这是许多短期的、临时的对象经常遇到的情况。会周期性地进行一次完整清除工作——大块头的对象仍未复制（只是让它们的生成计数溢出），而那些包含了小对象的块会进行复制和压缩。JVM会监视垃圾收集器的效率，如果由于所有对象都属于长期对象，造成垃圾收集成为浪费时间的一个过程，就会切换到“标记和清除”方案。类似地，JVM会跟踪监视成功的“标记与清除”工作，若内存堆变得越来越“散乱”，就会换回“停止和复制”方案。“自定义”的说法就是从这种行为来的，我们将其最后总结为：“根据情况，自动转换停止和复制／标记和清除这两种模式”。<br><br>JVM还采用了其他许多加速方案。其中一个特别重要的涉及装载器以及JIT编译器。若必须装载一个类（通常是我们首次想创建那个类的一个对象时），会找到.class文件，并将那个类的字节码送入内存。此时，一个方法是用JIT编译所有代码，但这样做有两方面的缺点：它会花更多的时间，若与程序的运行时间综合考虑，编译时间还有可能更长；而且它增大了执行文件的长度（字节码比扩展过的JIT代码精简得多），这有可能造成内存页交换，从而显著放慢一个程序的执行速度。另一种替代办法是：除非确有必要，否则不经JIT编译。这样一来，那些根本不会执行的代码就可能永远得不到JIT的编译。<br><br>由于JVM对浏览器来说是外置的，大家可能希望在使用浏览器的时候从一些JVM的速度提高中获得好处。但非常不幸，JVM目前不能与不同的浏览器进行沟通。为发挥一种特定JVM的潜力，要么使用内建了那种JVM的浏览器，要么只有运行独立的Java应用程序。</div></div>
			<nav>
				<ul class="pager">
				<li class='previous'><a href='158.html'>&larr; 附录D 性能</a></li>
			<li class='next'><a href='160.html'>附录F 推荐读物&rarr;</a></li>
				</ul>
			</nav>
</div>
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
			<!-- /.row -->
			  <hr>
        <!-- Footer -->
        <footer>
            <div class="row">
                <div class="col-xs-12">
                    <p>Copyright &copy; 小龙软件工作室 2016 粤icp备16103410</p>
                </div>
            </div>
        </footer>

    </div>
    <!-- /.container -->

    <!-- jQuery -->
    <script src="../../js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="../../js/bootstrap.min.js"></script>

</body>

</html>
