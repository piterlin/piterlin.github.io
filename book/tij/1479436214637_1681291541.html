<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="content-type" content="text/html;charset=utf-8">
    <meta charset="utf-8">
<meta name="360-site-verification" content="cabcfb5a0f4c0d28d604e8a69e6c0cdb" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="baidu-site-verification" content="HknqsD2zhn" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>java编程思想(thinking in java)-编码助手网</title>
      <meta content="为编码人员提供在线文档、模板等帮助，提升解决问题效率" name="description">
			<meta content="java编程思想(thinking in java) Java, spring, tomcat, servlet, jsp, api doc, bootstrap" name="keywords">
<meta name="sogou_site_verification" content="42nApEZFKO"/>


    <!-- Bootstrap Core CSS -->
    <link href="../../css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="../../css/heroic-features.css" rel="stylesheet">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
		<script>
		var _hmt = _hmt || [];
		(function() {
		  var hm = document.createElement("script");
		  hm.src = "//hm.baidu.com/hm.js?dd1361ca20a10cc161e72d4bc4fef6df";
		  var s = document.getElementsByTagName("script")[0];
		  s.parentNode.insertBefore(hm, s);
		})();
		</script>

</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">编码助手网</a>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav">
                    <li>
                        <a href="/">首页</a>
                    </li>
										<li>
                        <a href="/template.html">模板</a>
                    </li>
										<li>
												<a href="/doc.html">文档</a>
										</li>
                    <li>
                        <a href="/contact.html">联系我们</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Content -->
    <div class="container">

			<div class="row">
					<div class="col-xs-4">
						<h4>java编程思想(thinking in java)</h4>
						<h6>感谢http://quanke.name提供内容</h6>
<ul><li><a href='./1479436214592_-168316990.html'>Introduction</a></li><li><a href='./1479436214605_802664538.html'>写在前面的话</a></li><li><a href='./1479436214605_-791815332.html'>引言</a></li><li><a href='./1479436214605_1266451767.html'>第1章 对象入门</a></li><li><ul><li><a href='./1479436214606_-1211955969.html'>1.1 抽象的进步</a></li><li><a href='./1479436214606_-985491570.html'>1.2 对象的接口</a></li><li><a href='./1479436214606_421738363.html'>1.3 实现方案的隐藏</a></li><li><a href='./1479436214607_1726094433.html'>1.4 方案的重复使用</a></li><li><a href='./1479436214607_-1917493719.html'>1.5 继承：重新使用接口</a></li><li><a href='./1479436214607_-994529289.html'>1.6 多形对象的互换使用</a></li><li><a href='./1479436214608_695543294.html'>1.7 对象的创建和存在时间</a></li><li><a href='./1479436214609_186799536.html'>1.8 违例控制：解决错误</a></li><li><a href='./1479436214609_225257298.html'>1.9 多线程</a></li><li><a href='./1479436214610_-1377857368.html'>1.10 永久性</a></li><li><a href='./1479436214610_-1567485742.html'>1.11 Java和因特网</a></li><li><a href='./1479436214610_-534049255.html'>1.12 分析和设计</a></li><li><a href='./1479436214611_-516206529.html'>1.13 Java还是C++</a></li></ul></li><li><a href='./1479436214611_-833808368.html'>第2章 一切都是对象</a></li><li><ul><li><a href='./1479436214611_160489487.html'>2.1 用句柄操纵对象</a></li><li><a href='./1479436214611_-395400265.html'>2.2 所有对象都必须创建</a></li><li><a href='./1479436214612_-105112715.html'>2.3 绝对不要清除对象</a></li><li><a href='./1479436214612_-1081120728.html'>2.4 新建数据类型：类</a></li><li><a href='./1479436214612_437273775.html'>2.5 方法、自变量和返回值</a></li><li><a href='./1479436214612_968479086.html'>2.6 构建Java程序</a></li><li><a href='./1479436214612_-1963386412.html'>2.7 我们的第一个Java程序</a></li><li><a href='./1479436214613_988202688.html'>2.8 注释和嵌入文档</a></li><li><a href='./1479436214613_-642199972.html'>2.9 编码样式</a></li><li><a href='./1479436214613_-1135594618.html'>2.10 总结</a></li><li><a href='./1479436214613_976703976.html'>2.11 练习</a></li></ul></li><li><a href='./1479436214614_1617201657.html'>第3章 控制程序流程</a></li><li><ul><li><a href='./1479436214614_479400700.html'>3.1 使用Java运算符</a></li><li><a href='./1479436214614_-9479532.html'>3.2 执行控制</a></li><li><a href='./1479436214614_198965659.html'>3.3 总结</a></li><li><a href='./1479436214615_-634539581.html'>3.4 练习</a></li></ul></li><li><a href='./1479436214615_-1049694152.html'>第4章 初始化和清除</a></li><li><ul><li><a href='./1479436214615_-614369641.html'>4.1 用构建器自动初始化</a></li><li><a href='./1479436214615_-2107354158.html'>4.2 方法过载</a></li><li><a href='./1479436214616_2106438365.html'>4.3 清除：收尾和垃圾收集</a></li><li><a href='./1479436214616_-1969096840.html'>4.4 成员初始化</a></li><li><a href='./1479436214616_55724218.html'>4.5 数组初始化</a></li><li><a href='./1479436214616_-51810259.html'>4.6 总结</a></li><li><a href='./1479436214616_749059750.html'>4.7 练习</a></li></ul></li><li><a href='./1479436214617_-1201809261.html'>第5章 隐藏实施过程</a></li><li><ul><li><a href='./1479436214617_75246657.html'>5.1 包：库单元</a></li><li><a href='./1479436214617_-738077386.html'>5.2 Java访问指示符</a></li><li><a href='./1479436214617_-131608479.html'>5.3 接口与实现</a></li><li><a href='./1479436214617_-1940689271.html'>5.4 类访问</a></li><li><a href='./1479436214618_1119703547.html'>5.5 总结</a></li><li><a href='./1479436214618_-768700500.html'>5.6 练习</a></li></ul></li><li><a href='./1479436214618_303969565.html'>第6章 类再生</a></li><li><ul><li><a href='./1479436214618_1498787567.html'>6.1 合成的语法</a></li><li><a href='./1479436214618_1797834651.html'>6.2 继承的语法</a></li><li><a href='./1479436214619_128080957.html'>6.3 合成与继承的结合</a></li><li><a href='./1479436214619_-538376950.html'>6.4 到底选择合成还是继承</a></li><li><a href='./1479436214619_754950718.html'>6.5 protected</a></li><li><a href='./1479436214619_68859466.html'>6.6 累积开发</a></li><li><a href='./1479436214620_1707544672.html'>6.7 上溯造型</a></li><li><a href='./1479436214620_-1441830877.html'>6.8 final关键字</a></li><li><a href='./1479436214620_1153478487.html'>6.9 初始化和类装载</a></li><li><a href='./1479436214620_-39288028.html'>6.10 总结</a></li><li><a href='./1479436214620_537511919.html'>6.11 练习</a></li></ul></li><li><a href='./1479436214621_636771584.html'>第7章 多形性</a></li><li><ul><li><a href='./1479436214621_14200843.html'>7.1 上溯造型</a></li><li><a href='./1479436214621_-125275107.html'>7.2 深入理解</a></li><li><a href='./1479436214621_-1006098686.html'>7.3 覆盖与过载</a></li><li><a href='./1479436214622_1469935979.html'>7.4 抽象类和方法</a></li><li><a href='./1479436214622_-321517007.html'>7.5 接口</a></li><li><a href='./1479436214622_-1548998791.html'>7.6 内部类</a></li><li><a href='./1479436214622_-1125287817.html'>7.7 构建器和多形性</a></li><li><a href='./1479436214622_1541346557.html'>7.8 通过继承进行设计</a></li><li><a href='./1479436214623_1527391664.html'>7.9 总结</a></li><li><a href='./1479436214623_-953872192.html'>7.10 练习</a></li></ul></li><li><a href='./1479436214623_-1694327281.html'>第8章 对象的容纳</a></li><li><ul><li><a href='./1479436214623_1677953038.html'>8.1 数组</a></li><li><a href='./1479436214623_157279663.html'>8.2 集合</a></li><li><a href='./1479436214624_2028486897.html'>8.3 枚举器（反复器）</a></li><li><a href='./1479436214624_1552417959.html'>8.4 集合的类型</a></li><li><a href='./1479436214624_-1236839872.html'>8.5 排序</a></li><li><a href='./1479436214624_948884352.html'>8.6 通用集合库</a></li><li><a href='./1479436214624_-29314847.html'>8.7 新集合</a></li><li><a href='./1479436214625_950741899.html'>8.8 总结</a></li><li><a href='./1479436214625_-235386019.html'>8.9 练习</a></li></ul></li><li><a href='./1479436214625_-1144170168.html'>第9章 违例差错控制</a></li><li><ul><li><a href='./1479436214625_1164481198.html'>9.1 基本违例</a></li><li><a href='./1479436214625_639309640.html'>9.2 违例的捕获</a></li><li><a href='./1479436214625_545387660.html'>9.3 标准Java违例</a></li><li><a href='./1479436214625_1703684624.html'>9.4 创建自己的违例</a></li><li><a href='./1479436214626_-1814781625.html'>9.5 违例的限制</a></li><li><a href='./1479436214626_1362968450.html'>9.6 用finally清除</a></li><li><a href='./1479436214626_1696138810.html'>9.7 构建器</a></li><li><a href='./1479436214626_-946669500.html'>9.8 违例匹配</a></li><li><a href='./1479436214626_1369629725.html'>9.9 总结</a></li><li><a href='./1479436214626_1887454245.html'>9.10 练习</a></li></ul></li><li><a href='./1479436214627_-823192075.html'>第10章 Java IO系统</a></li><li><ul><li><a href='./1479436214627_793225325.html'>10.1 输入和输出</a></li><li><a href='./1479436214627_-1441186029.html'>10.2 增添属性和有用的接口</a></li><li><a href='./1479436214627_1039462397.html'>10.3 本身的缺陷：RandomAccessFile</a></li><li><a href='./1479436214627_1841380738.html'>10.4 File类</a></li><li><a href='./1479436214628_2095064408.html'>10.5 IO流的典型应用</a></li><li><a href='./1479436214628_1699205963.html'>10.6 StreamTokenizer</a></li><li><a href='./1479436214628_-1183832916.html'>10.7 Java 1.1的IO流</a></li><li><a href='./1479436214628_1169764652.html'>10.8 压缩</a></li><li><a href='./1479436214628_599949674.html'>10.9 对象序列化</a></li><li><a href='./1479436214629_822501598.html'>10.10 总结</a></li><li><a href='./1479436214629_784582642.html'>10.11 练习</a></li></ul></li><li><a href='./1479436214629_-446109494.html'>第11章 运行期类型鉴定</a></li><li><ul><li><a href='./1479436214629_615980680.html'>11.1 对RTTI的需要</a></li><li><a href='./1479436214629_1591261577.html'>11.2 RTTI语法</a></li><li><a href='./1479436214629_-479724471.html'>11.3 反射：运行期类信息</a></li><li><a href='./1479436214630_1962275414.html'>11.4 总结</a></li><li><a href='./1479436214630_-104101779.html'>11.5 练习</a></li></ul></li><li><a href='./1479436214630_2105662301.html'>第12章 传递和返回对象</a></li><li><ul><li><a href='./1479436214630_-381058478.html'>12.1 传递句柄</a></li><li><a href='./1479436214630_1317862656.html'>12.2 制作本地副本</a></li><li><a href='./1479436214630_66286946.html'>12.3 克隆的控制</a></li><li><a href='./1479436214631_1628962510.html'>12.4 只读类</a></li><li><a href='./1479436214631_178950784.html'>12.5 总结</a></li><li><a href='./1479436214631_204549698.html'>12.6 练习</a></li></ul></li><li><a href='./1479436214631_1667056471.html'>第13章 创建窗口和程序片</a></li><li><a href='./1479436214631_1646591288.html'>第14章 多线程</a></li><li><ul><li><a href='./1479436214631_-2057627207.html'>14.1 反应灵敏的用户界面</a></li><li><a href='./1479436214631_1635675213.html'>14.2 共享有限的资源</a></li><li><a href='./1479436214632_1587335383.html'>14.3 堵塞</a></li><li><a href='./1479436214632_1322789348.html'>14.4 优先级</a></li><li><a href='./1479436214632_1679851836.html'>14.5 回顾runnable</a></li><li><a href='./1479436214632_-914514060.html'>14.6 总结</a></li><li><a href='./1479436214632_1301544438.html'>14.7 练习</a></li></ul></li><li><a href='./1479436214633_1637559906.html'>第15章 网络编程</a></li><li><ul><li><a href='./1479436214633_-2140545630.html'>15.1 机器的标识</a></li><li><a href='./1479436214633_946775708.html'>15.2 套接字</a></li><li><a href='./1479436214634_1854884592.html'>15.3 服务多个客户</a></li><li><a href='./1479436214634_1410414288.html'>15.4 数据报</a></li><li><a href='./1479436214634_224372951.html'>15.5 一个Web应用</a></li><li><a href='./1479436214634_-1622230225.html'>15.6 Java与CGI的沟通</a></li><li><a href='./1479436214634_-903287570.html'>15.7 用JDBC连接数据库</a></li><li><a href='./1479436214634_-416599191.html'>15.8 远程方法</a></li><li><a href='./1479436214635_-917204139.html'>15.9 总结</a></li><li><a href='./1479436214635_-540223303.html'>15.10 练习</a></li></ul></li><li><a href='./1479436214635_339847129.html'>第16章 设计范式</a></li><li><ul><li><a href='./1479436214635_1826776975.html'>16.1 范式的概念</a></li><li><a href='./1479436214635_1309397010.html'>16.2 观察器范式</a></li><li><a href='./1479436214636_132034955.html'>16.3 模拟垃圾回收站</a></li><li><a href='./1479436214636_1756675694.html'>16.4 改进设计</a></li><li><a href='./1479436214636_-1966590010.html'>16.5 抽象的应用</a></li><li><a href='./1479436214636_-1831214784.html'>16.6 多重派遣</a></li><li><a href='./1479436214636_1935634882.html'>16.7 访问器范式</a></li><li><a href='./1479436214636_1843093443.html'>16.8 RTTI真的有害吗</a></li><li><a href='./1479436214636_-1838860121.html'>16.9 总结</a></li><li><a href='./1479436214637_-1901505940.html'>16.10 练习</a></li></ul></li><li><a href='./1479436214637_-387290815.html'>第17章 项目</a></li><li><ul><li><a href='./1479436214637_-498587551.html'>17.1 文字处理</a></li><li><a href='./1479436214637_1300299412.html'>17.2 方法查找工具</a></li><li><a href='./1479436214637_1681291541.html'>17.3 复杂性理论</a></li><li><a href='./1479436214637_-1113877505.html'>17.4 总结</a></li><li><a href='./1479436214638_-1637352061.html'>17.5 练习</a></li></ul></li><li><a href='./1479436214638_931172498.html'>附录A 使用非JAVA代码</a></li><li><a href='./1479436214638_882880730.html'>附录B 对比C++和Java</a></li><li><a href='./1479436214638_-283304223.html'>附录C Java编程规则</a></li><li><a href='./1479436214638_-1842547113.html'>附录D 性能</a></li><li><a href='./1479436214638_749950023.html'>附录E 关于垃圾收集的一些话</a></li><li><a href='./1479436214639_2079199942.html'>附录F 推荐读物</a></li><li></li>
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
					<div class="col-xs-8">
# 17.3 复杂性理论<br><br>下面要介绍的程序的前身是由Larry O'Brien原创的一些代码，并以由Craig Reynolds于1986年编制的“Boids”程序为基础，当时是为了演示复杂性理论的一个特殊问题，名为“凸显”（Emergence）。<br><br>这儿要达到的目标是通过为每种动物都规定少许简单的规则，从而逼真地再现动物的群聚行为。每个动物都能看到看到整个环境以及环境中的其他动物，但它只与一系列附近的“群聚伙伴”打交道。动物的移动基于三个简单的引导行为：<br><br>(1) 分隔：避免本地群聚伙伴过于拥挤。<br><br>(2) 方向：遵从本地群聚伙伴的普遍方向。<br><br>(3) 聚合：朝本地群聚伙伴组的中心移动。<br><br>更复杂的模型甚至可以包括障碍物的因素，动物能预知和避免与障碍冲突的能力，所以它们能围绕环境中的固定物体自由活动。除此以外，动物也可能有自己的特殊目标，这也许会造成群体按特定的路径前进。为简化讨论，避免障碍以及目标搜寻的因素并未包括到这里建立的模型中。<br><br>尽管计算机本身比较简陋，而且采用的规则也相当简单，但结果看起来是真实的。也就是说，相当逼真的行为从这个简单的模型中“凸显”出来了。<br><br>程序以合成到一起的应用程序／程序片的形式提供：<br><br>```<br>//: FieldOBeasts.java<br>// Demonstration of complexity theory; simulates <br>// herding behavior in animals. Adapted from<br>// a program by Larry O'Brien lobrien@msn.com<br>import java.awt.*;<br>import java.awt.event.*;<br>import java.applet.*;<br>import java.util.*;<br><br>class Beast {<br>  int<br>    x, y,            // Screen position<br>    currentSpeed;    // Pixels per second<br>  float currentDirection;  // Radians<br>  Color color;      // Fill color<br>  FieldOBeasts field; // Where the Beast roams<br>  static final int GSIZE = 10; // Graphic size<br><br>  public Beast(FieldOBeasts f, int x, int y, <br>      float cD, int cS, Color c) {<br>    field = f;<br>    this.x = x;<br>    this.y = y;<br>    currentDirection = cD;<br>    currentSpeed = cS;<br>    color = c;<br>  }<br>  public void step() {<br>    // You move based on those within your sight:<br>    Vector seen = field.beastListInSector(this);<br>    // If you're not out in front<br>    if(seen.size() > 0) {<br>      // Gather data on those you see<br>      int totalSpeed = 0;<br>      float totalBearing = 0.0f;<br>      float distanceToNearest = 100000.0f;<br>      Beast nearestBeast = <br>        (Beast)seen.elementAt(0);<br>      Enumeration e = seen.elements();<br>      while(e.hasMoreElements()) {<br>        Beast aBeast = (Beast) e.nextElement();<br>        totalSpeed += aBeast.currentSpeed;<br>        float bearing = <br>          aBeast.bearingFromPointAlongAxis(<br>            x, y, currentDirection);<br>        totalBearing += bearing;<br>        float distanceToBeast = <br>          aBeast.distanceFromPoint(x, y);<br>        if(distanceToBeast < distanceToNearest) {<br>          nearestBeast = aBeast;<br>          distanceToNearest = distanceToBeast;<br>        }<br>      }<br>      // Rule 1: Match average speed of those <br>      // in the list:<br>      currentSpeed = totalSpeed / seen.size();<br>      // Rule 2: Move towards the perceived<br>      // center of gravity of the herd:<br>      currentDirection = <br>        totalBearing / seen.size();<br>      // Rule 3: Maintain a minimum distance <br>      // from those around you:<br>      if(distanceToNearest <= <br>         field.minimumDistance) {<br>        currentDirection = <br>          nearestBeast.currentDirection;<br>        currentSpeed = nearestBeast.currentSpeed;<br>        if(currentSpeed > field.maxSpeed) {<br>          currentSpeed = field.maxSpeed;<br>        }<br>      }<br>    } <br>    else {  // You are in front, so slow down<br>      currentSpeed = <br>        (int)(currentSpeed * field.decayRate);<br>    }<br>    // Make the beast move:<br>    x += (int)(Math.cos(currentDirection) <br>               * currentSpeed);<br>    y += (int)(Math.sin(currentDirection)<br>               * currentSpeed);<br>    x %= field.xExtent;<br>    y %= field.yExtent;<br>    if(x < 0)<br>      x += field.xExtent;<br>    if(y < 0)<br>      y += field.yExtent;<br>  }<br>  public float bearingFromPointAlongAxis (<br>      int originX, int originY, float axis) {<br>    // Returns bearing angle of the current Beast<br>    // in the world coordiante system<br>    try {<br>      double bearingInRadians = <br>        Math.atan(<br>          (this.y - originY) / <br>          (this.x - originX));<br>      // Inverse tan has two solutions, so you <br>      // have to correct for other quarters:<br>      if(x < originX) {  <br>        if(y < originY) {<br>          bearingInRadians += - (float)Math.PI;<br>        } <br>        else {<br>          bearingInRadians = <br>            (float)Math.PI - bearingInRadians;<br>        }<br>      }<br>      // Just subtract the axis (in radians):<br>      return (float) (axis - bearingInRadians);<br>    } catch(ArithmeticException aE) {<br>      // Divide by 0 error possible on this<br>      if(x > originX) {<br>          return 0;<br>      } <br>      else<br>        return (float) Math.PI;<br>    }<br>  }<br>  public float distanceFromPoint(int x1, int y1){<br>    return (float) Math.sqrt(<br>      Math.pow(x1 - x, 2) + <br>      Math.pow(y1 - y, 2));<br>  }<br>  public Point position() { <br>    return new Point(x, y);<br>  }<br>  // Beasts know how to draw themselves:<br>  public void draw(Graphics g) {<br>    g.setColor(color);<br>    int directionInDegrees = (int)(<br>      (currentDirection * 360) / (2 * Math.PI));<br>    int startAngle = directionInDegrees - <br>      FieldOBeasts.halfFieldOfView;<br>    int endAngle = 90;<br>    g.fillArc(x, y, GSIZE, GSIZE, <br>      startAngle, endAngle);<br>  }<br>}<br><br>public class FieldOBeasts extends Applet <br>    implements Runnable {<br>  private Vector beasts;<br>  static float <br>    fieldOfView = <br>      (float) (Math.PI / 4), // In radians<br>    // Deceleration % per second:<br>    decayRate = 1.0f, <br>    minimumDistance = 10f; // In pixels<br>  static int<br>    halfFieldOfView = (int)(<br>      (fieldOfView * 360) / (2 * Math.PI)),<br>    xExtent = 0,<br>    yExtent = 0,<br>    numBeasts = 50,<br>    maxSpeed = 20; // Pixels/second<br>  boolean uniqueColors = true;<br>  Thread thisThread;<br>  int delay = 25;<br>  public void init() {<br>    if (xExtent == 0 && yExtent == 0) {<br>      xExtent = Integer.parseInt(<br>        getParameter("xExtent"));<br>      yExtent = Integer.parseInt(<br>        getParameter("yExtent"));<br>    }<br>    beasts = <br>      makeBeastVector(numBeasts, uniqueColors);<br>    // Now start the beasts a-rovin':<br>    thisThread = new Thread(this);<br>    thisThread.start();<br>  }<br>  public void run() {<br>    while(true) {<br>      for(int i = 0; i < beasts.size(); i++){<br>        Beast b = (Beast) beasts.elementAt(i);<br>        b.step();<br>      }<br>      try {<br>        thisThread.sleep(delay);<br>      } catch(InterruptedException ex){}<br>      repaint(); // Otherwise it won't update<br>    }<br>  }<br>  Vector makeBeastVector(<br>      int quantity, boolean uniqueColors) {<br>    Vector newBeasts = new Vector();<br>    Random generator = new Random();<br>    // Used only if uniqueColors is on:<br>    double cubeRootOfBeastNumber = <br>      Math.pow((double)numBeasts, 1.0 / 3.0);<br>    float colorCubeStepSize = <br>      (float) (1.0 / cubeRootOfBeastNumber);<br>    float r = 0.0f;<br>    float g = 0.0f;<br>    float b = 0.0f;<br>    for(int i = 0; i < quantity; i++) {<br>      int x = <br>        (int) (generator.nextFloat() * xExtent);<br>      if(x > xExtent - Beast.GSIZE) <br>        x -= Beast.GSIZE;<br>      int y = <br>        (int) (generator.nextFloat() * yExtent);<br>      if(y > yExtent - Beast.GSIZE) <br>        y -= Beast.GSIZE;<br>      float direction = (float)(<br>        generator.nextFloat() * 2 * Math.PI);<br>      int speed = (int)(<br>        generator.nextFloat() * (float)maxSpeed);<br>      if(uniqueColors) {<br>        r += colorCubeStepSize;<br>        if(r > 1.0) {<br>          r -= 1.0f;<br>          g += colorCubeStepSize;<br>          if( g > 1.0) {<br>            g -= 1.0f;<br>            b += colorCubeStepSize;<br>            if(b > 1.0) <br>              b -= 1.0f;<br>          }<br>        }<br>      }<br>      newBeasts.addElement(<br>        new Beast(this, x, y, direction, speed, <br>          new Color(r,g,b)));<br>    }<br>    return newBeasts;<br>  }<br>  public Vector beastListInSector(Beast viewer) {<br>    Vector output = new Vector();<br>    Enumeration e = beasts.elements();<br>    Beast aBeast = (Beast)beasts.elementAt(0);<br>    int counter = 0;<br>    while(e.hasMoreElements()) {<br>      aBeast = (Beast) e.nextElement();<br>      if(aBeast != viewer) {<br>        Point p = aBeast.position();<br>        Point v = viewer.position();<br>        float bearing = <br>          aBeast.bearingFromPointAlongAxis(<br>            v.x, v.y, viewer.currentDirection);<br>        if(Math.abs(bearing) < fieldOfView / 2)<br>         output.addElement(aBeast);<br>      }<br>    }<br>    return output;<br>  }<br>  public void paint(Graphics g)  {<br>    Enumeration e = beasts.elements();<br>    while(e.hasMoreElements()) {<br>      ((Beast)e.nextElement()).draw(g);<br>    }<br>  }<br>  public static void main(String[] args)   {<br>    FieldOBeasts field = new FieldOBeasts();<br>    field.xExtent = 640;<br>    field.yExtent = 480;<br>    Frame frame = new Frame("Field 'O Beasts");<br>    // Optionally use a command-line argument<br>    // for the sleep time:<br>    if(args.length >= 1)<br>      field.delay = Integer.parseInt(args[0]);<br>    frame.addWindowListener(<br>      new WindowAdapter() {<br>        public void windowClosing(WindowEvent e) {<br>          System.exit(0);<br>        }<br>      });<br>    frame.add(field, BorderLayout.CENTER);<br>    frame.setSize(640,480);<br>    field.init();<br>    field.start();<br>    frame.setVisible(true);<br>  }<br>} ///:~<br>```<br><br>尽管这并非对Craig Reynold的“Boids”例子中的行为完美重现，但它却展现出了自己独有的迷人之外。通过对数字进行调整，即可进行全面的修改。至于与这种群聚行为有关的更多的情况，大家可以访问Craig Reynold的主页——在那个地方，甚至还提供了Boids一个公开的3D展示版本：<br><br>http://www.hmt.com/cwr/boids.html<br><br>为了将这个程序作为一个程序片运行，请在HTML文件中设置下述程序片标志：<br><br>```<br><applet<br>code=FieldOBeasts<br>width=640<br>height=480><br><param name=xExtent value = "640"><br><param name=yExtent value = "480"><br></applet><br>```<br>
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
			</div>
			<!-- /.row -->
			  <hr>
        <!-- Footer -->
        <footer>
            <div class="row">
                <div class="col-lg-12">
                    <p>Copyright &copy; 小龙软件工作室 2016</p>
                </div>
            </div>
        </footer>

    </div>
    <!-- /.container -->

    <!-- jQuery -->
    <script src="../../js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="../../js/bootstrap.min.js"></script>

</body>

</html>
