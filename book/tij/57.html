<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="content-type" content="text/html;charset=utf-8">
    <meta charset="utf-8">
<meta name="360-site-verification" content="cabcfb5a0f4c0d28d604e8a69e6c0cdb" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="baidu-site-verification" content="HknqsD2zhn" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>java编程思想(thinking in java)-编码助手网</title>
      <meta content="为编码人员提供在线文档、模板等帮助，提升解决问题效率" name="description">
			<meta content="java编程思想(thinking in java) Java, spring, tomcat, servlet, jsp, api doc, bootstrap" name="keywords">
<meta name="sogou_site_verification" content="42nApEZFKO"/>


    <!-- Bootstrap Core CSS -->
    <link href="../../css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="../../css/heroic-features.css" rel="stylesheet">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
		<script>
		var _hmt = _hmt || [];
		(function() {
		  var hm = document.createElement("script");
		  hm.src = "//hm.baidu.com/hm.js?dd1361ca20a10cc161e72d4bc4fef6df";
		  var s = document.getElementsByTagName("script")[0];
		  s.parentNode.insertBefore(hm, s);
		})();
		</script>

</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">编码助手网</a>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav">
                    <li>
                        <a href="/">首页</a>
                    </li>
										<li>
                        <a href="/template.html">模板</a>
                    </li>
										<li>
												<a href="/doc.html">文档</a>
										</li>
                    <li>
                        <a href="/contact.html">联系我们</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Content -->
    <div class="container">

			<div class="row">
					<div class="col-xs-4">
						<h4>java编程思想(thinking in java)</h4>
						<h6>感谢quanke.name提供内容</h6>
<ul><li><a href='./0.html'>Introduction</a></li><li><a href='./1.html'>写在前面的话</a></li><li><a href='./2.html'>引言</a></li><li><a href='./3.html'>第1章 对象入门</a></li><li><ul><li><a href='./4.html'>1.1 抽象的进步</a></li><li><a href='./5.html'>1.2 对象的接口</a></li><li><a href='./6.html'>1.3 实现方案的隐藏</a></li><li><a href='./7.html'>1.4 方案的重复使用</a></li><li><a href='./8.html'>1.5 继承：重新使用接口</a></li><li><a href='./9.html'>1.6 多形对象的互换使用</a></li><li><a href='./10.html'>1.7 对象的创建和存在时间</a></li><li><a href='./11.html'>1.8 违例控制：解决错误</a></li><li><a href='./12.html'>1.9 多线程</a></li><li><a href='./13.html'>1.10 永久性</a></li><li><a href='./14.html'>1.11 Java和因特网</a></li><li><a href='./15.html'>1.12 分析和设计</a></li><li><a href='./16.html'>1.13 Java还是C++</a></li></ul></li><li><a href='./17.html'>第2章 一切都是对象</a></li><li><ul><li><a href='./18.html'>2.1 用句柄操纵对象</a></li><li><a href='./19.html'>2.2 所有对象都必须创建</a></li><li><a href='./20.html'>2.3 绝对不要清除对象</a></li><li><a href='./21.html'>2.4 新建数据类型：类</a></li><li><a href='./22.html'>2.5 方法、自变量和返回值</a></li><li><a href='./23.html'>2.6 构建Java程序</a></li><li><a href='./24.html'>2.7 我们的第一个Java程序</a></li><li><a href='./25.html'>2.8 注释和嵌入文档</a></li><li><a href='./26.html'>2.9 编码样式</a></li><li><a href='./27.html'>2.10 总结</a></li><li><a href='./28.html'>2.11 练习</a></li></ul></li><li><a href='./29.html'>第3章 控制程序流程</a></li><li><ul><li><a href='./30.html'>3.1 使用Java运算符</a></li><li><a href='./31.html'>3.2 执行控制</a></li><li><a href='./32.html'>3.3 总结</a></li><li><a href='./33.html'>3.4 练习</a></li></ul></li><li><a href='./34.html'>第4章 初始化和清除</a></li><li><ul><li><a href='./35.html'>4.1 用构建器自动初始化</a></li><li><a href='./36.html'>4.2 方法过载</a></li><li><a href='./37.html'>4.3 清除：收尾和垃圾收集</a></li><li><a href='./38.html'>4.4 成员初始化</a></li><li><a href='./39.html'>4.5 数组初始化</a></li><li><a href='./40.html'>4.6 总结</a></li><li><a href='./41.html'>4.7 练习</a></li></ul></li><li><a href='./42.html'>第5章 隐藏实施过程</a></li><li><ul><li><a href='./43.html'>5.1 包：库单元</a></li><li><a href='./44.html'>5.2 Java访问指示符</a></li><li><a href='./45.html'>5.3 接口与实现</a></li><li><a href='./46.html'>5.4 类访问</a></li><li><a href='./47.html'>5.5 总结</a></li><li><a href='./48.html'>5.6 练习</a></li></ul></li><li><a href='./49.html'>第6章 类再生</a></li><li><ul><li><a href='./50.html'>6.1 合成的语法</a></li><li><a href='./51.html'>6.2 继承的语法</a></li><li><a href='./52.html'>6.3 合成与继承的结合</a></li><li><a href='./53.html'>6.4 到底选择合成还是继承</a></li><li><a href='./54.html'>6.5 protected</a></li><li><a href='./55.html'>6.6 累积开发</a></li><li><a href='./56.html'>6.7 上溯造型</a></li><li><a href='./57.html'>6.8 final关键字</a></li><li><a href='./58.html'>6.9 初始化和类装载</a></li><li><a href='./59.html'>6.10 总结</a></li><li><a href='./60.html'>6.11 练习</a></li></ul></li><li><a href='./61.html'>第7章 多形性</a></li><li><ul><li><a href='./62.html'>7.1 上溯造型</a></li><li><a href='./63.html'>7.2 深入理解</a></li><li><a href='./64.html'>7.3 覆盖与过载</a></li><li><a href='./65.html'>7.4 抽象类和方法</a></li><li><a href='./66.html'>7.5 接口</a></li><li><a href='./67.html'>7.6 内部类</a></li><li><a href='./68.html'>7.7 构建器和多形性</a></li><li><a href='./69.html'>7.8 通过继承进行设计</a></li><li><a href='./70.html'>7.9 总结</a></li><li><a href='./71.html'>7.10 练习</a></li></ul></li><li><a href='./72.html'>第8章 对象的容纳</a></li><li><ul><li><a href='./73.html'>8.1 数组</a></li><li><a href='./74.html'>8.2 集合</a></li><li><a href='./75.html'>8.3 枚举器（反复器）</a></li><li><a href='./76.html'>8.4 集合的类型</a></li><li><a href='./77.html'>8.5 排序</a></li><li><a href='./78.html'>8.6 通用集合库</a></li><li><a href='./79.html'>8.7 新集合</a></li><li><a href='./80.html'>8.8 总结</a></li><li><a href='./81.html'>8.9 练习</a></li></ul></li><li><a href='./82.html'>第9章 违例差错控制</a></li><li><ul><li><a href='./83.html'>9.1 基本违例</a></li><li><a href='./84.html'>9.2 违例的捕获</a></li><li><a href='./85.html'>9.3 标准Java违例</a></li><li><a href='./86.html'>9.4 创建自己的违例</a></li><li><a href='./87.html'>9.5 违例的限制</a></li><li><a href='./88.html'>9.6 用finally清除</a></li><li><a href='./89.html'>9.7 构建器</a></li><li><a href='./90.html'>9.8 违例匹配</a></li><li><a href='./91.html'>9.9 总结</a></li><li><a href='./92.html'>9.10 练习</a></li></ul></li><li><a href='./93.html'>第10章 Java IO系统</a></li><li><ul><li><a href='./94.html'>10.1 输入和输出</a></li><li><a href='./95.html'>10.2 增添属性和有用的接口</a></li><li><a href='./96.html'>10.3 本身的缺陷：RandomAccessFile</a></li><li><a href='./97.html'>10.4 File类</a></li><li><a href='./98.html'>10.5 IO流的典型应用</a></li><li><a href='./99.html'>10.6 StreamTokenizer</a></li><li><a href='./100.html'>10.7 Java 1.1的IO流</a></li><li><a href='./101.html'>10.8 压缩</a></li><li><a href='./102.html'>10.9 对象序列化</a></li><li><a href='./103.html'>10.10 总结</a></li><li><a href='./104.html'>10.11 练习</a></li></ul></li><li><a href='./105.html'>第11章 运行期类型鉴定</a></li><li><ul><li><a href='./106.html'>11.1 对RTTI的需要</a></li><li><a href='./107.html'>11.2 RTTI语法</a></li><li><a href='./108.html'>11.3 反射：运行期类信息</a></li><li><a href='./109.html'>11.4 总结</a></li><li><a href='./110.html'>11.5 练习</a></li></ul></li><li><a href='./111.html'>第12章 传递和返回对象</a></li><li><ul><li><a href='./112.html'>12.1 传递句柄</a></li><li><a href='./113.html'>12.2 制作本地副本</a></li><li><a href='./114.html'>12.3 克隆的控制</a></li><li><a href='./115.html'>12.4 只读类</a></li><li><a href='./116.html'>12.5 总结</a></li><li><a href='./117.html'>12.6 练习</a></li></ul></li><li><a href='./118.html'>第13章 创建窗口和程序片</a></li><li><a href='./119.html'>第14章 多线程</a></li><li><ul><li><a href='./120.html'>14.1 反应灵敏的用户界面</a></li><li><a href='./121.html'>14.2 共享有限的资源</a></li><li><a href='./122.html'>14.3 堵塞</a></li><li><a href='./123.html'>14.4 优先级</a></li><li><a href='./124.html'>14.5 回顾runnable</a></li><li><a href='./125.html'>14.6 总结</a></li><li><a href='./126.html'>14.7 练习</a></li></ul></li><li><a href='./127.html'>第15章 网络编程</a></li><li><ul><li><a href='./128.html'>15.1 机器的标识</a></li><li><a href='./129.html'>15.2 套接字</a></li><li><a href='./130.html'>15.3 服务多个客户</a></li><li><a href='./131.html'>15.4 数据报</a></li><li><a href='./132.html'>15.5 一个Web应用</a></li><li><a href='./133.html'>15.6 Java与CGI的沟通</a></li><li><a href='./134.html'>15.7 用JDBC连接数据库</a></li><li><a href='./135.html'>15.8 远程方法</a></li><li><a href='./136.html'>15.9 总结</a></li><li><a href='./137.html'>15.10 练习</a></li></ul></li><li><a href='./138.html'>第16章 设计范式</a></li><li><ul><li><a href='./139.html'>16.1 范式的概念</a></li><li><a href='./140.html'>16.2 观察器范式</a></li><li><a href='./141.html'>16.3 模拟垃圾回收站</a></li><li><a href='./142.html'>16.4 改进设计</a></li><li><a href='./143.html'>16.5 抽象的应用</a></li><li><a href='./144.html'>16.6 多重派遣</a></li><li><a href='./145.html'>16.7 访问器范式</a></li><li><a href='./146.html'>16.8 RTTI真的有害吗</a></li><li><a href='./147.html'>16.9 总结</a></li><li><a href='./148.html'>16.10 练习</a></li></ul></li><li><a href='./149.html'>第17章 项目</a></li><li><ul><li><a href='./150.html'>17.1 文字处理</a></li><li><a href='./151.html'>17.2 方法查找工具</a></li><li><a href='./152.html'>17.3 复杂性理论</a></li><li><a href='./153.html'>17.4 总结</a></li><li><a href='./154.html'>17.5 练习</a></li></ul></li><li><a href='./155.html'>附录A 使用非JAVA代码</a></li><li><a href='./156.html'>附录B 对比C++和Java</a></li><li><a href='./157.html'>附录C Java编程规则</a></li><li><a href='./158.html'>附录D 性能</a></li><li><a href='./159.html'>附录E 关于垃圾收集的一些话</a></li><li><a href='./160.html'>附录F 推荐读物</a></li><li></li>
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
<div class="col-xs-8">
	<nav>
		<ul class="pager">
			<li class='previous'><a href='56.html'>&larr; 6.7 上溯造型</a></li>
		<li class='next'><a href='58.html'>6.9 初始化和类装载&rarr;</a></li>
		</ul>
	</nav>
			<div class="row"><div class="col-xs-12"># 6.8 final关键字<br><br><br>由于语境（应用环境）不同，final关键字的含义可能会稍微产生一些差异。但它最一般的意思就是声明“这个东西不能改变”。之所以要禁止改变，可能是考虑到两方面的因素：设计或效率。由于这两个原因颇有些区别，所以也许会造成final关键字的误用。<br><br>在接下去的小节里，我们将讨论final关键字的三种应用场合：数据、方法以及类。<br><br>6.8.1 final数据<br><br>许多程序设计语言都有自己的办法告诉编译器某个数据是“常数”。常数主要应用于下述两个方面：<br><br>(1) 编译期常数，它永远不会改变<br><br>(2) 在运行期初始化的一个值，我们不希望它发生变化<br><br>对于编译期的常数，编译器（程序）可将常数值“封装”到需要的计算过程里。也就是说，计算可在编译期间提前执行，从而节省运行时的一些开销。在Java中，这些形式的常数必须属于基本数据类型（Primitives），而且要用final关键字进行表达。在对这样的一个常数进行定义的时候，必须给出一个值。<br><br>无论static还是final字段，都只能存储一个数据，而且不得改变。<br><br>若随同对象句柄使用final，而不是基本数据类型，它的含义就稍微让人有点儿迷糊了。对于基本数据类型，final会将值变成一个常数；但对于对象句柄，final会将句柄变成一个常数。进行声明时，必须将句柄初始化到一个具体的对象。而且永远不能将句柄变成指向另一个对象。然而，对象本身是可以修改的。Java对此未提供任何手段，可将一个对象直接变成一个常数（但是，我们可自己编写一个类，使其中的对象具有“常数”效果）。这一限制也适用于数组，它也属于对象。<br><br>下面是演示final字段用法的一个例子：<br><br>```<br>//: FinalData.java<br>// The effect of final on fields<br><br>class Value {<br>  int i = 1;<br>}<br><br>public class FinalData {<br>  // Can be compile-time constants<br>  final int i1 = 9;<br>  static final int I2 = 99;<br>  // Typical public constant:<br>  public static final int I3 = 39;<br>  // Cannot be compile-time constants:<br>  final int i4 = (int)(Math.random()*20);<br>  static final int i5 = (int)(Math.random()*20);<br>  <br>  Value v1 = new Value();<br>  final Value v2 = new Value();<br>  static final Value v3 = new Value();<br>  //! final Value v4; // Pre-Java 1.1 Error: <br>                      // no initializer<br>  // Arrays:<br>  final int[] a = { 1, 2, 3, 4, 5, 6 };<br><br>  public void print(String id) {<br>    System.out.println(<br>      id + ": " + "i4 = " + i4 + <br>      ", i5 = " + i5);<br>  }<br>  public static void main(String[] args) {<br>    FinalData fd1 = new FinalData();<br>    //! fd1.i1++; // Error: can't change value<br>    fd1.v2.i++; // Object isn't constant!<br>    fd1.v1 = new Value(); // OK -- not final<br>    for(int i = 0; i < fd1.a.length; i++)<br>      fd1.a[i]++; // Object isn't constant!<br>    //! fd1.v2 = new Value(); // Error: Can't <br>    //! fd1.v3 = new Value(); // change handle<br>    //! fd1.a = new int[3];<br><br>    fd1.print("fd1");<br>    System.out.println("Creating new FinalData");<br>    FinalData fd2 = new FinalData();<br>    fd1.print("fd1");<br>    fd2.print("fd2");<br>  }<br>} ///:~<br>```<br><br>由于i1和I2都是具有final属性的基本数据类型，并含有编译期的值，所以它们除了能作为编译期的常数使用外，在任何导入方式中也不会出现任何不同。I3是我们体验此类常数定义时更典型的一种方式：public表示它们可在包外使用；Static强调它们只有一个；而final表明它是一个常数。注意对于含有固定初始化值（即编译期常数）的fianl static基本数据类型，它们的名字根据规则要全部采用大写。也要注意i5在编译期间是未知的，所以它没有大写。<br><br>不能由于某样东西的属性是final，就认定它的值能在编译时期知道。i4和i5向大家证明了这一点。它们在运行期间使用随机生成的数字。例子的这一部分也向大家揭示出将final值设为static和非static之间的差异。只有当值在运行期间初始化的前提下，这种差异才会揭示出来。因为编译期间的值被编译器认为是相同的。这种差异可从输出结果中看出：<br><br>```<br>fd1: i4 = 15, i5 = 9<br>Creating new FinalData<br>fd1: i4 = 15, i5 = 9<br>fd2: i4 = 10, i5 = 9<br>```<br><br>注意对于fd1和fd2来说，i4的值是唯一的，但i5的值不会由于创建了另一个FinalData对象而发生改变。那是因为它的属性是static，而且在载入时初始化，而非每创建一个对象时初始化。<br><br>从v1到v4的变量向我们揭示出final句柄的含义。正如大家在main()中看到的那样，并不能认为由于v2属于final，所以就不能再改变它的值。然而，我们确实不能再将v2绑定到一个新对象，因为它的属性是final。这便是final对于一个句柄的确切含义。我们会发现同样的含义亦适用于数组，后者只不过是另一种类型的句柄而已。将句柄变成final看起来似乎不如将基本数据类型变成final那么有用。<br><br>2. 空白final<br><br>Java 1.1允许我们创建“空白final”，它们属于一些特殊的字段。尽管被声明成final，但却未得到一个初始值。无论在哪种情况下，空白final都必须在实际使用前得到正确的初始化。而且编译器会主动保证这一规定得以贯彻。然而，对于final关键字的各种应用，空白final具有最大的灵活性。举个例子来说，位于类内部的一个final字段现在对每个对象都可以有所不同，同时依然保持其“不变”的本质。下面列出一个例子：<br><br>```<br>//: BlankFinal.java<br>// "Blank" final data members<br><br>class Poppet { }<br><br>class BlankFinal {<br>  final int i = 0; // Initialized final<br>  final int j; // Blank final<br>  final Poppet p; // Blank final handle<br>  // Blank finals MUST be initialized<br>  // in the constructor:<br>  BlankFinal() {<br>    j = 1; // Initialize blank final<br>    p = new Poppet();<br>  }<br>  BlankFinal(int x) {<br>    j = x; // Initialize blank final<br>    p = new Poppet();<br>  }<br>  public static void main(String[] args) {<br>    BlankFinal bf = new BlankFinal();<br>  }<br>} ///:~<br>```<br><br>现在强行要求我们对final进行赋值处理——要么在定义字段时使用一个表达 式，要么在每个构建器中。这样就可以确保final字段在使用前获得正确的初始化。<br><br>3. final自变量<br><br>Java 1.1允许我们将自变量设成final属性，方法是在自变量列表中对它们进行适当的声明。这意味着在一个方法的内部，我们不能改变自变量句柄指向的东西。如下所示：<br><br>```<br>//: FinalArguments.java<br>// Using "final" with method arguments<br><br>class Gizmo {<br>  public void spin() {}<br>}<br><br>public class FinalArguments {<br>  void with(final Gizmo g) {<br>    //! g = new Gizmo(); // Illegal -- g is final<br>    g.spin();<br>  }<br>  void without(Gizmo g) {<br>    g = new Gizmo(); // OK -- g not final<br>    g.spin();<br>  }<br>  // void f(final int i) { i++; } // Can't change<br>  // You can only read from a final primitive:<br>  int g(final int i) { return i + 1; }<br>  public static void main(String[] args) {<br>    FinalArguments bf = new FinalArguments();<br>    bf.without(null);<br>    bf.with(null);<br>  }<br>} ///:~<br>```<br><br>注意此时仍然能为final自变量分配一个null（空）句柄，同时编译器不会捕获它。这与我们对非final自变量采取的操作是一样的。<br><br>方法f()和g()向我们展示出基本类型的自变量为final时会发生什么情况：我们只能读取自变量，不可改变它。<br><br>6.8.2 final方法<br><br>之所以要使用final方法，可能是出于对两方面理由的考虑。第一个是为方法“上锁”，防止任何继承类改变它的本来含义。设计程序时，若希望一个方法的行为在继承期间保持不变，而且不可被覆盖或改写，就可以采取这种做法。<br>采用final方法的第二个理由是程序执行的效率。将一个方法设成final后，编译器就可以把对那个方法的所有调用都置入“嵌入”调用里。只要编译器发现一个final方法调用，就会（根据它自己的判断）忽略为执行方法调用机制而采取的常规代码插入方法（将自变量压入堆栈；跳至方法代码并执行它；跳回来；清除堆栈自变量；最后对返回值进行处理）。相反，它会用方法主体内实际代码的一个副本来替换方法调用。这样做可避免方法调用时的系统开销。当然，若方法体积太大，那么程序也会变得雍肿，可能受到到不到嵌入代码所带来的任何性能提升。因为任何提升都被花在方法内部的时间抵消了。Java编译器能自动侦测这些情况，并颇为“明智”地决定是否嵌入一个final方法。然而，最好还是不要完全相信编译器能正确地作出所有判断。通常，只有在方法的代码量非常少，或者想明确禁止方法被覆盖的时候，才应考虑将一个方法设为final。<br><br>类内所有private方法都自动成为final。由于我们不能访问一个private方法，所以它绝对不会被其他方法覆盖（若强行这样做，编译器会给出错误提示）。可为一个private方法添加final指示符，但却不能为那个方法提供任何额外的含义。<br><br>6.8.3 final类<br><br>如果说整个类都是final（在它的定义前冠以final关键字），就表明自己不希望从这个类继承，或者不允许其他任何人采取这种操作。换言之，出于这样或那样的原因，我们的类肯定不需要进行任何改变；或者出于安全方面的理由，我们不希望进行子类化（子类处理）。<br><br>除此以外，我们或许还考虑到执行效率的问题，并想确保涉及这个类各对象的所有行动都要尽可能地有效。如下所示：<br><br>```<br>//: Jurassic.java<br>// Making an entire class final<br><br>class SmallBrain {}<br><br>final class Dinosaur {<br>  int i = 7;<br>  int j = 1;<br>  SmallBrain x = new SmallBrain();<br>  void f() {}<br>}<br><br>//! class Further extends Dinosaur {}<br>// error: Cannot extend final class 'Dinosaur'<br><br>public class Jurassic {<br>  public static void main(String[] args) {<br>    Dinosaur n = new Dinosaur();<br>    n.f();<br>    n.i = 40;<br>    n.j++;<br>  }<br>} ///:~<br>```<br><br>注意数据成员既可以是final，也可以不是，取决于我们具体选择。应用于final的规则同样适用于数据成员，无论类是否被定义成final。将类定义成final后，结果只是禁止进行继承——没有更多的限制。然而，由于它禁止了继承，所以一个final类中的所有方法都默认为final。因为此时再也无法覆盖它们。所以与我们将一个方法明确声明为final一样，编译器此时有相同的效率选择。<br><br>可为final类内的一个方法添加final指示符，但这样做没有任何意义。<br><br>6.8.4 final的注意事项<br><br>设计一个类时，往往需要考虑是否将一个方法设为final。可能会觉得使用自己的类时执行效率非常重要，没有人想覆盖自己的方法。这种想法在某些时候是正确的。<br><br>但要慎重作出自己的假定。通常，我们很难预测一个类以后会以什么样的形式再生或重复利用。常规用途的类尤其如此。若将一个方法定义成final，就可能杜绝了在其他程序员的项目中对自己的类进行继承的途径，因为我们根本没有想到它会象那样使用。<br><br>标准Java库是阐述这一观点的最好例子。其中特别常用的一个类是Vector。如果我们考虑代码的执行效率，就会发现只有不把任何方法设为final，才能使其发挥更大的作用。我们很容易就会想到自己应继承和覆盖如此有用的一个类，但它的设计者却否定了我们的想法。但我们至少可以用两个理由来反驳他们。首先，Stack（堆栈）是从Vector继承来的，亦即Stack“是”一个Vector，这种说法是不确切的。其次，对于Vector许多重要的方法，如addElement()以及elementAt()等，它们都变成了synchronized（同步的）。正如在第14章要讲到的那样，这会造成显著的性能开销，可能会把final提供的性能改善抵销得一干二净。因此，程序员不得不猜测到底应该在哪里进行优化。在标准库里居然采用了如此笨拙的设计，真不敢想象会在程序员里引发什么样的情绪。<br><br>另一个值得注意的是Hashtable（散列表），它是另一个重要的标准类。该类没有采用任何final方法。正如我们在本书其他地方提到的那样，显然一些类的设计人员与其他设计人员有着全然不同的素质（注意比较Hashtable极短的方法名与Vecor的方法名）。对类库的用户来说，这显然是不应该如此轻易就能看出的。一个产品的设计变得不一致后，会加大用户的工作量。这也从另一个侧面强调了代码设计与检查时需要很强的责任心。<br></div></div>
			<nav>
				<ul class="pager">
				<li class='previous'><a href='56.html'>&larr; 6.7 上溯造型</a></li>
			<li class='next'><a href='58.html'>6.9 初始化和类装载&rarr;</a></li>
				</ul>
			</nav>
</div>
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
			<!-- /.row -->
			  <hr>
        <!-- Footer -->
        <footer>
            <div class="row">
                <div class="col-xs-12">
                    <p>Copyright &copy; 小龙软件工作室 2016 粤icp备16103410</p>
                </div>
            </div>
        </footer>

    </div>
    <!-- /.container -->

    <!-- jQuery -->
    <script src="../../js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="../../js/bootstrap.min.js"></script>

</body>

</html>
