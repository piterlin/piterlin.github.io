<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="content-type" content="text/html;charset=utf-8">
    <meta charset="utf-8">
<meta name="360-site-verification" content="cabcfb5a0f4c0d28d604e8a69e6c0cdb" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="baidu-site-verification" content="HknqsD2zhn" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>java编程思想(thinking in java)-编码助手网</title>
      <meta content="为编码人员提供在线文档、模板等帮助，提升解决问题效率" name="description">
			<meta content="java编程思想(thinking in java) Java, spring, tomcat, servlet, jsp, api doc, bootstrap" name="keywords">
<meta name="sogou_site_verification" content="42nApEZFKO"/>


    <!-- Bootstrap Core CSS -->
    <link href="../../css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="../../css/heroic-features.css" rel="stylesheet">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
		<script>
		var _hmt = _hmt || [];
		(function() {
		  var hm = document.createElement("script");
		  hm.src = "//hm.baidu.com/hm.js?dd1361ca20a10cc161e72d4bc4fef6df";
		  var s = document.getElementsByTagName("script")[0];
		  s.parentNode.insertBefore(hm, s);
		})();
		</script>

</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">编码助手网</a>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav">
                    <li>
                        <a href="/">首页</a>
                    </li>
										<li>
                        <a href="/template.html">模板</a>
                    </li>
										<li>
												<a href="/doc.html">文档</a>
										</li>
                    <li>
                        <a href="/contact.html">联系我们</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Content -->
    <div class="container">

			<div class="row">
					<div class="col-xs-4">
						<h4>java编程思想(thinking in java)</h4>
						<h6>感谢http://quanke.name提供内容</h6>
<ul><li><a href='./1479436214592_-168316990.html'>Introduction</a></li><li><a href='./1479436214605_802664538.html'>写在前面的话</a></li><li><a href='./1479436214605_-791815332.html'>引言</a></li><li><a href='./1479436214605_1266451767.html'>第1章 对象入门</a></li><li><ul><li><a href='./1479436214606_-1211955969.html'>1.1 抽象的进步</a></li><li><a href='./1479436214606_-985491570.html'>1.2 对象的接口</a></li><li><a href='./1479436214606_421738363.html'>1.3 实现方案的隐藏</a></li><li><a href='./1479436214607_1726094433.html'>1.4 方案的重复使用</a></li><li><a href='./1479436214607_-1917493719.html'>1.5 继承：重新使用接口</a></li><li><a href='./1479436214607_-994529289.html'>1.6 多形对象的互换使用</a></li><li><a href='./1479436214608_695543294.html'>1.7 对象的创建和存在时间</a></li><li><a href='./1479436214609_186799536.html'>1.8 违例控制：解决错误</a></li><li><a href='./1479436214609_225257298.html'>1.9 多线程</a></li><li><a href='./1479436214610_-1377857368.html'>1.10 永久性</a></li><li><a href='./1479436214610_-1567485742.html'>1.11 Java和因特网</a></li><li><a href='./1479436214610_-534049255.html'>1.12 分析和设计</a></li><li><a href='./1479436214611_-516206529.html'>1.13 Java还是C++</a></li></ul></li><li><a href='./1479436214611_-833808368.html'>第2章 一切都是对象</a></li><li><ul><li><a href='./1479436214611_160489487.html'>2.1 用句柄操纵对象</a></li><li><a href='./1479436214611_-395400265.html'>2.2 所有对象都必须创建</a></li><li><a href='./1479436214612_-105112715.html'>2.3 绝对不要清除对象</a></li><li><a href='./1479436214612_-1081120728.html'>2.4 新建数据类型：类</a></li><li><a href='./1479436214612_437273775.html'>2.5 方法、自变量和返回值</a></li><li><a href='./1479436214612_968479086.html'>2.6 构建Java程序</a></li><li><a href='./1479436214612_-1963386412.html'>2.7 我们的第一个Java程序</a></li><li><a href='./1479436214613_988202688.html'>2.8 注释和嵌入文档</a></li><li><a href='./1479436214613_-642199972.html'>2.9 编码样式</a></li><li><a href='./1479436214613_-1135594618.html'>2.10 总结</a></li><li><a href='./1479436214613_976703976.html'>2.11 练习</a></li></ul></li><li><a href='./1479436214614_1617201657.html'>第3章 控制程序流程</a></li><li><ul><li><a href='./1479436214614_479400700.html'>3.1 使用Java运算符</a></li><li><a href='./1479436214614_-9479532.html'>3.2 执行控制</a></li><li><a href='./1479436214614_198965659.html'>3.3 总结</a></li><li><a href='./1479436214615_-634539581.html'>3.4 练习</a></li></ul></li><li><a href='./1479436214615_-1049694152.html'>第4章 初始化和清除</a></li><li><ul><li><a href='./1479436214615_-614369641.html'>4.1 用构建器自动初始化</a></li><li><a href='./1479436214615_-2107354158.html'>4.2 方法过载</a></li><li><a href='./1479436214616_2106438365.html'>4.3 清除：收尾和垃圾收集</a></li><li><a href='./1479436214616_-1969096840.html'>4.4 成员初始化</a></li><li><a href='./1479436214616_55724218.html'>4.5 数组初始化</a></li><li><a href='./1479436214616_-51810259.html'>4.6 总结</a></li><li><a href='./1479436214616_749059750.html'>4.7 练习</a></li></ul></li><li><a href='./1479436214617_-1201809261.html'>第5章 隐藏实施过程</a></li><li><ul><li><a href='./1479436214617_75246657.html'>5.1 包：库单元</a></li><li><a href='./1479436214617_-738077386.html'>5.2 Java访问指示符</a></li><li><a href='./1479436214617_-131608479.html'>5.3 接口与实现</a></li><li><a href='./1479436214617_-1940689271.html'>5.4 类访问</a></li><li><a href='./1479436214618_1119703547.html'>5.5 总结</a></li><li><a href='./1479436214618_-768700500.html'>5.6 练习</a></li></ul></li><li><a href='./1479436214618_303969565.html'>第6章 类再生</a></li><li><ul><li><a href='./1479436214618_1498787567.html'>6.1 合成的语法</a></li><li><a href='./1479436214618_1797834651.html'>6.2 继承的语法</a></li><li><a href='./1479436214619_128080957.html'>6.3 合成与继承的结合</a></li><li><a href='./1479436214619_-538376950.html'>6.4 到底选择合成还是继承</a></li><li><a href='./1479436214619_754950718.html'>6.5 protected</a></li><li><a href='./1479436214619_68859466.html'>6.6 累积开发</a></li><li><a href='./1479436214620_1707544672.html'>6.7 上溯造型</a></li><li><a href='./1479436214620_-1441830877.html'>6.8 final关键字</a></li><li><a href='./1479436214620_1153478487.html'>6.9 初始化和类装载</a></li><li><a href='./1479436214620_-39288028.html'>6.10 总结</a></li><li><a href='./1479436214620_537511919.html'>6.11 练习</a></li></ul></li><li><a href='./1479436214621_636771584.html'>第7章 多形性</a></li><li><ul><li><a href='./1479436214621_14200843.html'>7.1 上溯造型</a></li><li><a href='./1479436214621_-125275107.html'>7.2 深入理解</a></li><li><a href='./1479436214621_-1006098686.html'>7.3 覆盖与过载</a></li><li><a href='./1479436214622_1469935979.html'>7.4 抽象类和方法</a></li><li><a href='./1479436214622_-321517007.html'>7.5 接口</a></li><li><a href='./1479436214622_-1548998791.html'>7.6 内部类</a></li><li><a href='./1479436214622_-1125287817.html'>7.7 构建器和多形性</a></li><li><a href='./1479436214622_1541346557.html'>7.8 通过继承进行设计</a></li><li><a href='./1479436214623_1527391664.html'>7.9 总结</a></li><li><a href='./1479436214623_-953872192.html'>7.10 练习</a></li></ul></li><li><a href='./1479436214623_-1694327281.html'>第8章 对象的容纳</a></li><li><ul><li><a href='./1479436214623_1677953038.html'>8.1 数组</a></li><li><a href='./1479436214623_157279663.html'>8.2 集合</a></li><li><a href='./1479436214624_2028486897.html'>8.3 枚举器（反复器）</a></li><li><a href='./1479436214624_1552417959.html'>8.4 集合的类型</a></li><li><a href='./1479436214624_-1236839872.html'>8.5 排序</a></li><li><a href='./1479436214624_948884352.html'>8.6 通用集合库</a></li><li><a href='./1479436214624_-29314847.html'>8.7 新集合</a></li><li><a href='./1479436214625_950741899.html'>8.8 总结</a></li><li><a href='./1479436214625_-235386019.html'>8.9 练习</a></li></ul></li><li><a href='./1479436214625_-1144170168.html'>第9章 违例差错控制</a></li><li><ul><li><a href='./1479436214625_1164481198.html'>9.1 基本违例</a></li><li><a href='./1479436214625_639309640.html'>9.2 违例的捕获</a></li><li><a href='./1479436214625_545387660.html'>9.3 标准Java违例</a></li><li><a href='./1479436214625_1703684624.html'>9.4 创建自己的违例</a></li><li><a href='./1479436214626_-1814781625.html'>9.5 违例的限制</a></li><li><a href='./1479436214626_1362968450.html'>9.6 用finally清除</a></li><li><a href='./1479436214626_1696138810.html'>9.7 构建器</a></li><li><a href='./1479436214626_-946669500.html'>9.8 违例匹配</a></li><li><a href='./1479436214626_1369629725.html'>9.9 总结</a></li><li><a href='./1479436214626_1887454245.html'>9.10 练习</a></li></ul></li><li><a href='./1479436214627_-823192075.html'>第10章 Java IO系统</a></li><li><ul><li><a href='./1479436214627_793225325.html'>10.1 输入和输出</a></li><li><a href='./1479436214627_-1441186029.html'>10.2 增添属性和有用的接口</a></li><li><a href='./1479436214627_1039462397.html'>10.3 本身的缺陷：RandomAccessFile</a></li><li><a href='./1479436214627_1841380738.html'>10.4 File类</a></li><li><a href='./1479436214628_2095064408.html'>10.5 IO流的典型应用</a></li><li><a href='./1479436214628_1699205963.html'>10.6 StreamTokenizer</a></li><li><a href='./1479436214628_-1183832916.html'>10.7 Java 1.1的IO流</a></li><li><a href='./1479436214628_1169764652.html'>10.8 压缩</a></li><li><a href='./1479436214628_599949674.html'>10.9 对象序列化</a></li><li><a href='./1479436214629_822501598.html'>10.10 总结</a></li><li><a href='./1479436214629_784582642.html'>10.11 练习</a></li></ul></li><li><a href='./1479436214629_-446109494.html'>第11章 运行期类型鉴定</a></li><li><ul><li><a href='./1479436214629_615980680.html'>11.1 对RTTI的需要</a></li><li><a href='./1479436214629_1591261577.html'>11.2 RTTI语法</a></li><li><a href='./1479436214629_-479724471.html'>11.3 反射：运行期类信息</a></li><li><a href='./1479436214630_1962275414.html'>11.4 总结</a></li><li><a href='./1479436214630_-104101779.html'>11.5 练习</a></li></ul></li><li><a href='./1479436214630_2105662301.html'>第12章 传递和返回对象</a></li><li><ul><li><a href='./1479436214630_-381058478.html'>12.1 传递句柄</a></li><li><a href='./1479436214630_1317862656.html'>12.2 制作本地副本</a></li><li><a href='./1479436214630_66286946.html'>12.3 克隆的控制</a></li><li><a href='./1479436214631_1628962510.html'>12.4 只读类</a></li><li><a href='./1479436214631_178950784.html'>12.5 总结</a></li><li><a href='./1479436214631_204549698.html'>12.6 练习</a></li></ul></li><li><a href='./1479436214631_1667056471.html'>第13章 创建窗口和程序片</a></li><li><a href='./1479436214631_1646591288.html'>第14章 多线程</a></li><li><ul><li><a href='./1479436214631_-2057627207.html'>14.1 反应灵敏的用户界面</a></li><li><a href='./1479436214631_1635675213.html'>14.2 共享有限的资源</a></li><li><a href='./1479436214632_1587335383.html'>14.3 堵塞</a></li><li><a href='./1479436214632_1322789348.html'>14.4 优先级</a></li><li><a href='./1479436214632_1679851836.html'>14.5 回顾runnable</a></li><li><a href='./1479436214632_-914514060.html'>14.6 总结</a></li><li><a href='./1479436214632_1301544438.html'>14.7 练习</a></li></ul></li><li><a href='./1479436214633_1637559906.html'>第15章 网络编程</a></li><li><ul><li><a href='./1479436214633_-2140545630.html'>15.1 机器的标识</a></li><li><a href='./1479436214633_946775708.html'>15.2 套接字</a></li><li><a href='./1479436214634_1854884592.html'>15.3 服务多个客户</a></li><li><a href='./1479436214634_1410414288.html'>15.4 数据报</a></li><li><a href='./1479436214634_224372951.html'>15.5 一个Web应用</a></li><li><a href='./1479436214634_-1622230225.html'>15.6 Java与CGI的沟通</a></li><li><a href='./1479436214634_-903287570.html'>15.7 用JDBC连接数据库</a></li><li><a href='./1479436214634_-416599191.html'>15.8 远程方法</a></li><li><a href='./1479436214635_-917204139.html'>15.9 总结</a></li><li><a href='./1479436214635_-540223303.html'>15.10 练习</a></li></ul></li><li><a href='./1479436214635_339847129.html'>第16章 设计范式</a></li><li><ul><li><a href='./1479436214635_1826776975.html'>16.1 范式的概念</a></li><li><a href='./1479436214635_1309397010.html'>16.2 观察器范式</a></li><li><a href='./1479436214636_132034955.html'>16.3 模拟垃圾回收站</a></li><li><a href='./1479436214636_1756675694.html'>16.4 改进设计</a></li><li><a href='./1479436214636_-1966590010.html'>16.5 抽象的应用</a></li><li><a href='./1479436214636_-1831214784.html'>16.6 多重派遣</a></li><li><a href='./1479436214636_1935634882.html'>16.7 访问器范式</a></li><li><a href='./1479436214636_1843093443.html'>16.8 RTTI真的有害吗</a></li><li><a href='./1479436214636_-1838860121.html'>16.9 总结</a></li><li><a href='./1479436214637_-1901505940.html'>16.10 练习</a></li></ul></li><li><a href='./1479436214637_-387290815.html'>第17章 项目</a></li><li><ul><li><a href='./1479436214637_-498587551.html'>17.1 文字处理</a></li><li><a href='./1479436214637_1300299412.html'>17.2 方法查找工具</a></li><li><a href='./1479436214637_1681291541.html'>17.3 复杂性理论</a></li><li><a href='./1479436214637_-1113877505.html'>17.4 总结</a></li><li><a href='./1479436214638_-1637352061.html'>17.5 练习</a></li></ul></li><li><a href='./1479436214638_931172498.html'>附录A 使用非JAVA代码</a></li><li><a href='./1479436214638_882880730.html'>附录B 对比C++和Java</a></li><li><a href='./1479436214638_-283304223.html'>附录C Java编程规则</a></li><li><a href='./1479436214638_-1842547113.html'>附录D 性能</a></li><li><a href='./1479436214638_749950023.html'>附录E 关于垃圾收集的一些话</a></li><li><a href='./1479436214639_2079199942.html'>附录F 推荐读物</a></li><li></li>
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
					<div class="col-xs-8">
# 10.4 File类<br><br><br>File类有一个欺骗性的名字——通常会认为它对付的是一个文件，但实情并非如此。它既代表一个特定文件的名字，也代表目录内一系列文件的名字。若代表一个文件集，便可用list()方法查询这个集，返回的是一个字串数组。之所以要返回一个数组，而非某个灵活的集合类，是因为元素的数量是固定的。而且若想得到一个不同的目录列表，只需创建一个不同的File对象即可。事实上，“FilePath”（文件路径）似乎是一个更好的名字。本节将向大家完整地例示如何使用这个类，其中包括相关的FilenameFilter（文件名过滤器）接口。<br><br>10.4.1 目录列表器<br><br>现在假设我们想观看一个目录列表。可用两种方式列出File对象。若在不含自变量（参数）的情况下调用list()，会获得File对象包含的一个完整列表。然而，若想对这个列表进行某些限制，就需要使用一个“目录过滤器”，该类的作用是指出应如何选择File对象来完成显示。<br><br>下面是用于这个例子的代码（或在执行该程序时遇到困难，请参考第3章3.1.2小节“赋值”）：<br><br>```<br>//: DirList.java<br>// Displays directory listing<br>package c10;<br>import java.io.*;<br><br>public class DirList {<br>  public static void main(String[] args) {<br>    try {<br>      File path = new File(".");<br>      String[] list;<br>      if(args.length == 0)<br>        list = path.list();<br>      else <br>        list = path.list(new DirFilter(args[0]));<br>      for(int i = 0; i < list.length; i++)<br>        System.out.println(list[i]);<br>    } catch(Exception e) {<br>      e.printStackTrace();<br>    }<br>  }<br>}<br><br>class DirFilter implements FilenameFilter {<br>  String afn;<br>  DirFilter(String afn) { this.afn = afn; }<br>  public boolean accept(File dir, String name) {<br>    // Strip path information:<br>    String f = new File(name).getName();<br>    return f.indexOf(afn) != -1;<br>  }<br>} ///:~<br>```<br><br>DirFilter类“实现”了interface FilenameFilter（关于接口的问题，已在第7章进行了详述）。下面让我们看看FilenameFilter接口有多么简单：<br><br>```<br>public interface FilenameFilter {<br>boolean accept(文件目录, 字串名);<br>}<br>```<br><br>它指出这种类型的所有对象都提供了一个名为accept()的方法。之所以要创建这样的一个类，背后的全部原因就是把accept()方法提供给list()方法，使list()能够“回调”accept()，从而判断应将哪些文件名包括到列表中。因此，通常将这种技术称为“回调”，有时也称为“算子”（也就是说，DirFilter是一个算子，因为它唯一的作用就是容纳一个方法）。由于list()采用一个FilenameFilter对象作为自己的自变量使用，所以我们能传递实现了FilenameFilter的任何类的一个对象，用它决定（甚至在运行期）list()方法的行为方式。回调的目的是在代码的行为上提供更大的灵活性。<br><br>通过DirFilter，我们看出尽管一个“接口”只包含了一系列方法，但并不局限于只能写那些方法（但是，至少必须提供一个接口内所有方法的定义。在这种情况下，DirFilter构建器也会创建）。<br><br>accept()方法必须接纳一个File对象，用它指示用于寻找一个特定文件的目录；并接纳一个String，其中包含了要寻找之文件的名字。可决定使用或忽略这两个参数之一，但有时至少要使用文件名。记住list()方法准备为目录对象中的每个文件名调用<br><br>accept()，核实哪个应包含在内——具体由accept()返回的“布尔”结果决定。<br>为确定我们操作的只是文件名，其中没有包含路径信息，必须采用String对象，并在它的外部创建一个File对象。然后调用<br><br>getName()，它的作用是去除所有路径信息（采用与平台无关的方式）。随后，accept()用String类的indexOf()方法检查文件名内部是否存在搜索字串"afn"。若在字串内找到afn，那么返回值就是afn的起点索引；但假如没有找到，返回值就是-1。注意这只是一个简单的字串搜索例子，未使用常见的表达式“通配符”方案，比如"fo?.b?r*"；这种方案更难实现。<br><br>list()方法返回的是一个数组。可查询这个数组的长度，然后在其中遍历，选定数组元素。与C和C++的类似行为相比，这种于方法内外方便游历数组的行为无疑是一个显著的进步。<br><br>1. 匿名内部类<br><br>下例用一个匿名内部类（已在第7章讲述）来重写显得非常理想。首先创建了一个filter()方法，它返回指向FilenameFilter的一个句柄：<br><br>```<br>//: DirList2.java<br>// Uses Java 1.1 anonymous inner classes<br>import java.io.*;<br><br>public class DirList2 {<br>  public static FilenameFilter <br>  filter(final String afn) {<br>    // Creation of anonymous inner class:<br>    return new FilenameFilter() {<br>      String fn = afn;<br>      public boolean accept(File dir, String n) {<br>        // Strip path information:<br>        String f = new File(n).getName();<br>        return f.indexOf(fn) != -1;<br>      }<br>    }; // End of anonymous inner class<br>  }<br>  public static void main(String[] args) {<br>    try {<br>      File path = new File(".");<br>      String[] list;<br>      if(args.length == 0)<br>        list = path.list();<br>      else <br>        list = path.list(filter(args[0]));<br>      for(int i = 0; i < list.length; i++)<br>        System.out.println(list[i]);<br>    } catch(Exception e) {<br>      e.printStackTrace();<br>    }<br>  }<br>} ///:~<br><br>```<br><br>注意filter()的自变量必须是final。这一点是匿名内部类要求的，使其能使用来自本身作用域以外的一个对象。<br><br>之所以认为这样做更好，是由于FilenameFilter类现在同DirList2紧密地结合在一起。然而，我们可采取进一步的操作，将匿名内部类定义成list()的一个参数，使其显得更加精简。如下所示：<br><br>```<br>//: DirList3.java<br>// Building the anonymous inner class "in-place"<br>import java.io.*;<br><br>public class DirList3 {<br>  public static void main(final String[] args) {<br>    try {<br>      File path = new File(".");<br>      String[] list;<br>      if(args.length == 0)<br>        list = path.list();<br>      else <br>        list = path.list(<br>          new FilenameFilter() {<br>            public boolean <br>            accept(File dir, String n) {<br>              String f = new File(n).getName();<br>              return f.indexOf(args[0]) != -1;<br>            }<br>          });<br>      for(int i = 0; i < list.length; i++)<br>        System.out.println(list[i]);<br>    } catch(Exception e) {<br>      e.printStackTrace();<br>    }<br>  }<br>} ///:~<br>```<br><br>main()现在的自变量是final，因为匿名内部类直接使用args[0]。<br><br>这展示了如何利用匿名内部类快速创建精简的类，以便解决一些复杂的问题。由于Java中的所有东西都与类有关，所以它无疑是一种相当有用的编码技术。它的一个好处是将特定的问题隔离在一个地方统一解决。但在另一方面，这样生成的代码不是十分容易阅读，所以使用时必须慎重。<br><br>2. 顺序目录列表<br><br>经常都需要文件名以排好序的方式提供。由于Java 1.0和Java 1.1都没有提供对排序的支持（从Java 1.2开始提供），所以必须用第8章创建的SortVector将这一能力直接加入自己的程序。就象下面这样：<br><br>```<br>//: SortedDirList.java<br>// Displays sorted directory listing<br>import java.io.*;<br>import c08.*;<br><br>public class SortedDirList {<br>  private File path;<br>  private String[] list;<br>  public SortedDirList(final String afn) {<br>    path = new File(".");<br>    if(afn == null)<br>      list = path.list();<br>    else<br>      list = path.list(<br>          new FilenameFilter() {<br>            public boolean <br>            accept(File dir, String n) {<br>              String f = new File(n).getName();<br>              return f.indexOf(afn) != -1;<br>            }<br>          });<br>    sort();<br>  }<br>  void print() {<br>    for(int i = 0; i < list.length; i++)<br>      System.out.println(list[i]);<br>  }<br>  private void sort() {<br>    StrSortVector sv = new StrSortVector();<br>    for(int i = 0; i < list.length; i++)<br>      sv.addElement(list[i]);<br>    // The first time an element is pulled from<br>    // the StrSortVector the list is sorted:<br>    for(int i = 0; i < list.length; i++)<br>      list[i] = sv.elementAt(i);<br>  }<br>  // Test it:<br>  public static void main(String[] args) {<br>    SortedDirList sd;<br>    if(args.length == 0)<br>      sd = new SortedDirList(null);<br>    else<br>      sd = new SortedDirList(args[0]);<br>    sd.print();<br>  }<br>} ///:~<br>```<br><br>这里进行了另外少许改进。不再是将path（路径）和list（列表）创建为main()的本地变量，它们变成了类的成员，使它们的值能在对象“生存”期间方便地访问。事实上，main()现在只是对类进行测试的一种方式。大家可以看到，一旦列表创建完毕，类的构建器就会自动开始对列表进行排序。<br><br>这种排序不要求区分大小写，所以最终不会得到一组全部单词都以大写字母开头的列表，跟着是全部以小写字母开头的列表。然而，我们注意到在以相同字母开头的一组文件名中，大写字母是排在前面的——这对标准的排序来说仍是一种不合格的行为。Java 1.2已成功解决了这个问题。<br><br>10.4.2 检查与创建目录<br><br>File类并不仅仅是对现有目录路径、文件或者文件组的一个表示。亦可用一个File对象新建一个目录，甚至创建一个完整的目录路径——假如它尚不存在的话。亦可用它了解文件的属性（长度、上一次修改日期、读／写属性等），检查一个File对象到底代表一个文件还是一个目录，以及删除一个文件等等。下列程序完整展示了如何运用File类剩下的这些方法：<br><br>```<br>//: MakeDirectories.java<br>// Demonstrates the use of the File class to<br>// create directories and manipulate files.<br>import java.io.*;<br><br>public class MakeDirectories {<br>  private final static String usage =<br>    "Usage:MakeDirectories path1 ...\n" +<br>    "Creates each path\n" +<br>    "Usage:MakeDirectories -d path1 ...\n" +<br>    "Deletes each path\n" +<br>    "Usage:MakeDirectories -r path1 path2\n" +<br>    "Renames from path1 to path2\n";<br>  private static void usage() {<br>    System.err.println(usage);<br>    System.exit(1);<br>  }<br>  private static void fileData(File f) {<br>    System.out.println(<br>      "Absolute path: " + f.getAbsolutePath() +<br>      "\n Can read: " + f.canRead() +<br>      "\n Can write: " + f.canWrite() +<br>      "\n getName: " + f.getName() +<br>      "\n getParent: " + f.getParent() +<br>      "\n getPath: " + f.getPath() +<br>      "\n length: " + f.length() +<br>      "\n lastModified: " + f.lastModified());<br>    if(f.isFile())<br>      System.out.println("it's a file");<br>    else if(f.isDirectory())<br>      System.out.println("it's a directory");<br>  }<br>  public static void main(String[] args) {<br>    if(args.length < 1) usage();<br>    if(args[0].equals("-r")) {<br>      if(args.length != 3) usage();<br>      File <br>        old = new File(args[1]),<br>        rname = new File(args[2]);<br>      old.renameTo(rname);<br>      fileData(old);<br>      fileData(rname);<br>      return; // Exit main<br>    }<br>    int count = 0;<br>    boolean del = false;<br>    if(args[0].equals("-d")) {<br>      count++;<br>      del = true;<br>    }<br>    for( ; count < args.length; count++) {<br>      File f = new File(args[count]);<br>      if(f.exists()) {<br>        System.out.println(f + " exists");<br>        if(del) {<br>          System.out.println("deleting..." + f);<br>          f.delete();<br>        }<br>      } <br>      else { // Doesn't exist<br>        if(!del) {<br>          f.mkdirs();<br>          System.out.println("created " + f);<br>        }<br>      }<br>      fileData(f);<br>    }  <br>  }<br>} ///:~<br>```<br><br>在fileData()中，可看到应用了各种文件调查方法来显示与文件或目录路径有关的信息。<br><br>main()应用的第一个方法是renameTo()，利用它可以重命名（或移动）一个文件至一个全新的路径（该路径由参数决定），它属于另一个File对象。这也适用于任何长度的目录。<br><br>若试验上述程序，就可发现自己能制作任意复杂程度的一个目录路径，因为mkdirs()会帮我们完成所有工作。在Java 1.0中，-d标志报告目录虽然已被删除，但它依然存在；但在Java 1.1中，目录会被实际删除。<br>
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
			</div>
			<!-- /.row -->
			  <hr>
        <!-- Footer -->
        <footer>
            <div class="row">
                <div class="col-lg-12">
                    <p>Copyright &copy; 小龙软件工作室 2016</p>
                </div>
            </div>
        </footer>

    </div>
    <!-- /.container -->

    <!-- jQuery -->
    <script src="../../js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="../../js/bootstrap.min.js"></script>

</body>

</html>
