<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="content-type" content="text/html;charset=utf-8">
    <meta charset="utf-8">
<meta name="360-site-verification" content="cabcfb5a0f4c0d28d604e8a69e6c0cdb" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="baidu-site-verification" content="HknqsD2zhn" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>java编程思想(thinking in java)-编码助手网</title>
      <meta content="为编码人员提供在线文档、模板等帮助，提升解决问题效率" name="description">
			<meta content="java编程思想(thinking in java) Java, spring, tomcat, servlet, jsp, api doc, bootstrap" name="keywords">
<meta name="sogou_site_verification" content="42nApEZFKO"/>


    <!-- Bootstrap Core CSS -->
    <link href="../../css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="../../css/heroic-features.css" rel="stylesheet">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
		<script>
		var _hmt = _hmt || [];
		(function() {
		  var hm = document.createElement("script");
		  hm.src = "//hm.baidu.com/hm.js?dd1361ca20a10cc161e72d4bc4fef6df";
		  var s = document.getElementsByTagName("script")[0];
		  s.parentNode.insertBefore(hm, s);
		})();
		</script>

</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">编码助手网</a>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav">
                    <li>
                        <a href="/">首页</a>
                    </li>
										<li>
                        <a href="/template.html">模板</a>
                    </li>
										<li>
												<a href="/doc.html">文档</a>
										</li>
                    <li>
                        <a href="/contact.html">联系我们</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Content -->
    <div class="container">

			<div class="row">
					<div class="col-xs-4">
						<h4>java编程思想(thinking in java)</h4>
						<h6>感谢http://quanke.name提供内容</h6>
<ul><li><a href='./1479436214592_-168316990.html'>Introduction</a></li><li><a href='./1479436214605_802664538.html'>写在前面的话</a></li><li><a href='./1479436214605_-791815332.html'>引言</a></li><li><a href='./1479436214605_1266451767.html'>第1章 对象入门</a></li><li><ul><li><a href='./1479436214606_-1211955969.html'>1.1 抽象的进步</a></li><li><a href='./1479436214606_-985491570.html'>1.2 对象的接口</a></li><li><a href='./1479436214606_421738363.html'>1.3 实现方案的隐藏</a></li><li><a href='./1479436214607_1726094433.html'>1.4 方案的重复使用</a></li><li><a href='./1479436214607_-1917493719.html'>1.5 继承：重新使用接口</a></li><li><a href='./1479436214607_-994529289.html'>1.6 多形对象的互换使用</a></li><li><a href='./1479436214608_695543294.html'>1.7 对象的创建和存在时间</a></li><li><a href='./1479436214609_186799536.html'>1.8 违例控制：解决错误</a></li><li><a href='./1479436214609_225257298.html'>1.9 多线程</a></li><li><a href='./1479436214610_-1377857368.html'>1.10 永久性</a></li><li><a href='./1479436214610_-1567485742.html'>1.11 Java和因特网</a></li><li><a href='./1479436214610_-534049255.html'>1.12 分析和设计</a></li><li><a href='./1479436214611_-516206529.html'>1.13 Java还是C++</a></li></ul></li><li><a href='./1479436214611_-833808368.html'>第2章 一切都是对象</a></li><li><ul><li><a href='./1479436214611_160489487.html'>2.1 用句柄操纵对象</a></li><li><a href='./1479436214611_-395400265.html'>2.2 所有对象都必须创建</a></li><li><a href='./1479436214612_-105112715.html'>2.3 绝对不要清除对象</a></li><li><a href='./1479436214612_-1081120728.html'>2.4 新建数据类型：类</a></li><li><a href='./1479436214612_437273775.html'>2.5 方法、自变量和返回值</a></li><li><a href='./1479436214612_968479086.html'>2.6 构建Java程序</a></li><li><a href='./1479436214612_-1963386412.html'>2.7 我们的第一个Java程序</a></li><li><a href='./1479436214613_988202688.html'>2.8 注释和嵌入文档</a></li><li><a href='./1479436214613_-642199972.html'>2.9 编码样式</a></li><li><a href='./1479436214613_-1135594618.html'>2.10 总结</a></li><li><a href='./1479436214613_976703976.html'>2.11 练习</a></li></ul></li><li><a href='./1479436214614_1617201657.html'>第3章 控制程序流程</a></li><li><ul><li><a href='./1479436214614_479400700.html'>3.1 使用Java运算符</a></li><li><a href='./1479436214614_-9479532.html'>3.2 执行控制</a></li><li><a href='./1479436214614_198965659.html'>3.3 总结</a></li><li><a href='./1479436214615_-634539581.html'>3.4 练习</a></li></ul></li><li><a href='./1479436214615_-1049694152.html'>第4章 初始化和清除</a></li><li><ul><li><a href='./1479436214615_-614369641.html'>4.1 用构建器自动初始化</a></li><li><a href='./1479436214615_-2107354158.html'>4.2 方法过载</a></li><li><a href='./1479436214616_2106438365.html'>4.3 清除：收尾和垃圾收集</a></li><li><a href='./1479436214616_-1969096840.html'>4.4 成员初始化</a></li><li><a href='./1479436214616_55724218.html'>4.5 数组初始化</a></li><li><a href='./1479436214616_-51810259.html'>4.6 总结</a></li><li><a href='./1479436214616_749059750.html'>4.7 练习</a></li></ul></li><li><a href='./1479436214617_-1201809261.html'>第5章 隐藏实施过程</a></li><li><ul><li><a href='./1479436214617_75246657.html'>5.1 包：库单元</a></li><li><a href='./1479436214617_-738077386.html'>5.2 Java访问指示符</a></li><li><a href='./1479436214617_-131608479.html'>5.3 接口与实现</a></li><li><a href='./1479436214617_-1940689271.html'>5.4 类访问</a></li><li><a href='./1479436214618_1119703547.html'>5.5 总结</a></li><li><a href='./1479436214618_-768700500.html'>5.6 练习</a></li></ul></li><li><a href='./1479436214618_303969565.html'>第6章 类再生</a></li><li><ul><li><a href='./1479436214618_1498787567.html'>6.1 合成的语法</a></li><li><a href='./1479436214618_1797834651.html'>6.2 继承的语法</a></li><li><a href='./1479436214619_128080957.html'>6.3 合成与继承的结合</a></li><li><a href='./1479436214619_-538376950.html'>6.4 到底选择合成还是继承</a></li><li><a href='./1479436214619_754950718.html'>6.5 protected</a></li><li><a href='./1479436214619_68859466.html'>6.6 累积开发</a></li><li><a href='./1479436214620_1707544672.html'>6.7 上溯造型</a></li><li><a href='./1479436214620_-1441830877.html'>6.8 final关键字</a></li><li><a href='./1479436214620_1153478487.html'>6.9 初始化和类装载</a></li><li><a href='./1479436214620_-39288028.html'>6.10 总结</a></li><li><a href='./1479436214620_537511919.html'>6.11 练习</a></li></ul></li><li><a href='./1479436214621_636771584.html'>第7章 多形性</a></li><li><ul><li><a href='./1479436214621_14200843.html'>7.1 上溯造型</a></li><li><a href='./1479436214621_-125275107.html'>7.2 深入理解</a></li><li><a href='./1479436214621_-1006098686.html'>7.3 覆盖与过载</a></li><li><a href='./1479436214622_1469935979.html'>7.4 抽象类和方法</a></li><li><a href='./1479436214622_-321517007.html'>7.5 接口</a></li><li><a href='./1479436214622_-1548998791.html'>7.6 内部类</a></li><li><a href='./1479436214622_-1125287817.html'>7.7 构建器和多形性</a></li><li><a href='./1479436214622_1541346557.html'>7.8 通过继承进行设计</a></li><li><a href='./1479436214623_1527391664.html'>7.9 总结</a></li><li><a href='./1479436214623_-953872192.html'>7.10 练习</a></li></ul></li><li><a href='./1479436214623_-1694327281.html'>第8章 对象的容纳</a></li><li><ul><li><a href='./1479436214623_1677953038.html'>8.1 数组</a></li><li><a href='./1479436214623_157279663.html'>8.2 集合</a></li><li><a href='./1479436214624_2028486897.html'>8.3 枚举器（反复器）</a></li><li><a href='./1479436214624_1552417959.html'>8.4 集合的类型</a></li><li><a href='./1479436214624_-1236839872.html'>8.5 排序</a></li><li><a href='./1479436214624_948884352.html'>8.6 通用集合库</a></li><li><a href='./1479436214624_-29314847.html'>8.7 新集合</a></li><li><a href='./1479436214625_950741899.html'>8.8 总结</a></li><li><a href='./1479436214625_-235386019.html'>8.9 练习</a></li></ul></li><li><a href='./1479436214625_-1144170168.html'>第9章 违例差错控制</a></li><li><ul><li><a href='./1479436214625_1164481198.html'>9.1 基本违例</a></li><li><a href='./1479436214625_639309640.html'>9.2 违例的捕获</a></li><li><a href='./1479436214625_545387660.html'>9.3 标准Java违例</a></li><li><a href='./1479436214625_1703684624.html'>9.4 创建自己的违例</a></li><li><a href='./1479436214626_-1814781625.html'>9.5 违例的限制</a></li><li><a href='./1479436214626_1362968450.html'>9.6 用finally清除</a></li><li><a href='./1479436214626_1696138810.html'>9.7 构建器</a></li><li><a href='./1479436214626_-946669500.html'>9.8 违例匹配</a></li><li><a href='./1479436214626_1369629725.html'>9.9 总结</a></li><li><a href='./1479436214626_1887454245.html'>9.10 练习</a></li></ul></li><li><a href='./1479436214627_-823192075.html'>第10章 Java IO系统</a></li><li><ul><li><a href='./1479436214627_793225325.html'>10.1 输入和输出</a></li><li><a href='./1479436214627_-1441186029.html'>10.2 增添属性和有用的接口</a></li><li><a href='./1479436214627_1039462397.html'>10.3 本身的缺陷：RandomAccessFile</a></li><li><a href='./1479436214627_1841380738.html'>10.4 File类</a></li><li><a href='./1479436214628_2095064408.html'>10.5 IO流的典型应用</a></li><li><a href='./1479436214628_1699205963.html'>10.6 StreamTokenizer</a></li><li><a href='./1479436214628_-1183832916.html'>10.7 Java 1.1的IO流</a></li><li><a href='./1479436214628_1169764652.html'>10.8 压缩</a></li><li><a href='./1479436214628_599949674.html'>10.9 对象序列化</a></li><li><a href='./1479436214629_822501598.html'>10.10 总结</a></li><li><a href='./1479436214629_784582642.html'>10.11 练习</a></li></ul></li><li><a href='./1479436214629_-446109494.html'>第11章 运行期类型鉴定</a></li><li><ul><li><a href='./1479436214629_615980680.html'>11.1 对RTTI的需要</a></li><li><a href='./1479436214629_1591261577.html'>11.2 RTTI语法</a></li><li><a href='./1479436214629_-479724471.html'>11.3 反射：运行期类信息</a></li><li><a href='./1479436214630_1962275414.html'>11.4 总结</a></li><li><a href='./1479436214630_-104101779.html'>11.5 练习</a></li></ul></li><li><a href='./1479436214630_2105662301.html'>第12章 传递和返回对象</a></li><li><ul><li><a href='./1479436214630_-381058478.html'>12.1 传递句柄</a></li><li><a href='./1479436214630_1317862656.html'>12.2 制作本地副本</a></li><li><a href='./1479436214630_66286946.html'>12.3 克隆的控制</a></li><li><a href='./1479436214631_1628962510.html'>12.4 只读类</a></li><li><a href='./1479436214631_178950784.html'>12.5 总结</a></li><li><a href='./1479436214631_204549698.html'>12.6 练习</a></li></ul></li><li><a href='./1479436214631_1667056471.html'>第13章 创建窗口和程序片</a></li><li><a href='./1479436214631_1646591288.html'>第14章 多线程</a></li><li><ul><li><a href='./1479436214631_-2057627207.html'>14.1 反应灵敏的用户界面</a></li><li><a href='./1479436214631_1635675213.html'>14.2 共享有限的资源</a></li><li><a href='./1479436214632_1587335383.html'>14.3 堵塞</a></li><li><a href='./1479436214632_1322789348.html'>14.4 优先级</a></li><li><a href='./1479436214632_1679851836.html'>14.5 回顾runnable</a></li><li><a href='./1479436214632_-914514060.html'>14.6 总结</a></li><li><a href='./1479436214632_1301544438.html'>14.7 练习</a></li></ul></li><li><a href='./1479436214633_1637559906.html'>第15章 网络编程</a></li><li><ul><li><a href='./1479436214633_-2140545630.html'>15.1 机器的标识</a></li><li><a href='./1479436214633_946775708.html'>15.2 套接字</a></li><li><a href='./1479436214634_1854884592.html'>15.3 服务多个客户</a></li><li><a href='./1479436214634_1410414288.html'>15.4 数据报</a></li><li><a href='./1479436214634_224372951.html'>15.5 一个Web应用</a></li><li><a href='./1479436214634_-1622230225.html'>15.6 Java与CGI的沟通</a></li><li><a href='./1479436214634_-903287570.html'>15.7 用JDBC连接数据库</a></li><li><a href='./1479436214634_-416599191.html'>15.8 远程方法</a></li><li><a href='./1479436214635_-917204139.html'>15.9 总结</a></li><li><a href='./1479436214635_-540223303.html'>15.10 练习</a></li></ul></li><li><a href='./1479436214635_339847129.html'>第16章 设计范式</a></li><li><ul><li><a href='./1479436214635_1826776975.html'>16.1 范式的概念</a></li><li><a href='./1479436214635_1309397010.html'>16.2 观察器范式</a></li><li><a href='./1479436214636_132034955.html'>16.3 模拟垃圾回收站</a></li><li><a href='./1479436214636_1756675694.html'>16.4 改进设计</a></li><li><a href='./1479436214636_-1966590010.html'>16.5 抽象的应用</a></li><li><a href='./1479436214636_-1831214784.html'>16.6 多重派遣</a></li><li><a href='./1479436214636_1935634882.html'>16.7 访问器范式</a></li><li><a href='./1479436214636_1843093443.html'>16.8 RTTI真的有害吗</a></li><li><a href='./1479436214636_-1838860121.html'>16.9 总结</a></li><li><a href='./1479436214637_-1901505940.html'>16.10 练习</a></li></ul></li><li><a href='./1479436214637_-387290815.html'>第17章 项目</a></li><li><ul><li><a href='./1479436214637_-498587551.html'>17.1 文字处理</a></li><li><a href='./1479436214637_1300299412.html'>17.2 方法查找工具</a></li><li><a href='./1479436214637_1681291541.html'>17.3 复杂性理论</a></li><li><a href='./1479436214637_-1113877505.html'>17.4 总结</a></li><li><a href='./1479436214638_-1637352061.html'>17.5 练习</a></li></ul></li><li><a href='./1479436214638_931172498.html'>附录A 使用非JAVA代码</a></li><li><a href='./1479436214638_882880730.html'>附录B 对比C++和Java</a></li><li><a href='./1479436214638_-283304223.html'>附录C Java编程规则</a></li><li><a href='./1479436214638_-1842547113.html'>附录D 性能</a></li><li><a href='./1479436214638_749950023.html'>附录E 关于垃圾收集的一些话</a></li><li><a href='./1479436214639_2079199942.html'>附录F 推荐读物</a></li><li></li>
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
					<div class="col-xs-8">
# 15.6 Java与CGI的沟通<br><br>Java程序可向一个服务器发出一个CGI请求，这与HTML表单页没什么两样。而且和HTML页一样，这个请求既可以设为GET（下载），亦可设为POST（上传）。除此以外，Java程序还可拦截CGI程序的输出，所以不必依赖程序来格式化一个新页，也不必在出错的时候强迫用户从一个页回转到另一个页。事实上，程序的外观可以做得跟以前的版本别无二致。<br><br>代码也要简单一些，毕竟用CGI也不是很难就能写出来（前提是真正地理解它）。所以在这一节里，我们准备办个CGI编程速成班。为解决常规问题，将用C++创建一些CGI工具，以便我们编写一个能解决所有问题的CGI程序。这样做的好处是移植能力特别强——即将看到的例子能在支持CGI的任何系统上运行，而且不存在防火墙的问题。<br><br>这个例子也阐示了如何在程序片（Applet）和CGI程序之间建立连接，以便将其方便地改编到自己的项目中。<br><br>15.6.1 CGI数据的编码<br><br>在这个版本中，我们将收集名字和电子函件地址，并用下述形式将其保存到文件中：<br><br>```<br>First Last <email@domain.com>;<br>```<br><br>这对任何E-mail程序来说都是一种非常方便的格式。由于只需收集两个字段，而且CGI为字段中的编码采用了一种特殊的格式，所以这里没有简便的方法。如果自己动手编制一个原始的HTML页，并加入下述代码行，即可正确地理解这一点：<br><br>```<br><Form method="GET" ACTION="/cgi-bin/Listmgr2.exe"><br><P>Name: <INPUT TYPE = "text" NAME = "name" <br>VALUE = "" size = "40"></p><br><P>Email Address: <INPUT TYPE = "text" <br>NAME = "email" VALUE = "" size = "40"></p><br><p><input type = "submit" name = "submit" > </p><br></Form><br>```<br><br>上述代码创建了两个数据输入字段（区），名为name和email。另外还有一个submit（提交）按钮，用于收集数据，并将其发给CGI程序。Listmgr2.exe是驻留在特殊程序目录中的一个可执行文件。在我们的Web服务器上，该目录一般都叫作“cgi-bin”（注释③）。如果在那个目录里找不到该程序，结果就无法出现。填好这个表单，然后按下提交按钮，即可在浏览器的URL地址窗口里看到象下面这样的内容：<br><br>```<br>http://www.myhome.com/cgi-bin/Listmgr2.exe?name=First+Last&email=email@domain.com&submit=Submit<br>```<br><br>③：在Windows32平台下，可利用与Microsoft Office 97或其他产品配套提供的Microsoft Personal Web Server（微软个人Web服务器）进行测试。这是进行试验的最好方法，因为不必正式连入网络，可在本地环境中完成测试（速度也非常快）。如果使用的是不同的平台，或者没有Office 97或者FrontPage 98那样的产品，可到网上找一个免费的Web服务器供自己测试。<br><br>当然，上述URL实际显示时是不会拆行的。从中可稍微看出如何对数据编码并传给CGI。至少有一件事情能够肯定——空格是不允许的（因为它通常用于分隔命令行参数）。所有必需的空格都用“+”号替代，每个字段都包含了字段名（具体由HTML页决定），后面跟随一个“=”号以及正式的字段数据，最后用一个“&”结束。<br><br>到这时，大家也许会对“+”，“=”以及“&”的使用产生疑惑。假如必须在字段里使用这些字符，那么该如何声明呢？例如，我们可能使用“John & MarshaSmith”这个名字，其中的“&”代表“And”。事实上，它会编码成下面这个样子：<br><br>```<br>John+%26+Marsha+Smith<br>```<br><br>也就是说，特殊字符会转换成一个“%”，并在后面跟上它的十六进制ASCII编码。<br><br>幸运的是，Java有一个工具来帮助我们进行这种编码。这是URLEncoder类的一个静态方法，名为encode()。可用下述程序来试验这个方法：<br><br>```<br>//: EncodeDemo.java<br>// Demonstration of URLEncoder.encode()<br>import java.net.*;<br><br>public class EncodeDemo {<br>  public static void main(String[] args) {<br>    String s = "";<br>    for(int i = 0; i < args.length; i++)<br>      s += args[i] + " ";<br>    s = URLEncoder.encode(s.trim());<br>    System.out.println(s);<br>  }<br>} ///:~<br>```<br><br>该程序将获取一些命令行参数，把它们合并成一个由多个词构成的字串，各词之间用空格分隔（最后一个空格用String.trim()剔除了）。随后对它们进行编码，并打印出来。<br><br>为调用一个CGI程序，程序片要做的全部事情就是从自己的字段或其他地方收集数据，将所有数据都编码成正确的URL样式，然后汇编到单独一个字串里。每个字段名后面都加上一个“=”符号，紧跟正式数据，再紧跟一个“&”。为构建完整的CGI命令，我们将这个字串置于CGI程序的URL以及一个“?”后。这是调用所有CGI程序的标准方法。大家马上就会看到，用一个程序片能够很轻松地完成所有这些编码与合并。<br><br>15.6.2 程序片<br><br>程序片实际要比NameSender.java简单一些。这部分是由于很容易即可发出一个GET请求。此外，也不必等候回复信息。现在有两个字段，而非一个，但大家会发现许多程序片都是熟悉的，请比较NameSender.java。<br><br>```<br>//: NameSender2.java<br>// An applet that sends an email address<br>// via a CGI GET, using Java 1.02.<br>import java.awt.*;<br>import java.applet.*;<br>import java.net.*;<br>import java.io.*;<br><br>public class NameSender2 extends Applet {<br>  final String CGIProgram = "Listmgr2.exe";<br>  Button send = new Button(<br>    "Add email address to mailing list");<br>  TextField name = new TextField(<br>    "type your name here", 40),<br>    email = new TextField(<br>    "type your email address here", 40);<br>  String str = new String();<br>  Label l = new Label(), l2 = new Label();<br>  int vcount = 0;<br>  public void init() {<br>    setLayout(new BorderLayout());<br>    Panel p = new Panel();<br>    p.setLayout(new GridLayout(3, 1));<br>    p.add(name);<br>    p.add(email);<br>    p.add(send);<br>    add("North", p);<br>    Panel labels = new Panel();<br>    labels.setLayout(new GridLayout(2, 1));<br>    labels.add(l);<br>    labels.add(l2);<br>    add("Center", labels);<br>    l.setText("Ready to send email address");<br>  }<br>  public boolean action (Event evt, Object arg) {<br>    if(evt.target.equals(send)) {<br>      l2.setText("");<br>      // Check for errors in data:<br>      if(name.getText().trim()<br>         .indexOf(' ') == -1) {<br>        l.setText(<br>          "Please give first and last name");<br>        l2.setText("");<br>        return true;<br>      }<br>      str = email.getText().trim();<br>      if(str.indexOf(' ') != -1) {<br>        l.setText(<br>          "Spaces not allowed in email name");<br>        l2.setText("");<br>        return true;<br>      }<br>      if(str.indexOf(',') != -1) {<br>        l.setText(<br>          "Commas not allowed in email name");<br>        return true;<br>      }<br>      if(str.indexOf('@') == -1) {<br>        l.setText("Email name must include '@'");<br>        l2.setText("");<br>        return true;<br>      }<br>      if(str.indexOf('@') == 0) {<br>        l.setText(<br>          "Name must preceed '@' in email name");<br>        l2.setText("");<br>        return true;<br>      }<br>      String end = <br>        str.substring(str.indexOf('@'));<br>      if(end.indexOf('.') == -1) {<br>        l.setText("Portion after '@' must " +<br>          "have an extension, such as '.com'");<br>        l2.setText("");<br>        return true;<br>      }<br>      // Build and encode the email data:<br>      String emailData = <br>        "name=" + URLEncoder.encode(<br>          name.getText().trim()) +<br>        "&email=" + URLEncoder.encode(<br>          email.getText().trim().toLowerCase()) +<br>        "&submit=Submit";<br>      // Send the name using CGI's GET process:<br>      try {<br>        l.setText("Sending...");<br>        URL u = new URL(<br>          getDocumentBase(), "cgi-bin/" +<br>          CGIProgram + "?" + emailData);<br>        l.setText("Sent: " + email.getText());<br>        send.setLabel("Re-send");<br>        l2.setText(<br>          "Waiting for reply " + ++vcount);<br>        DataInputStream server =<br>          new DataInputStream(u.openStream());<br>        String line;<br>        while((line = server.readLine()) != null)<br>          l2.setText(line);<br>      } catch(MalformedURLException e) {<br>        l.setText("Bad URl");<br>      } catch(IOException e) {<br>        l.setText("IO Exception");<br>      } <br>    }<br>    else return super.action(evt, arg);<br>    return true;<br>  }<br>} ///:~<br>```<br><br>CGI程序（不久即可看到）的名字是Listmgr2.exe。许多Web服务器都在Unix机器上运行（Linux也越来越受到青睐）。根据传统，它们一般不为自己的可执行程序采用.exe扩展名。但在Unix操作系统中，可以把自己的程序称呼为自己希望的任何东西。若使用的是.exe扩展名，程序毋需任何修改即可通过Unix和Win32的运行测试。<br><br>和往常一样，程序片设置了自己的用户界面（这次是两个输入字段，不是一个）。唯一显著的区别是在action()方法内产生的。该方法的作用是对按钮按下事件进行控制。名字检查过以后，大家会发现下述代码行：<br><br>```<br>      String emailData = <br>        "name=" + URLEncoder.encode(<br>          name.getText().trim()) +<br>        "&email=" + URLEncoder.encode(<br>          email.getText().trim().toLowerCase()) +<br>        "&submit=Submit";<br>      // Send the name using CGI's GET process:<br>      try {<br>        l.setText("Sending...");<br>        URL u = new URL(<br>          getDocumentBase(), "cgi-bin/" +<br>          CGIProgram + "?" + emailData);<br>        l.setText("Sent: " + email.getText());<br>        send.setLabel("Re-send");<br>        l2.setText(<br>          "Waiting for reply " + ++vcount);<br>        DataInputStream server =<br>          new DataInputStream(u.openStream());<br>        String line;<br>        while((line = server.readLine()) != null)<br>          l2.setText(line);<br>        // ...<br>```<br><br>name和email数据都是它们对应的文字框里提取出来，而且两端多余的空格都用trim()剔去了。为了进入列表，email名字被强制换成小写形式，以便能够准确地对比（防止基于大小写形式的错误判断）。来自每个字段的数据都编码为URL形式，随后采用与HTML页中一样的方式汇编GET字串（这样一来，我们可将Java程序片与现有的任何CGI程序结合使用，以满足常规的HTML GET请求）。<br><br>到这时，一些Java的魔力已经开始发挥作用了：如果想同任何URL连接，只需创建一个URL对象，并将地址传递给构建器即可。构建器会负责建立同服务器的连接（对Web服务器来说，所有连接行动都是根据作为URL使用的字串来判断的）。就目前这种情况来说，URL指向的是当前Web站点的cgi-bin目录（当前Web站点的基础地址是用getDocumentBase()设定的）。一旦Web服务器在URL中看到了一个“cgi-bin”，会接着希望在它后面跟随了cgi-bin目录内的某个程序的名字，那是我们要运行的目标程序。程序名后面是一个问号以及CGI程序会在QUERY_STRING环境变量中查找的一个参数字串（马上就要学到）。<br><br>我们发出任何形式的请求后，一般都会得到一个回应的HTML页。但若使用Java的URL对象，我们可以拦截自CGI程序传回的任何东西，只需从URL对象里取得一个InputStream（输入数据流）即可。这是用URL对象的openStream()方法实现，它要封装到一个DataInputStream里。随后就可以读取数据行，若readLine()返回一个null（空值），就表明CGI程序已结束了它的输出。<br>我们即将看到的CGI程序返回的仅仅是一行，它是用于标志成功与否（以及失败的具体原因）的一个字串。这一行会被捕获并置放第二个Label字段里，使用户看到具体发生了什么事情。<br><br>1. 从程序片里显示一个Web页<br><br>程序亦可将CGI程序的结果作为一个Web页显示出来，就象它们在普通HTML模式中运行那样。可用下述代码做到这一点：<br><br>```<br>getAppletContext().showDocument(u);<br>```<br><br>其中，u代表URL对象。这是将我们重新定向于另一个Web页的一个简单例子。那个页凑巧是一个CGI程序的输出，但可以非常方便地进入一个原始的HTML页，所以可以构建这个程序片，令其产生一个由密码保护的网关，通过它进入自己Web站点的特殊部分：<br><br>```<br>//: ShowHTML.java<br>import java.awt.*;<br>import java.applet.*;<br>import java.net.*;<br>import java.io.*;<br><br>public class ShowHTML extends Applet {<br>  static final String CGIProgram = "MyCGIProgram";<br>  Button send = new Button("Go");<br>  Label l = new Label();<br>  public void init() {<br>    add(send);<br>    add(l);<br>  }<br>  public boolean action (Event evt, Object arg) {<br>    if(evt.target.equals(send)) {<br>      try {<br>        // This could be an HTML page instead of<br>        // a CGI program. Notice that this CGI <br>        // program doesn't use arguments, but <br>        // you can add them in the usual way.<br>        URL u = new URL(<br>          getDocumentBase(), <br>          "cgi-bin/" + CGIProgram);<br>        // Display the output of the URL using<br>        // the Web browser, as an ordinary page:<br>        getAppletContext().showDocument(u);<br>      } catch(Exception e) {<br>        l.setText(e.toString());<br>      } <br>    }<br>    else return super.action(evt, arg);<br>    return true;<br>  }<br>} ///:~<br>```<br><br>URL类的最大的特点就是有效地保护了我们的安全。可以同一个Web服务器建立连接，毋需知道幕后的任何东西。<br><br>15.6.3 用C++写的CGI程序<br><br>经过前面的学习，大家应该能够根据例子用ANSI C为自己的服务器写出CGI程序。之所以选用ANSI C，是因为它几乎随处可见，是最流行的C语言标准。当然，现在的C++也非常流行了，特别是采用GNU C++编译器（g++）形式的那一些（注释④）。可从网上许多地方免费下载g++，而且可选用几乎所有平台的版本（通常与Linux那样的操作系统配套提供，且已预先安装好）。正如大家即将看到的那样，从CGI程序可获得面向对象程序设计的许多好处。<br><br>④：GNU的全称是“Gnu's Not Unix”。这最早是由“自由软件基金会”（FSF）负责开发的一个项目，致力于用一个免费的版本取代原有的Unix操作系统。现在的Linux似乎正在做前人没有做到的事情。但GNU工具在Linux的开发中扮演了至关重要的角色。事实上，Linux的整套软件包附带了数量非常多的GNU组件。<br><br>为避免第一次就提出过多的新概念，这个程序并未打算成为一个“纯”C++程序；有些代码是用普通C写成的——尽管还可选用C++的一些替用形式。但这并不是个突出的问题，因为该程序用C++制作最大的好处就是能够创建类。在解析CGI信息的时候，由于我们最关心的是字段的“名称／值”对，所以要用一个类（Pair）来代表单个名称／值对；另一个类（CGI_vector）则将CGI字串自动解析到它会容纳的Pair对象里（作为一个vector），这样即可在有空的时候把每个Pair（对）都取出来。<br><br>这个程序同时也非常有趣，因为它演示了C++与Java相比的许多优缺点。大家会看到一些相似的东西；比如class关键字。访问控制使用的是完全相同的关键字public和private，但用法却有所不同。它们控制的是一个块，而非单个方法或字段（也就是说，如果指定private:，后续的每个定义都具有private属性，直到我们再指定public:为止）。另外在创建一个类的时候，所有定义都自动默认为private。<br><br>在这儿使用C++的一个原因是要利用C++“标准模板库”（STL）提供的便利。至少，STL包含了一个vector类。这是一个C++模板，可在编译期间进行配置，令其只容纳一种特定类型的对象（这里是Pair对象）。和Java的Vector不同，如果我们试图将除Pair对象之外的任何东西置入vector，C++的vector模板都会造成一个编译期错误；而Java的Vector能够照单全收。而且从vector里取出什么东西的时候，它会自动成为一个Pair对象，毋需进行造型处理。所以检查在编译期进行，这使程序显得更为“健壮”。此外，程序的运行速度也可以加快，因为没有必要进行运行期间的造型。vector也会过载operator[]，所以可以利用非常方便的语法来提取Pair对象。vector模板将在CGI_vector创建时使用；在那时，大家就可以体会到如此简短的一个定义居然蕴藏有那么巨大的能量。<br><br>若提到缺点，就一定不要忘记Pair在下列代码中定义时的复杂程度。与我们在Java代码中看到的相比，Pair的方法定义要多得多。这是由于C++的程序员必须提前知道如何用副本构建器控制复制过程，而且要用过载的operator=完成赋值。正如第12章解释的那样，我们有时也要在Java中考虑同样的事情。但在C++中，几乎一刻都不能放松对这些问题的关注。<br>这个项目首先创建一个可以重复使用的部分，由C++头文件中的Pair和CGI_vector构成。从技术角度看，确实不应把这些东西都塞到一个头文件里。但就目前的例子来说，这样做不会造成任何方面的损害，而且更具有Java风格，所以大家阅读理解代码时要显得轻松一些：<br><br>```<br>//: CGITools.h<br>// Automatically extracts and decodes data<br>// from CGI GETs and POSTs. Tested with GNU C++ <br>// (available for most server machines).<br>#include <string.h><br>#include <vector> // STL vector<br>using namespace std;<br><br>// A class to hold a single name-value pair from<br>// a CGI query. CGI_vector holds Pair objects and<br>// returns them from its operator[].<br>class Pair {<br>  char* nm;<br>  char* val;<br>public:<br>  Pair() { nm = val = 0; }<br>  Pair(char* name, char* value) {<br>    // Creates new memory:<br>    nm = decodeURLString(name);<br>    val = decodeURLString(value);<br>  }<br>  const char* name() const { return nm; }<br>  const char* value() const { return val; }<br>  // Test for "emptiness"<br>  bool empty() const {<br>    return (nm == 0) || (val == 0);<br>  }<br>  // Automatic type conversion for boolean test:<br>  operator bool() const {<br>    return (nm != 0) && (val != 0);<br>  }<br>  // The following constructors & destructor are<br>  // necessary for bookkeeping in C++.<br>  // Copy-constructor:<br>  Pair(const Pair& p) {<br>    if(p.nm == 0 || p.val == 0) {<br>      nm = val = 0;<br>    } else {<br>      // Create storage & copy rhs values:<br>      nm = new char[strlen(p.nm) + 1];<br>      strcpy(nm, p.nm);<br>      val = new char[strlen(p.val) + 1];<br>      strcpy(val, p.val);<br>    }<br>  }<br>  // Assignment operator:<br>  Pair& operator=(const Pair& p) {<br>    // Clean up old lvalues:<br>    delete nm;<br>    delete val;<br>    if(p.nm == 0 || p.val == 0) {<br>      nm = val = 0;<br>    } else {<br>      // Create storage & copy rhs values:<br>      nm = new char[strlen(p.nm) + 1];<br>      strcpy(nm, p.nm);<br>      val = new char[strlen(p.val) + 1];<br>      strcpy(val, p.val);<br>    }<br>    return *this;<br>  } <br>  ~Pair() { // Destructor<br>    delete nm; // 0 value OK<br>    delete val;<br>  }<br>  // If you use this method outide this class, <br>  // you're responsible for calling 'delete' on<br>  // the pointer that's returned:<br>  static char* <br>  decodeURLString(const char* URLstr) {<br>    int len = strlen(URLstr);<br>    char* result = new char[len + 1];<br>    memset(result, len + 1, 0);<br>    for(int i = 0, j = 0; i <= len; i++, j++) {<br>      if(URLstr[i] == '+')<br>        result[j] = ' ';<br>      else if(URLstr[i] == '%') {<br>        result[j] =<br>          translateHex(URLstr[i + 1]) * 16 +<br>          translateHex(URLstr[i + 2]);<br>        i += 2; // Move past hex code<br>      } else // An ordinary character<br>        result[j] = URLstr[i];<br>    }<br>    return result;<br>  }<br>  // Translate a single hex character; used by<br>  // decodeURLString():<br>  static char translateHex(char hex) {<br>    if(hex >= 'A')<br>      return (hex & 0xdf) - 'A' + 10;<br>    else<br>      return hex - '0';<br>  }<br>};<br><br>// Parses any CGI query and turns it<br>// into an STL vector of Pair objects:<br>class CGI_vector : public vector<Pair> {<br>  char* qry;<br>  const char* start; // Save starting position<br>  // Prevent assignment and copy-construction:<br>  void operator=(CGI_vector&);<br>  CGI_vector(CGI_vector&);<br>public:<br>  // const fields must be initialized in the C++<br>  // "Constructor initializer list":<br>  CGI_vector(char* query) :<br>      start(new char[strlen(query) + 1]) {<br>    qry = (char*)start; // Cast to non-const<br>    strcpy(qry, query);<br>    Pair p;<br>    while((p = nextPair()) != 0)<br>      push_back(p);<br>  }<br>  // Destructor:<br>  ~CGI_vector() { delete start; }<br>private:<br>  // Produces name-value pairs from the query <br>  // string. Returns an empty Pair when there's <br>  // no more query string left:<br>  Pair nextPair() {<br>    char* name = qry;<br>    if(name == 0 || *name == '\0')<br>      return Pair(); // End, return null Pair<br>    char* value = strchr(name, '=');<br>    if(value == 0)<br>      return Pair(); // Error, return null Pair<br>    // Null-terminate name, move value to start<br>    // of its set of characters:<br>    *value = '\0';<br>    value++;<br>    // Look for end of value, marked by '&':<br>    qry = strchr(value, '&');<br>    if(qry == 0) qry = ""; // Last pair found<br>    else {<br>      *qry = '\0'; // Terminate value string<br>      qry++; // Move to next pair<br>    }<br>    return Pair(name, value);<br>  }<br>}; ///:~<br>```<br><br>在#include语句后，可看到有一行是：<br><br>```<br>using namespace std;<br>```<br><br>C++中的“命名空间”（Namespace）解决了由Java的package负责的一个问题：将库名隐藏起来。std命名空间引用的是标准C++库，而vector就在这个库中，所以这一行是必需的。<br><br>Pair类表面看异常简单，只是容纳了两个（private）字符指针而已——一个用于名字，另一个用于值。默认构建器将这两个指针简单地设为零。这是由于在C++中，对象的内存不会自动置零。第二个构建器调用方法decodeURLString()，在新分配的堆内存中生成一个解码过后的字串。这个内存区域必须由对象负责管理及清除，这与“破坏器”中见到的相同。name()和value()方法为相关的字段产生只读指针。利用empty()方法，我们查询Pair对象它的某个字段是否为空；返回的结果是一个bool——C++内建的基本布尔数据类型。operator bool()使用的是C++“运算符过载”的一种特殊形式。它允许我们控制自动类型转换。如果有一个名为p的Pair对象，而且在一个本来希望是布尔结果的表达式中使用，比如if(p){//...，那么编译器能辨别出它有一个Pair，而且需要的是个布尔值，所以自动调用operator bool()，进行必要的转换。<br><br>接下来的三个方法属于常规编码，在C++中创建类时必须用到它们。根据C++类采用的所谓“经典形式”，我们必须定义必要的“原始”构建器，以及一个副本构建器和赋值运算符——operator=（以及破坏器，用于清除内存）。之所以要作这样的定义，是由于编译器会“默默”地调用它们。在对象传入、传出一个函数的时候，需要调用副本构建器；而在分配对象时，需要调用赋值运算符。只有真正掌握了副本构建器和赋值运算符的工作原理，才能在C++里写出真正“健壮”的类，但这需要需要一个比较艰苦的过程（注释⑤）。<br><br>⑤：我的《Thinking in C++》（Prentice-Hall,1995）用了一整章的地方来讨论这个主题。若需更多的帮助，请务必看看那一章。<br><br>只要将一个对象按值传入或传出函数，就会自动调用副本构建器Pair(const Pair&)。也就是说，对于准备为其制作一个完整副本的那个对象，我们不准备在函数框架中传递它的地址。这并不是Java提供的一个选项，由于我们只能传递句柄，所以在Java里没有所谓的副本构建器（如果想制作一个本地副本，可以“克隆”那个对象——使用clone()，参见第12章）。类似地，如果在Java里分配一个句柄，它会简单地复制。但C++中的赋值意味着整个对象都会复制。在副本构建器中，我们创建新的存储空间，并复制原始数据。但对于赋值运算符，我们必须在分配新存储空间之前释放老存储空间。我们要见到的也许是C++类最复杂的一种情况，但那正是Java的支持者们论证Java比C++简单得多的有力证据。在Java中，我们可以自由传递句柄，善后工作则由垃圾收集器负责，所以可以轻松许多。<br><br>但事情并没有完。Pair类为nm和val使用的是char*，最复杂的情况主要是围绕指针展开的。如果用较时髦的C++ string类来代替 `char*` ，事情就要变得简单得多（当然，并不是所有编译器都提供了对string的支持）。那么，Pair的第一部分看起来就象下面这样：<br><br>```<br>class Pair {<br>  string nm;<br>  string val;<br>public:<br>  Pair() { }<br>  Pair(char* name, char* value) {<br>    nm = decodeURLString(name);<br>    val = decodeURLString(value);<br>  }<br>  const char* name() const { return nm.c_str(); }<br>  const char* value() const { <br>    return val.c_str(); <br>  }<br>  // Test for "emptiness"<br>  bool empty() const {<br>    return (nm.length() == 0) <br>      || (val.length() == 0);<br>  }<br>  // Automatic type conversion for boolean test:<br>  operator bool() const {<br>    return (nm.length() != 0) <br>      && (val.length() != 0);<br>  }<br>```<br><br>（此外，对这个类decodeURLString()会返回一个string，而不是一个char*）。我们不必定义副本构建器、operator=或者破坏器，因为编译器已帮我们做了，而且做得非常好。但即使有些事情是自动进行的，C++程序员也必须了解副本构建以及赋值的细节。<br><br>Pair类剩下的部分由两个方法构成：decodeURLString()以及一个“帮助器”方法translateHex()——将由decodeURLString()使用。注意translateHex()并不能防范用户的恶意输入，比如“%1H”。分配好足够的存储空间后（必须由破坏器释放），decodeURLString()就会其中遍历，将所有“+”都换成一个空格；将所有十六进制代码（以一个“%”打头）换成对应的字符。<br><br>CGI_vector用于解析和容纳整个CGI GET命令。它是从STL vector里继承的，后者例示为容纳Pair。C++中的继承是用一个冒号表示，在Java中则要用extends。此外，继承默认为private属性，所以几乎肯定需要用到public关键字，就象这样做的那样。大家也会发现CGI_vector有一个副本构建器以及一个operator=，但它们都声明成private。这样做是为了防止编译器同步两个函数（如果不自己声明它们，两者就会同步）。但这同时也禁止了客户程序员按值或者通过赋值传递一个CGI_vector。<br><br>CGI_vector的工作是获取QUERY_STRING，并把它解析成“名称／值”对，这需要在Pair的帮助下完成。它首先将字串复制到本地分配的内存，并用常数指针start跟踪起始地址（稍后会在破坏器中用于释放内存）。随后，它用自己的nextPair()方法将字串解析成原始的“名称／值”对，各个对之间用一个“=”和“&”符号分隔。这些对由nextPair()传递给Pair构建器，所以nextPair()返回的是一个Pair对象。随后用push_back()将该对象加入vector。nextPair()遍历完整个QUERY_STRING后，会返回一个零值。<br><br>现在基本工具已定义好，它们可以简单地在一个CGI程序中使用，就象下面这样：<br><br>```<br>//: Listmgr2.cpp<br>// CGI version of Listmgr.c in C++, which <br>// extracts its input via the GET submission <br>// from the associated applet. Also works as<br>// an ordinary CGI program with HTML forms.<br>#include <stdio.h><br>#include "CGITools.h"<br>const char* dataFile = "list2.txt";<br>const char* notify = "Bruce@EckelObjects.com";<br>#undef DEBUG<br><br>// Similar code as before, except that it looks<br>// for the email name inside of '<>':<br>int inList(FILE* list, const char* emailName) {<br>  const int BSIZE = 255;<br>  char lbuf[BSIZE];<br>  char emname[BSIZE];<br>  // Put the email name in '<>' so there's no<br>  // possibility of a match within another name:<br>  sprintf(emname, "<%s>", emailName);<br>  // Go to the beginning of the list:<br>  fseek(list, 0, SEEK_SET);<br>  // Read each line in the list:<br>  while(fgets(lbuf, BSIZE, list)) {<br>    // Strip off the newline: <br>    char * newline = strchr(lbuf, '\n');<br>    if(newline != 0) <br>      *newline = '\0';<br>    if(strstr(lbuf, emname) != 0)<br>      return 1;<br>  }<br>  return 0;<br>}<br><br>void main() {<br>  // You MUST print this out, otherwise the <br>  // server will not send the response:<br>  printf("Content-type: text/plain\n\n");<br>  FILE* list = fopen(dataFile, "a+t");<br>  if(list == 0) {<br>    printf("error: could not open database. ");<br>    printf("Notify %s", notify);<br>    return;<br>  }<br>  // For a CGI "GET," the server puts the data<br>  // in the environment variable QUERY_STRING:<br>  CGI_vector query(getenv("QUERY_STRING"));<br>  #if defined(DEBUG)<br>  // Test: dump all names and values<br>  for(int i = 0; i < query.size(); i++) {<br>    printf("query[%d].name() = [%s], ", <br>      i, query[i].name());<br>    printf("query[%d].value() = [%s]\n", <br>      i, query[i].value());<br>  }<br>  #endif(DEBUG)<br>  Pair name = query[0];<br>  Pair email = query[1];<br>  if(name.empty() || email.empty()) {<br>    printf("error: null name or email");<br>    return;<br>  } <br>  if(inList(list, email.value())) {<br>    printf("Already in list: %s", email.value());<br>    return;<br>  }<br>  // It's not in the list, add it:<br>  fseek(list, 0, SEEK_END);<br>  fprintf(list, "%s <%s>;\n", <br>    name.value(), email.value());<br>  fflush(list);<br>  fclose(list);<br>  printf("%s <%s> added to list\n", <br>    name.value(), email.value());<br>} ///:~<br>```<br><br>alreadyInList()函数与前一个版本几乎是完全相同的，只是它假定所有电子函件地址都在一个“<>”内。<br>在使用GET方法时（通过在FORM引导命令的METHOD标记内部设置，但这在这里由数据发送的方式控制），Web服务器会收集位于“?”后面的所有信息，并把它们置入环境变量QUERY_STRING（查询字串）里。所以为了读取那些信息，必须获得QUERY_STRING的值，这是用标准的C库函数getnv()完成的。在main()中，注意对QUERY_STRING的解析有多么容易：只需把它传递给用于CGI_vector对象的构建器（名为query），剩下的所有工作都会自动进行。从这时开始，我们就可以从query中取出名称和值，把它们当作数组看待（这是由于operator[]在vector里已经过载了）。在调试代码中，大家可看到这一切是如何运作的；调试代码封装在预处理器引导命令#if defined(DEBUG)和#endif(DEBUG)之间。<br><br>现在，我们迫切需要掌握一些与CGI有关的东西。CGI程序用两个方式之一传递它们的输入：在GET执行期间通过QUERY_STRING传递（目前用的这种方式），或者在POST期间通过标准输入。但CGI程序通过标准输出发送自己的输出，这通常是用C程序的printf()命令实现的。那么这个输出到哪里去了呢？它回到了Web服务器，由服务器决定该如何处理它。服务器作出决定的依据是content-type（内容类型）头数据。这意味着假如content-type头不是它看到的第一件东西，就不知道该如何处理收到的数据。因此，我们无论如何也要使所有CGI程序都从content-type头开始输出。<br><br>在目前这种情况下，我们希望服务器将所有信息都直接反馈回客户程序（亦即我们的程序片，它们正在等候给自己的回复）。信息应该原封不动，所以content-type设为text/plain（纯文本）。一旦服务器看到这个头，就会将所有字串都直接发还给客户。所以每个字串（三个用于出错条件，一个用于成功的加入）都会返回程序片。<br><br>我们用相同的代码添加电子函件名称（用户的姓名）。但在CGI脚本的情况下，并不存在无限循环——程序只是简单地响应，然后就中断。每次有一个CGI请求抵达时，程序都会启动，对那个请求作出反应，然后自行关闭。所以CPU不可能陷入空等待的尴尬境地，只有启动程序和打开文件时才存在性能上的隐患。Web服务器对CGI请求进行控制时，它的开销会将这种隐患减轻到最低程度。<br>这种设计的另一个好处是由于Pair和CGI_vector都得到了定义，大多数工作都帮我们自动完成了，所以只需修改main()即可轻松创建自己的CGI程序。尽管小服务程序（Servlet）最终会变得越来越流行，但为了创建快速的CGI程序，C++仍然显得非常方便。<br><br>15.6.4 POST的概念<br><br>在许多应用程序中使用GET都没有问题。但是，GET要求通过一个环境变量将自己的数据传递给CGI程序。但假如GET字串过长，有些Web服务器可能用光自己的环境空间（若字串长度超过200字符，就应开始关心这方面的问题）。CGI为此提供了一个解决方案：POST。通过POST，数据可以编码，并按与GET相同的方法连结起来。但POST利用标准输入将编码过后的查询字串传递给CGI程序。我们要做的全部事情就是判断查询字串的长度，而这个长度已在环境变量CONTENT_LENGTH中保存好了。一旦知道了长度，就可自由分配存储空间，并从标准输入中读入指定数量的字符。<br><br>对一个用来控制POST的CGI程序，由CGITools.h提供的Pair和CGI_vector均可不加丝毫改变地使用。下面这段程序揭示了写这样的一个CGI程序有多么简单。这个例子将采用“纯”C++，所以studio.h库被iostream（IO数据流）代替。对于iostream，我们可以使用两个预先定义好的对象：cin，用于同标准输入连接；以及cout，用于同标准输出连接。有几个办法可从cin中读入数据以及向cout中写入。但下面这个程序准备采用标准方法：用“<<”将信息发给cout，并用一个成员函数（此时是read()）从cin中读入数据：<br><br>```<br>//: POSTtest.cpp<br>// CGI_vector works as easily with POST as it<br>// does with GET. Written in "pure" C++.<br>#include <iostream.h><br>#include "CGITools.h"<br><br>void main() {<br>  cout << "Content-type: text/plain\n" << endl;<br>  // For a CGI "POST," the server puts the length<br>  // of the content string in the environment <br>  // variable CONTENT_LENGTH:<br>  char* clen = getenv("CONTENT_LENGTH");<br>  if(clen == 0) {<br>    cout << "Zero CONTENT_LENGTH" << endl;<br>    return;<br>  }<br>  int len = atoi(clen);<br>  char* query_str = new char[len + 1];<br>  cin.read(query_str, len);<br>  query_str[len] = '\0';<br>  CGI_vector query(query_str);<br>  // Test: dump all names and values<br>  for(int i = 0; i < query.size(); i++)<br>    cout << "query[" << i << "].name() = [" <<<br>      query[i].name() << "], " <<<br>      "query[" << i << "].value() = [" <<<br>      query[i].value() << "]" << endl;<br>  delete query_str; // Release storage<br>} ///:~<br>```<br><br>getenv()函数返回指向一个字串的指针，那个字串指示着内容的长度。若指针为零，表明CONTENT_LENGTH环境变量尚未设置，所以肯定某个地方出了问题。否则就必须用ANSI C库函数atoi()将字串转换成一个整数。这个长度将与new一起运用，分配足够的存储空间，以便容纳查询字串（另加它的空中止符）。随后为cin()调用read()。read()函数需要取得指向目标缓冲区的一个指针以及要读入的字节数。随后用空字符（null）中止query_str，指出已经抵达字串的末尾，这就叫作“空中止”。<br><br>到这个时候，我们得到的查询字串与GET查询字串已经没有什么区别，所以把它传递给用于CGI_vector的构建器。随后便和前例一样，我们可以自由vector内不同的字段。<br><br>为测试这个程序，必须把它编译到主机Web服务器的cgi-bin目录下。然后就可以写一个简单的HTML页进行测试，就象下面这样：<br><br>```<br><HTML><br><HEAD><br><META CONTENT="text/html"><br><TITLE>A test of standard HTML POST</TITLE><br></HEAD><br>Test, uses standard html POST<br><Form method="POST" ACTION="/cgi-bin/POSTtest"><br><P>Field1: <INPUT TYPE = "text" NAME = "Field1" <br>VALUE = "" size = "40"></p><br><P>Field2: <INPUT TYPE = "text" NAME = "Field2" <br>VALUE = "" size = "40"></p><br><P>Field3: <INPUT TYPE = "text" NAME = "Field3" <br>VALUE = "" size = "40"></p><br><P>Field4: <INPUT TYPE = "text" NAME = "Field4" <br>VALUE = "" size = "40"></p><br><P>Field5: <INPUT TYPE = "text" NAME = "Field5" <br>VALUE = "" size = "40"></p><br><P>Field6: <INPUT TYPE = "text" NAME = "Field6" <br>VALUE = "" size = "40"></p><br><p><input type = "submit" name = "submit" > </p><br></Form><br></HTML><br>```<br><br>填好这个表单并提交出去以后，会得到一个简单的文本页，其中包含了解析出来的结果。从中可知道CGI程序是否在正常工作。<br>当然，用一个程序片来提交数据显得更有趣一些。然而，POST数据的提交属于一个不同的过程。在用常规方式调用了CGI程序以后，必须另行建立与服务器的一个连接，以便将查询字串反馈给它。服务器随后会进行一番处理，再通过标准输入将查询字串反馈回CGI程序。<br><br>为建立与服务器的一个直接连接，必须取得自己创建的URL，然后调用openConnection()创建一个URLConnection。但是，由于URLConnection一般不允许我们把数据发给它，所以必须很可笑地调用setDoOutput(true)函数，同时调用的还包括setDoInput(true)以及setAllowUserInteraction(false)——注释⑥。最后，可调用getOutputStream()来创建一个OutputStream（输出数据流），并把它封装到一个DataOutputStream里，以便能按传统方式同它通信。下面列出的便是一个用于完成上述工作的程序片，必须在从它的各个字段里收集了数据之后再执行它：<br><br>```<br>//: POSTtest.java<br>// An applet that sends its data via a CGI POST<br>import java.awt.*;<br>import java.applet.*;<br>import java.net.*;<br>import java.io.*;<br><br>public class POSTtest extends Applet {<br>  final static int SIZE = 10;<br>  Button submit = new Button("Submit");<br>  TextField[] t = new TextField[SIZE];<br>  String query = "";<br>  Label l = new Label();<br>  TextArea ta = new TextArea(15, 60);<br>  public void init() {<br>    Panel p = new Panel();<br>    p.setLayout(new GridLayout(t.length + 2, 2));<br>    for(int i = 0; i < t.length; i++) {<br>      p.add(new Label(<br>        "Field " + i + "  ", Label.RIGHT));<br>      p.add(t[i] = new TextField(30));<br>    }<br>    p.add(l);<br>    p.add(submit);<br>    add("North", p);<br>    add("South", ta);<br>  }<br>  public boolean action (Event evt, Object arg) {<br>    if(evt.target.equals(submit)) {<br>      query = "";<br>      ta.setText("");<br>      // Encode the query from the field data:<br>      for(int i = 0; i < t.length; i++)<br>         query += "Field" + i + "=" +<br>           URLEncoder.encode(<br>             t[i].getText().trim()) +<br>           "&";<br>      query += "submit=Submit";<br>      // Send the name using CGI's POST process:<br>      try {<br>        URL u = new URL(<br>          getDocumentBase(), "cgi-bin/POSTtest");<br>        URLConnection urlc = u.openConnection();<br>        urlc.setDoOutput(true);<br>        urlc.setDoInput(true);<br>        urlc.setAllowUserInteraction(false);<br>        DataOutputStream server = <br>          new DataOutputStream(<br>            urlc.getOutputStream());<br>        // Send the data<br>        server.writeBytes(query);<br>        server.close();<br>        // Read and display the response. You<br>        // cannot use <br>        // getAppletContext().showDocument(u);<br>        // to display the results as a Web page!<br>        DataInputStream in = <br>          new DataInputStream(<br>            urlc.getInputStream());<br>        String s;<br>        while((s = in.readLine()) != null) {<br>          ta.appendText(s + "\n");<br>        }<br>        in.close();<br>      }<br>      catch (Exception e) {<br>        l.setText(e.toString());<br>      }<br>    }<br>    else return super.action(evt, arg);<br>    return true;<br>  }<br>} ///:~<br>```<br><br>⑥：我不得不说自己并没有真正理解这儿都发生了什么事情，这些概念都是从Elliotte Rusty Harold编著的《Java Network Programming》里得来的，该书由O'Reilly于1997年出版。他在书中提到了Java连网函数库中出现的许多令人迷惑的Bug。所以一旦涉足这些领域，事情就不是编写代码，然后让它自己运行那么简单。一定要警惕潜在的陷阱！<br><br>信息发送到服务器后，我们调用getInputStream()，并把返回值封装到一个DataInputStream里，以便自己能读取结果。要注意的一件事情是结果以文本行的形式显示在一个TextArea（文本区域）中。为什么不简单地使用getAppletContext().showDocument(u)呢？事实上，这正是那些陷阱中的一个。上述代码可以很好地工作，但假如试图换用showDocument()，几乎一切都会停止运行。也就是说，showDocument()确实可以运行，但从POSTtest得到的返回结果是“Zero CONTENT_LENGTH”（内容长度为零）。所以不知道为什么原因，showDocument()阻止了POST查询向CGI程序的传递。我很难判断这到底是一个在以后版本里会修复的Bug，还是由于我的理解不够（我看过的书对此讲得都很模糊）。但无论在哪种情况下，只要能坚持在文本区域里观看自CGI程序返回的内容，上述程序片运行时就没有问题。<br>
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
			</div>
			<!-- /.row -->
			  <hr>
        <!-- Footer -->
        <footer>
            <div class="row">
                <div class="col-lg-12">
                    <p>Copyright &copy; 小龙软件工作室 2016</p>
                </div>
            </div>
        </footer>

    </div>
    <!-- /.container -->

    <!-- jQuery -->
    <script src="../../js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="../../js/bootstrap.min.js"></script>

</body>

</html>
