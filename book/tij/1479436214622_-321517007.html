<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="content-type" content="text/html;charset=utf-8">
    <meta charset="utf-8">
<meta name="360-site-verification" content="cabcfb5a0f4c0d28d604e8a69e6c0cdb" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="baidu-site-verification" content="HknqsD2zhn" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>java编程思想(thinking in java)-编码助手网</title>
      <meta content="为编码人员提供在线文档、模板等帮助，提升解决问题效率" name="description">
			<meta content="java编程思想(thinking in java) Java, spring, tomcat, servlet, jsp, api doc, bootstrap" name="keywords">
<meta name="sogou_site_verification" content="42nApEZFKO"/>


    <!-- Bootstrap Core CSS -->
    <link href="../../css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="../../css/heroic-features.css" rel="stylesheet">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
		<script>
		var _hmt = _hmt || [];
		(function() {
		  var hm = document.createElement("script");
		  hm.src = "//hm.baidu.com/hm.js?dd1361ca20a10cc161e72d4bc4fef6df";
		  var s = document.getElementsByTagName("script")[0];
		  s.parentNode.insertBefore(hm, s);
		})();
		</script>

</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">编码助手网</a>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav">
                    <li>
                        <a href="/">首页</a>
                    </li>
										<li>
                        <a href="/template.html">模板</a>
                    </li>
										<li>
												<a href="/doc.html">文档</a>
										</li>
                    <li>
                        <a href="/contact.html">联系我们</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Content -->
    <div class="container">

			<div class="row">
					<div class="col-xs-4">
						<h4>java编程思想(thinking in java)</h4>
						<h6>感谢http://quanke.name提供内容</h6>
<ul><li><a href='./1479436214592_-168316990.html'>Introduction</a></li><li><a href='./1479436214605_802664538.html'>写在前面的话</a></li><li><a href='./1479436214605_-791815332.html'>引言</a></li><li><a href='./1479436214605_1266451767.html'>第1章 对象入门</a></li><li><ul><li><a href='./1479436214606_-1211955969.html'>1.1 抽象的进步</a></li><li><a href='./1479436214606_-985491570.html'>1.2 对象的接口</a></li><li><a href='./1479436214606_421738363.html'>1.3 实现方案的隐藏</a></li><li><a href='./1479436214607_1726094433.html'>1.4 方案的重复使用</a></li><li><a href='./1479436214607_-1917493719.html'>1.5 继承：重新使用接口</a></li><li><a href='./1479436214607_-994529289.html'>1.6 多形对象的互换使用</a></li><li><a href='./1479436214608_695543294.html'>1.7 对象的创建和存在时间</a></li><li><a href='./1479436214609_186799536.html'>1.8 违例控制：解决错误</a></li><li><a href='./1479436214609_225257298.html'>1.9 多线程</a></li><li><a href='./1479436214610_-1377857368.html'>1.10 永久性</a></li><li><a href='./1479436214610_-1567485742.html'>1.11 Java和因特网</a></li><li><a href='./1479436214610_-534049255.html'>1.12 分析和设计</a></li><li><a href='./1479436214611_-516206529.html'>1.13 Java还是C++</a></li></ul></li><li><a href='./1479436214611_-833808368.html'>第2章 一切都是对象</a></li><li><ul><li><a href='./1479436214611_160489487.html'>2.1 用句柄操纵对象</a></li><li><a href='./1479436214611_-395400265.html'>2.2 所有对象都必须创建</a></li><li><a href='./1479436214612_-105112715.html'>2.3 绝对不要清除对象</a></li><li><a href='./1479436214612_-1081120728.html'>2.4 新建数据类型：类</a></li><li><a href='./1479436214612_437273775.html'>2.5 方法、自变量和返回值</a></li><li><a href='./1479436214612_968479086.html'>2.6 构建Java程序</a></li><li><a href='./1479436214612_-1963386412.html'>2.7 我们的第一个Java程序</a></li><li><a href='./1479436214613_988202688.html'>2.8 注释和嵌入文档</a></li><li><a href='./1479436214613_-642199972.html'>2.9 编码样式</a></li><li><a href='./1479436214613_-1135594618.html'>2.10 总结</a></li><li><a href='./1479436214613_976703976.html'>2.11 练习</a></li></ul></li><li><a href='./1479436214614_1617201657.html'>第3章 控制程序流程</a></li><li><ul><li><a href='./1479436214614_479400700.html'>3.1 使用Java运算符</a></li><li><a href='./1479436214614_-9479532.html'>3.2 执行控制</a></li><li><a href='./1479436214614_198965659.html'>3.3 总结</a></li><li><a href='./1479436214615_-634539581.html'>3.4 练习</a></li></ul></li><li><a href='./1479436214615_-1049694152.html'>第4章 初始化和清除</a></li><li><ul><li><a href='./1479436214615_-614369641.html'>4.1 用构建器自动初始化</a></li><li><a href='./1479436214615_-2107354158.html'>4.2 方法过载</a></li><li><a href='./1479436214616_2106438365.html'>4.3 清除：收尾和垃圾收集</a></li><li><a href='./1479436214616_-1969096840.html'>4.4 成员初始化</a></li><li><a href='./1479436214616_55724218.html'>4.5 数组初始化</a></li><li><a href='./1479436214616_-51810259.html'>4.6 总结</a></li><li><a href='./1479436214616_749059750.html'>4.7 练习</a></li></ul></li><li><a href='./1479436214617_-1201809261.html'>第5章 隐藏实施过程</a></li><li><ul><li><a href='./1479436214617_75246657.html'>5.1 包：库单元</a></li><li><a href='./1479436214617_-738077386.html'>5.2 Java访问指示符</a></li><li><a href='./1479436214617_-131608479.html'>5.3 接口与实现</a></li><li><a href='./1479436214617_-1940689271.html'>5.4 类访问</a></li><li><a href='./1479436214618_1119703547.html'>5.5 总结</a></li><li><a href='./1479436214618_-768700500.html'>5.6 练习</a></li></ul></li><li><a href='./1479436214618_303969565.html'>第6章 类再生</a></li><li><ul><li><a href='./1479436214618_1498787567.html'>6.1 合成的语法</a></li><li><a href='./1479436214618_1797834651.html'>6.2 继承的语法</a></li><li><a href='./1479436214619_128080957.html'>6.3 合成与继承的结合</a></li><li><a href='./1479436214619_-538376950.html'>6.4 到底选择合成还是继承</a></li><li><a href='./1479436214619_754950718.html'>6.5 protected</a></li><li><a href='./1479436214619_68859466.html'>6.6 累积开发</a></li><li><a href='./1479436214620_1707544672.html'>6.7 上溯造型</a></li><li><a href='./1479436214620_-1441830877.html'>6.8 final关键字</a></li><li><a href='./1479436214620_1153478487.html'>6.9 初始化和类装载</a></li><li><a href='./1479436214620_-39288028.html'>6.10 总结</a></li><li><a href='./1479436214620_537511919.html'>6.11 练习</a></li></ul></li><li><a href='./1479436214621_636771584.html'>第7章 多形性</a></li><li><ul><li><a href='./1479436214621_14200843.html'>7.1 上溯造型</a></li><li><a href='./1479436214621_-125275107.html'>7.2 深入理解</a></li><li><a href='./1479436214621_-1006098686.html'>7.3 覆盖与过载</a></li><li><a href='./1479436214622_1469935979.html'>7.4 抽象类和方法</a></li><li><a href='./1479436214622_-321517007.html'>7.5 接口</a></li><li><a href='./1479436214622_-1548998791.html'>7.6 内部类</a></li><li><a href='./1479436214622_-1125287817.html'>7.7 构建器和多形性</a></li><li><a href='./1479436214622_1541346557.html'>7.8 通过继承进行设计</a></li><li><a href='./1479436214623_1527391664.html'>7.9 总结</a></li><li><a href='./1479436214623_-953872192.html'>7.10 练习</a></li></ul></li><li><a href='./1479436214623_-1694327281.html'>第8章 对象的容纳</a></li><li><ul><li><a href='./1479436214623_1677953038.html'>8.1 数组</a></li><li><a href='./1479436214623_157279663.html'>8.2 集合</a></li><li><a href='./1479436214624_2028486897.html'>8.3 枚举器（反复器）</a></li><li><a href='./1479436214624_1552417959.html'>8.4 集合的类型</a></li><li><a href='./1479436214624_-1236839872.html'>8.5 排序</a></li><li><a href='./1479436214624_948884352.html'>8.6 通用集合库</a></li><li><a href='./1479436214624_-29314847.html'>8.7 新集合</a></li><li><a href='./1479436214625_950741899.html'>8.8 总结</a></li><li><a href='./1479436214625_-235386019.html'>8.9 练习</a></li></ul></li><li><a href='./1479436214625_-1144170168.html'>第9章 违例差错控制</a></li><li><ul><li><a href='./1479436214625_1164481198.html'>9.1 基本违例</a></li><li><a href='./1479436214625_639309640.html'>9.2 违例的捕获</a></li><li><a href='./1479436214625_545387660.html'>9.3 标准Java违例</a></li><li><a href='./1479436214625_1703684624.html'>9.4 创建自己的违例</a></li><li><a href='./1479436214626_-1814781625.html'>9.5 违例的限制</a></li><li><a href='./1479436214626_1362968450.html'>9.6 用finally清除</a></li><li><a href='./1479436214626_1696138810.html'>9.7 构建器</a></li><li><a href='./1479436214626_-946669500.html'>9.8 违例匹配</a></li><li><a href='./1479436214626_1369629725.html'>9.9 总结</a></li><li><a href='./1479436214626_1887454245.html'>9.10 练习</a></li></ul></li><li><a href='./1479436214627_-823192075.html'>第10章 Java IO系统</a></li><li><ul><li><a href='./1479436214627_793225325.html'>10.1 输入和输出</a></li><li><a href='./1479436214627_-1441186029.html'>10.2 增添属性和有用的接口</a></li><li><a href='./1479436214627_1039462397.html'>10.3 本身的缺陷：RandomAccessFile</a></li><li><a href='./1479436214627_1841380738.html'>10.4 File类</a></li><li><a href='./1479436214628_2095064408.html'>10.5 IO流的典型应用</a></li><li><a href='./1479436214628_1699205963.html'>10.6 StreamTokenizer</a></li><li><a href='./1479436214628_-1183832916.html'>10.7 Java 1.1的IO流</a></li><li><a href='./1479436214628_1169764652.html'>10.8 压缩</a></li><li><a href='./1479436214628_599949674.html'>10.9 对象序列化</a></li><li><a href='./1479436214629_822501598.html'>10.10 总结</a></li><li><a href='./1479436214629_784582642.html'>10.11 练习</a></li></ul></li><li><a href='./1479436214629_-446109494.html'>第11章 运行期类型鉴定</a></li><li><ul><li><a href='./1479436214629_615980680.html'>11.1 对RTTI的需要</a></li><li><a href='./1479436214629_1591261577.html'>11.2 RTTI语法</a></li><li><a href='./1479436214629_-479724471.html'>11.3 反射：运行期类信息</a></li><li><a href='./1479436214630_1962275414.html'>11.4 总结</a></li><li><a href='./1479436214630_-104101779.html'>11.5 练习</a></li></ul></li><li><a href='./1479436214630_2105662301.html'>第12章 传递和返回对象</a></li><li><ul><li><a href='./1479436214630_-381058478.html'>12.1 传递句柄</a></li><li><a href='./1479436214630_1317862656.html'>12.2 制作本地副本</a></li><li><a href='./1479436214630_66286946.html'>12.3 克隆的控制</a></li><li><a href='./1479436214631_1628962510.html'>12.4 只读类</a></li><li><a href='./1479436214631_178950784.html'>12.5 总结</a></li><li><a href='./1479436214631_204549698.html'>12.6 练习</a></li></ul></li><li><a href='./1479436214631_1667056471.html'>第13章 创建窗口和程序片</a></li><li><a href='./1479436214631_1646591288.html'>第14章 多线程</a></li><li><ul><li><a href='./1479436214631_-2057627207.html'>14.1 反应灵敏的用户界面</a></li><li><a href='./1479436214631_1635675213.html'>14.2 共享有限的资源</a></li><li><a href='./1479436214632_1587335383.html'>14.3 堵塞</a></li><li><a href='./1479436214632_1322789348.html'>14.4 优先级</a></li><li><a href='./1479436214632_1679851836.html'>14.5 回顾runnable</a></li><li><a href='./1479436214632_-914514060.html'>14.6 总结</a></li><li><a href='./1479436214632_1301544438.html'>14.7 练习</a></li></ul></li><li><a href='./1479436214633_1637559906.html'>第15章 网络编程</a></li><li><ul><li><a href='./1479436214633_-2140545630.html'>15.1 机器的标识</a></li><li><a href='./1479436214633_946775708.html'>15.2 套接字</a></li><li><a href='./1479436214634_1854884592.html'>15.3 服务多个客户</a></li><li><a href='./1479436214634_1410414288.html'>15.4 数据报</a></li><li><a href='./1479436214634_224372951.html'>15.5 一个Web应用</a></li><li><a href='./1479436214634_-1622230225.html'>15.6 Java与CGI的沟通</a></li><li><a href='./1479436214634_-903287570.html'>15.7 用JDBC连接数据库</a></li><li><a href='./1479436214634_-416599191.html'>15.8 远程方法</a></li><li><a href='./1479436214635_-917204139.html'>15.9 总结</a></li><li><a href='./1479436214635_-540223303.html'>15.10 练习</a></li></ul></li><li><a href='./1479436214635_339847129.html'>第16章 设计范式</a></li><li><ul><li><a href='./1479436214635_1826776975.html'>16.1 范式的概念</a></li><li><a href='./1479436214635_1309397010.html'>16.2 观察器范式</a></li><li><a href='./1479436214636_132034955.html'>16.3 模拟垃圾回收站</a></li><li><a href='./1479436214636_1756675694.html'>16.4 改进设计</a></li><li><a href='./1479436214636_-1966590010.html'>16.5 抽象的应用</a></li><li><a href='./1479436214636_-1831214784.html'>16.6 多重派遣</a></li><li><a href='./1479436214636_1935634882.html'>16.7 访问器范式</a></li><li><a href='./1479436214636_1843093443.html'>16.8 RTTI真的有害吗</a></li><li><a href='./1479436214636_-1838860121.html'>16.9 总结</a></li><li><a href='./1479436214637_-1901505940.html'>16.10 练习</a></li></ul></li><li><a href='./1479436214637_-387290815.html'>第17章 项目</a></li><li><ul><li><a href='./1479436214637_-498587551.html'>17.1 文字处理</a></li><li><a href='./1479436214637_1300299412.html'>17.2 方法查找工具</a></li><li><a href='./1479436214637_1681291541.html'>17.3 复杂性理论</a></li><li><a href='./1479436214637_-1113877505.html'>17.4 总结</a></li><li><a href='./1479436214638_-1637352061.html'>17.5 练习</a></li></ul></li><li><a href='./1479436214638_931172498.html'>附录A 使用非JAVA代码</a></li><li><a href='./1479436214638_882880730.html'>附录B 对比C++和Java</a></li><li><a href='./1479436214638_-283304223.html'>附录C Java编程规则</a></li><li><a href='./1479436214638_-1842547113.html'>附录D 性能</a></li><li><a href='./1479436214638_749950023.html'>附录E 关于垃圾收集的一些话</a></li><li><a href='./1479436214639_2079199942.html'>附录F 推荐读物</a></li><li></li>
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
					<div class="col-xs-8">
# 7.5 接口<br><br><br>“interface”（接口）关键字使抽象的概念更深入了一层。我们可将其想象为一个“纯”抽象类。它允许创建者规定一个类的基本形式：方法名、自变量列表以及返回类型，但不规定方法主体。接口也包含了基本数据类型的数据成员，但它们都默认为static和final。接口只提供一种形式，并不提供实施的细节。<br><br>接口这样描述自己：“对于实现我的所有类，看起来都应该象我现在这个样子”。因此，采用了一个特定接口的所有代码都知道对于那个接口可能会调用什么方法。这便是接口的全部含义。所以我们常把接口用于建立类和类之间的一个“协议”。有些面向对象的程序设计语言采用了一个名为“protocol”（协议）的关键字，它做的便是与接口相同的事情。<br><br>为创建一个接口，请使用interface关键字，而不要用class。与类相似，我们可在interface关键字的前面增加一个public关键字（但只有接口定义于同名的一个文件内）；或者将其省略，营造一种“友好的”状态。<br><br>为了生成与一个特定的接口（或一组接口）相符的类，要使用implements（实现）关键字。我们要表达的意思是“接口看起来就象那个样子，这儿是它具体的工作细节”。除这些之外，我们其他的工作都与继承极为相似。下面是乐器例子的示意图：<br><br>![](7-4.gif)<br><br>具体实现了一个接口以后，就获得了一个普通的类，可用标准方式对其进行扩展。<br><br>可决定将一个接口中的方法声明明确定义为“public”。但即便不明确定义，它们也会默认为public。所以在实现一个接口的时候，来自接口的方法必须定义成public。否则的话，它们会默认为“友好的”，而且会限制我们在继承过程中对一个方法的访问——Java编译器不允许我们那样做。<br><br>在Instrument例子的修改版本中，大家可明确地看出这一点。注意接口中的每个方法都严格地是一个声明，它是编译器唯一允许的。除此以外，Instrument5中没有一个方法被声明为public，但它们都会自动获得public属性。如下所示：<br><br>```<br>//: Music5.java<br>// Interfaces<br>import java.util.*;<br><br>interface Instrument5 {<br>  // Compile-time constant:<br>  int i = 5; // static & final<br>  // Cannot have method definitions:<br>  void play(); // Automatically public<br>  String what();<br>  void adjust();<br>}<br><br>class Wind5 implements Instrument5 {<br>  public void play() {<br>    System.out.println("Wind5.play()");<br>  }<br>  public String what() { return "Wind5"; }<br>  public void adjust() {}<br>}<br><br>class Percussion5 implements Instrument5 {<br>  public void play() {<br>    System.out.println("Percussion5.play()");<br>  }<br>  public String what() { return "Percussion5"; }<br>  public void adjust() {}<br>}<br><br>class Stringed5 implements Instrument5 {<br>  public void play() {<br>    System.out.println("Stringed5.play()");<br>  }<br>  public String what() { return "Stringed5"; }<br>  public void adjust() {}<br>}<br><br>class Brass5 extends Wind5 {<br>  public void play() {<br>    System.out.println("Brass5.play()");<br>  }<br>  public void adjust() { <br>    System.out.println("Brass5.adjust()");<br>  }<br>}<br><br>class Woodwind5 extends Wind5 {<br>  public void play() {<br>    System.out.println("Woodwind5.play()");<br>  }<br>  public String what() { return "Woodwind5"; }<br>}<br><br>public class Music5 {<br>  // Doesn't care about type, so new types<br>  // added to the system still work right:<br>  static void tune(Instrument5 i) {<br>    // ...<br>    i.play();<br>  }<br>  static void tuneAll(Instrument5[] e) {<br>    for(int i = 0; i < e.length; i++)<br>      tune(e[i]);<br>  }<br>  public static void main(String[] args) {<br>    Instrument5[] orchestra = new Instrument5[5];<br>    int i = 0;<br>    // Upcasting during addition to the array:<br>    orchestra[i++] = new Wind5();<br>    orchestra[i++] = new Percussion5();<br>    orchestra[i++] = new Stringed5();<br>    orchestra[i++] = new Brass5();<br>    orchestra[i++] = new Woodwind5();<br>    tuneAll(orchestra);<br>  }<br>} ///:~<br>```<br><br>代码剩余的部分按相同的方式工作。我们可以自由决定上溯造型到一个名为Instrument5的“普通”类，一个名为Instrument5的“抽象”类，或者一个名为Instrument5的“接口”。所有行为都是相同的。事实上，我们在tune()方法中可以发现没有任何证据显示Instrument5到底是个“普通”类、“抽象”类还是一个“接口”。这是做是故意的：每种方法都使程序员能对对象的创建与使用进行不同的控制。<br><br>7.5.1 Java的“多重继承”<br><br>接口只是比抽象类“更纯”的一种形式。它的用途并不止那些。由于接口根本没有具体的实施细节——也就是说，没有与存储空间与“接口”关联在一起——所以没有任何办法可以防止多个接口合并到一起。这一点是至关重要的，因为我们经常都需要表达这样一个意思：“x从属于a，也从属于b，也从属于c”。在C++中，将多个类合并到一起的行动称作“多重继承”，而且操作较为不便，因为每个类都可能有一套自己的实施细节。在Java中，我们可采取同样的行动，但只有其中一个类拥有具体的实施细节。所以在合并多个接口的时候，C++的问题不会在Java中重演。如下所示：<br><br>![](7-5.gif)<br><br>在一个衍生类中，我们并不一定要拥有一个抽象或具体（没有抽象方法）的基础类。如果确实想从一个非接口继承，那么只能从一个继承。剩余的所有基本元素都必须是“接口”。我们将所有接口名置于implements关键字的后面，并用逗号分隔它们。可根据需要使用多个接口，而且每个接口都会成为一个独立的类型，可对其进行上溯造型。下面这个例子展示了一个“具体”类同几个接口合并的情况，它最终生成了一个新类：<br><br>```<br>//: Adventure.java<br>// Multiple interfaces<br>import java.util.*;<br><br>interface CanFight {<br>  void fight();<br>}<br><br>interface CanSwim {<br>  void swim();<br>}<br><br>interface CanFly {<br>  void fly();<br>}<br><br>class ActionCharacter {<br>  public void fight() {}<br>}<br><br>class Hero extends ActionCharacter <br>    implements CanFight, CanSwim, CanFly {<br>  public void swim() {}<br>  public void fly() {}<br>}<br><br>public class Adventure {<br>  static void t(CanFight x) { x.fight(); }<br>  static void u(CanSwim x) { x.swim(); }<br>  static void v(CanFly x) { x.fly(); }<br>  static void w(ActionCharacter x) { x.fight(); }<br>  public static void main(String[] args) {<br>    Hero i = new Hero();<br>    t(i); // Treat it as a CanFight<br>    u(i); // Treat it as a CanSwim<br>    v(i); // Treat it as a CanFly<br>    w(i); // Treat it as an ActionCharacter<br>  }<br>} ///:~<br>```<br><br>从中可以看到，Hero将具体类ActionCharacter同接口CanFight，CanSwim以及CanFly合并起来。按这种形式合并一个具体类与接口的时候，具体类必须首先出现，然后才是接口（否则编译器会报错）。<br><br>请注意fight()的签名在CanFight接口与ActionCharacter类中是相同的，而且没有在Hero中为fight()提供一个具体的定义。接口的规则是：我们可以从它继承（稍后就会看到），但这样得到的将是另一个接口。如果想创建新类型的一个对象，它就必须是已提供所有定义的一个类。尽管Hero没有为fight()明确地提供一个定义，但定义是随同ActionCharacter来的，所以这个定义会自动提供，我们可以创建Hero的对象。<br><br>在类Adventure中，我们可看到共有四个方法，它们将不同的接口和具体类作为自己的自变量使用。创建一个Hero对象后，它可以传递给这些方法中的任何一个。这意味着它们会依次上溯造型到每一个接口。由于接口是用Java设计的，所以这样做不会有任何问题，而且程序员不必对此加以任何特别的关注。<br><br>注意上述例子已向我们揭示了接口最关键的作用，也是使用接口最重要的一个原因：能上溯造型至多个基础类。使用接口的第二个原因与使用抽象基础类的原因是一样的：防止客户程序员制作这个类的一个对象，以及规定它仅仅是一个接口。这样便带来了一个问题：到底应该使用一个接口还是一个抽象类呢？若使用接口，我们可以同时获得抽象类以及接口的好处。所以假如想创建的基础类没有任何方法定义或者成员变量，那么无论如何都愿意使用接口，而不要选择抽象类。事实上，如果事先知道某种东西会成为基础类，那么第一个选择就是把它变成一个接口。只有在必须使用方法定义或者成员变量的时候，才应考虑采用抽象类。<br><br>7.5.2 通过继承扩展接口<br><br>利用继承技术，可方便地为一个接口添加新的方法声明，也可以将几个接口合并成一个新接口。在这两种情况下，最终得到的都是一个新接口，如下例所示：<br><br>```<br>//: HorrorShow.java<br>// Extending an interface with inheritance<br><br>interface Monster {<br>  void menace();<br>}<br><br>interface DangerousMonster extends Monster {<br>  void destroy();<br>}<br><br>interface Lethal {<br>  void kill();<br>}<br><br>class DragonZilla implements DangerousMonster {<br>  public void menace() {}<br>  public void destroy() {}<br>}<br><br>interface Vampire <br>    extends DangerousMonster, Lethal {<br>  void drinkBlood();<br>}<br><br>class HorrorShow {<br>  static void u(Monster b) { b.menace(); }<br>  static void v(DangerousMonster d) {<br>    d.menace();<br>    d.destroy();<br>  }<br>  public static void main(String[] args) {<br>    DragonZilla if2 = new DragonZilla();<br>    u(if2);<br>    v(if2);<br>  }<br>} ///:~<br>```<br><br>DangerousMonster是对Monster的一个简单的扩展，最终生成了一个新接口。这是在DragonZilla里实现的。<br>Vampire的语法仅在继承接口时才可使用。通常，我们只能对单独一个类应用extends（扩展）关键字。但由于接口可能由多个其他接口构成，所以在构建一个新接口时，extends可能引用多个基础接口。正如大家看到的那样，接口的名字只是简单地使用逗号分隔。<br><br>7.5.3 常数分组<br><br>由于置入一个接口的所有字段都自动具有static和final属性，所以接口是对常数值进行分组的一个好工具，它具有与C或C++的enum非常相似的效果。如下例所示：<br><br>```<br>//: Months.java<br>// Using interfaces to create groups of constants<br>package c07;<br><br>public interface Months {<br>  int<br>    JANUARY = 1, FEBRUARY = 2, MARCH = 3, <br>    APRIL = 4, MAY = 5, JUNE = 6, JULY = 7, <br>    AUGUST = 8, SEPTEMBER = 9, OCTOBER = 10,<br>    NOVEMBER = 11, DECEMBER = 12;<br>} ///:~<br>```<br><br>注意根据Java命名规则，拥有固定标识符的static final基本数据类型（亦即编译期常数）都全部采用大写字母（用下划线分隔单个标识符里的多个单词）。<br><br>接口中的字段会自动具备public属性，所以没必要专门指定。<br><br>现在，通过导入 `c07.*` 或 `c07.Months` ，我们可以从包的外部使用常数——就象对其他任何包进行的操作那样。此外，也可以用类似Months.JANUARY的表达式对值进行引用。当然，我们获得的只是一个int，所以不象C++的enum那样拥有额外的类型安全性。但与将数字强行编码（硬编码）到自己的程序中相比，这种（常用的）技术无疑已经是一个巨大的进步。我们通常把“硬编码”数字的行为称为“魔术数字”，它产生的代码是非常难以维护的。<br>如确实不想放弃额外的类型安全性，可构建象下面这样的一个类（注释①）：<br><br>```<br>//: Month2.java<br>// A more robust enumeration system<br>package c07;<br><br>public final class Month2 {<br>  private String name;<br>  private Month2(String nm) { name = nm; }<br>  public String toString() { return name; }<br>  public final static Month2<br>    JAN = new Month2("January"), <br>    FEB = new Month2("February"),<br>    MAR = new Month2("March"),<br>    APR = new Month2("April"),<br>    MAY = new Month2("May"),<br>    JUN = new Month2("June"),<br>    JUL = new Month2("July"),<br>    AUG = new Month2("August"),<br>    SEP = new Month2("September"),<br>    OCT = new Month2("October"),<br>    NOV = new Month2("November"),<br>    DEC = new Month2("December");<br>  public final static Month2[] month =  {<br>    JAN, JAN, FEB, MAR, APR, MAY, JUN,<br>    JUL, AUG, SEP, OCT, NOV, DEC<br>  };<br>  public static void main(String[] args) {<br>    Month2 m = Month2.JAN;<br>    System.out.println(m);<br>    m = Month2.month[12];<br>    System.out.println(m);<br>    System.out.println(m == Month2.DEC);<br>    System.out.println(m.equals(Month2.DEC));<br>  }<br>} ///:~<br>```<br><br>①：是Rich Hoffarth的一封E-mail触发了我这样编写程序的灵感。<br><br>这个类叫作Month2，因为标准Java库里已经有一个Month。它是一个final类，并含有一个private构建器，所以没有人能从它继承，或制作它的一个实例。唯一的实例就是那些final static对象，它们是在类本身内部创建的，包括：JAN，FEB，MAR等等。这些对象也在month数组中使用，后者让我们能够按数字挑选月份，而不是按名字（注意数组中提供了一个多余的JAN，使偏移量增加了1，也使December确实成为12月）。在main()中，我们可注意到类型的安全性：m是一个Month2对象，所以只能将其分配给Month2。在前面的Months.java例子中，只提供了int值，所以本来想用来代表一个月份的int变量可能实际获得一个整数值，那样做可能不十分安全。<br>这儿介绍的方法也允许我们交换使用==或者equals()，就象main()尾部展示的那样。<br><br>7.5.4 初始化接口中的字段<br><br>接口中定义的字段会自动具有static和final属性。它们不能是“空白final”，但可初始化成非常数表达式。例如：<br><br>```<br>//: RandVals.java<br>// Initializing interface fields with <br>// non-constant initializers<br>import java.util.*;<br><br>public interface RandVals {<br>  int rint = (int)(Math.random() * 10);<br>  long rlong = (long)(Math.random() * 10);<br>  float rfloat = (float)(Math.random() * 10);<br>  double rdouble = Math.random() * 10;<br>} ///:~<br>```<br><br>由于字段是static的，所以它们会在首次装载类之后、以及首次访问任何字段之前获得初始化。下面是一个简单的测试：<br><br>```<br>//: TestRandVals.java<br><br>public class TestRandVals {<br>  public static void main(String[] args) {<br>    System.out.println(RandVals.rint);<br>    System.out.println(RandVals.rlong);<br>    System.out.println(RandVals.rfloat);<br>    System.out.println(RandVals.rdouble);<br>  }<br>} ///:~<br>```<br><br>当然，字段并不是接口的一部分，而是保存于那个接口的static存储区域中。<br>
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
			</div>
			<!-- /.row -->
			  <hr>
        <!-- Footer -->
        <footer>
            <div class="row">
                <div class="col-lg-12">
                    <p>Copyright &copy; 小龙软件工作室 2016</p>
                </div>
            </div>
        </footer>

    </div>
    <!-- /.container -->

    <!-- jQuery -->
    <script src="../../js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="../../js/bootstrap.min.js"></script>

</body>

</html>
