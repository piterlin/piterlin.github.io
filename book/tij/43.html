<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="content-type" content="text/html;charset=utf-8">
    <meta charset="utf-8">
<meta name="360-site-verification" content="cabcfb5a0f4c0d28d604e8a69e6c0cdb" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="baidu-site-verification" content="HknqsD2zhn" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>java编程思想(thinking in java)-编码助手网</title>
      <meta content="为编码人员提供在线文档、模板等帮助，提升解决问题效率" name="description">
			<meta content="java编程思想(thinking in java) Java, spring, tomcat, servlet, jsp, api doc, bootstrap" name="keywords">
<meta name="sogou_site_verification" content="42nApEZFKO"/>


    <!-- Bootstrap Core CSS -->
    <link href="../../css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="../../css/heroic-features.css" rel="stylesheet">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
		<script>
		var _hmt = _hmt || [];
		(function() {
		  var hm = document.createElement("script");
		  hm.src = "//hm.baidu.com/hm.js?dd1361ca20a10cc161e72d4bc4fef6df";
		  var s = document.getElementsByTagName("script")[0];
		  s.parentNode.insertBefore(hm, s);
		})();
		</script>

</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">编码助手网</a>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav">
                    <li>
                        <a href="/">首页</a>
                    </li>
										<li>
                        <a href="/template.html">模板</a>
                    </li>
										<li>
												<a href="/doc.html">文档</a>
										</li>
                    <li>
                        <a href="/contact.html">联系我们</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Content -->
    <div class="container">

			<div class="row">
					<div class="col-xs-4">
						<h4>java编程思想(thinking in java)</h4>
						<h6>感谢quanke.name提供内容</h6>
<ul><li><a href='./0.html'>Introduction</a></li><li><a href='./1.html'>写在前面的话</a></li><li><a href='./2.html'>引言</a></li><li><a href='./3.html'>第1章 对象入门</a></li><li><ul><li><a href='./4.html'>1.1 抽象的进步</a></li><li><a href='./5.html'>1.2 对象的接口</a></li><li><a href='./6.html'>1.3 实现方案的隐藏</a></li><li><a href='./7.html'>1.4 方案的重复使用</a></li><li><a href='./8.html'>1.5 继承：重新使用接口</a></li><li><a href='./9.html'>1.6 多形对象的互换使用</a></li><li><a href='./10.html'>1.7 对象的创建和存在时间</a></li><li><a href='./11.html'>1.8 违例控制：解决错误</a></li><li><a href='./12.html'>1.9 多线程</a></li><li><a href='./13.html'>1.10 永久性</a></li><li><a href='./14.html'>1.11 Java和因特网</a></li><li><a href='./15.html'>1.12 分析和设计</a></li><li><a href='./16.html'>1.13 Java还是C++</a></li></ul></li><li><a href='./17.html'>第2章 一切都是对象</a></li><li><ul><li><a href='./18.html'>2.1 用句柄操纵对象</a></li><li><a href='./19.html'>2.2 所有对象都必须创建</a></li><li><a href='./20.html'>2.3 绝对不要清除对象</a></li><li><a href='./21.html'>2.4 新建数据类型：类</a></li><li><a href='./22.html'>2.5 方法、自变量和返回值</a></li><li><a href='./23.html'>2.6 构建Java程序</a></li><li><a href='./24.html'>2.7 我们的第一个Java程序</a></li><li><a href='./25.html'>2.8 注释和嵌入文档</a></li><li><a href='./26.html'>2.9 编码样式</a></li><li><a href='./27.html'>2.10 总结</a></li><li><a href='./28.html'>2.11 练习</a></li></ul></li><li><a href='./29.html'>第3章 控制程序流程</a></li><li><ul><li><a href='./30.html'>3.1 使用Java运算符</a></li><li><a href='./31.html'>3.2 执行控制</a></li><li><a href='./32.html'>3.3 总结</a></li><li><a href='./33.html'>3.4 练习</a></li></ul></li><li><a href='./34.html'>第4章 初始化和清除</a></li><li><ul><li><a href='./35.html'>4.1 用构建器自动初始化</a></li><li><a href='./36.html'>4.2 方法过载</a></li><li><a href='./37.html'>4.3 清除：收尾和垃圾收集</a></li><li><a href='./38.html'>4.4 成员初始化</a></li><li><a href='./39.html'>4.5 数组初始化</a></li><li><a href='./40.html'>4.6 总结</a></li><li><a href='./41.html'>4.7 练习</a></li></ul></li><li><a href='./42.html'>第5章 隐藏实施过程</a></li><li><ul><li><a href='./43.html'>5.1 包：库单元</a></li><li><a href='./44.html'>5.2 Java访问指示符</a></li><li><a href='./45.html'>5.3 接口与实现</a></li><li><a href='./46.html'>5.4 类访问</a></li><li><a href='./47.html'>5.5 总结</a></li><li><a href='./48.html'>5.6 练习</a></li></ul></li><li><a href='./49.html'>第6章 类再生</a></li><li><ul><li><a href='./50.html'>6.1 合成的语法</a></li><li><a href='./51.html'>6.2 继承的语法</a></li><li><a href='./52.html'>6.3 合成与继承的结合</a></li><li><a href='./53.html'>6.4 到底选择合成还是继承</a></li><li><a href='./54.html'>6.5 protected</a></li><li><a href='./55.html'>6.6 累积开发</a></li><li><a href='./56.html'>6.7 上溯造型</a></li><li><a href='./57.html'>6.8 final关键字</a></li><li><a href='./58.html'>6.9 初始化和类装载</a></li><li><a href='./59.html'>6.10 总结</a></li><li><a href='./60.html'>6.11 练习</a></li></ul></li><li><a href='./61.html'>第7章 多形性</a></li><li><ul><li><a href='./62.html'>7.1 上溯造型</a></li><li><a href='./63.html'>7.2 深入理解</a></li><li><a href='./64.html'>7.3 覆盖与过载</a></li><li><a href='./65.html'>7.4 抽象类和方法</a></li><li><a href='./66.html'>7.5 接口</a></li><li><a href='./67.html'>7.6 内部类</a></li><li><a href='./68.html'>7.7 构建器和多形性</a></li><li><a href='./69.html'>7.8 通过继承进行设计</a></li><li><a href='./70.html'>7.9 总结</a></li><li><a href='./71.html'>7.10 练习</a></li></ul></li><li><a href='./72.html'>第8章 对象的容纳</a></li><li><ul><li><a href='./73.html'>8.1 数组</a></li><li><a href='./74.html'>8.2 集合</a></li><li><a href='./75.html'>8.3 枚举器（反复器）</a></li><li><a href='./76.html'>8.4 集合的类型</a></li><li><a href='./77.html'>8.5 排序</a></li><li><a href='./78.html'>8.6 通用集合库</a></li><li><a href='./79.html'>8.7 新集合</a></li><li><a href='./80.html'>8.8 总结</a></li><li><a href='./81.html'>8.9 练习</a></li></ul></li><li><a href='./82.html'>第9章 违例差错控制</a></li><li><ul><li><a href='./83.html'>9.1 基本违例</a></li><li><a href='./84.html'>9.2 违例的捕获</a></li><li><a href='./85.html'>9.3 标准Java违例</a></li><li><a href='./86.html'>9.4 创建自己的违例</a></li><li><a href='./87.html'>9.5 违例的限制</a></li><li><a href='./88.html'>9.6 用finally清除</a></li><li><a href='./89.html'>9.7 构建器</a></li><li><a href='./90.html'>9.8 违例匹配</a></li><li><a href='./91.html'>9.9 总结</a></li><li><a href='./92.html'>9.10 练习</a></li></ul></li><li><a href='./93.html'>第10章 Java IO系统</a></li><li><ul><li><a href='./94.html'>10.1 输入和输出</a></li><li><a href='./95.html'>10.2 增添属性和有用的接口</a></li><li><a href='./96.html'>10.3 本身的缺陷：RandomAccessFile</a></li><li><a href='./97.html'>10.4 File类</a></li><li><a href='./98.html'>10.5 IO流的典型应用</a></li><li><a href='./99.html'>10.6 StreamTokenizer</a></li><li><a href='./100.html'>10.7 Java 1.1的IO流</a></li><li><a href='./101.html'>10.8 压缩</a></li><li><a href='./102.html'>10.9 对象序列化</a></li><li><a href='./103.html'>10.10 总结</a></li><li><a href='./104.html'>10.11 练习</a></li></ul></li><li><a href='./105.html'>第11章 运行期类型鉴定</a></li><li><ul><li><a href='./106.html'>11.1 对RTTI的需要</a></li><li><a href='./107.html'>11.2 RTTI语法</a></li><li><a href='./108.html'>11.3 反射：运行期类信息</a></li><li><a href='./109.html'>11.4 总结</a></li><li><a href='./110.html'>11.5 练习</a></li></ul></li><li><a href='./111.html'>第12章 传递和返回对象</a></li><li><ul><li><a href='./112.html'>12.1 传递句柄</a></li><li><a href='./113.html'>12.2 制作本地副本</a></li><li><a href='./114.html'>12.3 克隆的控制</a></li><li><a href='./115.html'>12.4 只读类</a></li><li><a href='./116.html'>12.5 总结</a></li><li><a href='./117.html'>12.6 练习</a></li></ul></li><li><a href='./118.html'>第13章 创建窗口和程序片</a></li><li><a href='./119.html'>第14章 多线程</a></li><li><ul><li><a href='./120.html'>14.1 反应灵敏的用户界面</a></li><li><a href='./121.html'>14.2 共享有限的资源</a></li><li><a href='./122.html'>14.3 堵塞</a></li><li><a href='./123.html'>14.4 优先级</a></li><li><a href='./124.html'>14.5 回顾runnable</a></li><li><a href='./125.html'>14.6 总结</a></li><li><a href='./126.html'>14.7 练习</a></li></ul></li><li><a href='./127.html'>第15章 网络编程</a></li><li><ul><li><a href='./128.html'>15.1 机器的标识</a></li><li><a href='./129.html'>15.2 套接字</a></li><li><a href='./130.html'>15.3 服务多个客户</a></li><li><a href='./131.html'>15.4 数据报</a></li><li><a href='./132.html'>15.5 一个Web应用</a></li><li><a href='./133.html'>15.6 Java与CGI的沟通</a></li><li><a href='./134.html'>15.7 用JDBC连接数据库</a></li><li><a href='./135.html'>15.8 远程方法</a></li><li><a href='./136.html'>15.9 总结</a></li><li><a href='./137.html'>15.10 练习</a></li></ul></li><li><a href='./138.html'>第16章 设计范式</a></li><li><ul><li><a href='./139.html'>16.1 范式的概念</a></li><li><a href='./140.html'>16.2 观察器范式</a></li><li><a href='./141.html'>16.3 模拟垃圾回收站</a></li><li><a href='./142.html'>16.4 改进设计</a></li><li><a href='./143.html'>16.5 抽象的应用</a></li><li><a href='./144.html'>16.6 多重派遣</a></li><li><a href='./145.html'>16.7 访问器范式</a></li><li><a href='./146.html'>16.8 RTTI真的有害吗</a></li><li><a href='./147.html'>16.9 总结</a></li><li><a href='./148.html'>16.10 练习</a></li></ul></li><li><a href='./149.html'>第17章 项目</a></li><li><ul><li><a href='./150.html'>17.1 文字处理</a></li><li><a href='./151.html'>17.2 方法查找工具</a></li><li><a href='./152.html'>17.3 复杂性理论</a></li><li><a href='./153.html'>17.4 总结</a></li><li><a href='./154.html'>17.5 练习</a></li></ul></li><li><a href='./155.html'>附录A 使用非JAVA代码</a></li><li><a href='./156.html'>附录B 对比C++和Java</a></li><li><a href='./157.html'>附录C Java编程规则</a></li><li><a href='./158.html'>附录D 性能</a></li><li><a href='./159.html'>附录E 关于垃圾收集的一些话</a></li><li><a href='./160.html'>附录F 推荐读物</a></li><li></li>
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
<div class="col-xs-8">
	<nav>
		<ul class="pager">
			<li class='previous'><a href='42.html'>&larr; 第5章 隐藏实施过程</a></li>
		<li class='next'><a href='44.html'>5.2 Java访问指示符&rarr;</a></li>
		</ul>
	</nav>
			<div class="row"><div class="col-xs-12"># 5.1 包：库单元<br><br><br>我们用import关键字导入一个完整的库时，就会获得“包”（Package）。例如：<br><br>```<br>import java.util.*;<br>```<br><br>它的作用是导入完整的实用工具（Utility）库，该库属于标准Java开发工具包的一部分。由于Vector位于java.util里，所以现在要么指定完整名称“java.util.Vector”（可省略import语句），要么简单地指定一个“Vector”（因为import是默认的）。<br><br>若想导入单独一个类，可在import语句里指定那个类的名字：<br><br>```<br>import java.util.Vector;<br>```<br><br>现在，我们可以自由地使用Vector。然而，java.util中的其他任何类仍是不可使用的。<br><br>之所以要进行这样的导入，是为了提供一种特殊的机制，以便管理“命名空间”（Name Space）。我们所有类成员的名字相互间都会隔离起来。位于类A内的一个方法f()不会与位于类B内的、拥有相同“签名”（自变量列表）的f()发生冲突。但类名会不会冲突呢？假设创建一个stack类，将它安装到已有一个stack类（由其他人编写）的机器上，这时会出现什么情况呢？对于因特网中的Java应用，这种情况会在用户毫不知晓的时候发生，因为类会在运行一个Java程序的时候自动下载。<br><br>正是由于存在名字潜在的冲突，所以特别有必要对Java中的命名空间进行完整的控制，而且需要创建一个完全独一无二的名字，无论因特网存在什么样的限制。<br><br>迄今为止，本书的大多数例子都仅存在于单个文件中，而且设计成局部（本地）使用，没有同包名发生冲突（在这种情况下，类名置于“默认包”内）。这是一种有效的做法，而且考虑到问题的简化，本书剩下的部分也将尽可能地采用它。然而，若计划创建一个“对因特网友好”或者说“适合在因特网使用”的程序，必须考虑如何防止类名的重复。<br>为Java创建一个源码文件的时候，它通常叫作一个“编辑单元”（有时也叫作“翻译单元”）。每个编译单元都必须有一个以.java结尾的名字。而且在编译单元的内部，可以有一个公共（public）类，它必须拥有与文件相同的名字（包括大小写形式，但排除.java文件扩展名）。如果不这样做，编译器就会报告出错。每个编译单元内都只能有一个public类（同样地，否则编译器会报告出错）。那个编译单元剩下的类（如果有的话）可在那个包外面的世界面前隐藏起来，因为它们并非“公共”的（非public），而且它们由用于主public类的“支撑”类组成。<br><br>编译一个.java文件时，我们会获得一个名字完全相同的输出文件；但对于.java文件中的每个类，它们都有一个.class扩展名。因此，我们最终从少量的.java文件里有可能获得数量众多的.class文件。如以前用一种汇编语言写过程序，那么可能已习惯编译器先分割出一种过渡形式（通常是一个.obj文件），再用一个链接器将其与其他东西封装到一起（生成一个可执行文件），或者与一个库封装到一起（生成一个库）。但那并不是Java的工作方式。一个有效的程序就是一系列.class文件，它们可以封装和压缩到一个JAR文件里（使用Java 1.1提供的jar工具）。Java解释器负责对这些文件的寻找、装载和解释（注释①）。<br><br>①：Java并没有强制一定要使用解释器。一些固有代码的Java编译器可生成单独的可执行文件。<br><br>“库”也由一系列类文件构成。每个文件都有一个public类（并没强迫使用一个public类，但这种情况最很典型的），所以每个文件都有一个组件。如果想将所有这些组件（它们在各自独立的.java和.class文件里）都归纳到一起，那么package关键字就可以发挥作用）。<br><br>若在一个文件的开头使用下述代码：<br><br>```<br>package mypackage;<br>```<br><br>那么package语句必须作为文件的第一个非注释语句出现。该语句的作用是指出这个编译单元属于名为mypackage的一个库的一部分。或者换句话说，它表明这个编译单元内的public类名位于mypackage这个名字的下面。如果其他人想使用这个名字，要么指出完整的名字，要么与mypackage联合使用import关键字（使用前面给出的选项）。注意根据Java包（封装）的约定，名字内的所有字母都应小写，甚至那些中间单词亦要如此。<br><br>例如，假定文件名是MyClass.java。它意味着在那个文件有一个、而且只能有一个public类。而且那个类的名字必须是MyClass（包括大小写形式）：<br><br>```<br>package mypackage;<br>public class MyClass {<br>// . . .<br>```<br><br>现在，如果有人想使用MyClass，或者想使用mypackage内的其他任何public类，他们必须用import关键字激活mypackage内的名字，使它们能够使用。另一个办法则是指定完整的名称：<br><br>```<br>mypackage.MyClass m = new mypackage.MyClass();<br>```<br><br>import关键字则可将其变得简洁得多：<br><br>```<br>import mypackage.*;<br>// . . .<br>MyClass m = new MyClass();<br>```<br><br>作为一名库设计者，一定要记住package和import关键字允许我们做的事情就是分割单个全局命名空间，保证我们不会遇到名字的冲突——无论有多少人使用因特网，也无论多少人用Java编写自己的类。<br><br>5.1.1 创建独一无二的包名<br><br>大家或许已注意到这样一个事实：由于一个包永远不会真的“封装”到单独一个文件里面，它可由多个.class文件构成，所以局面可能稍微有些混乱。为避免这个问题，最合理的一种做法就是将某个特定包使用的所有.class文件都置入单个目录里。也就是说，我们要利用操作系统的分级文件结构避免出现混乱局面。这正是Java所采取的方法。<br>它同时也解决了另两个问题：创建独一无二的包名以及找出那些可能深藏于目录结构某处的类。正如我们在第2章讲述的那样，为达到这个目的，需要将.class文件的位置路径编码到package的名字里。但根据约定，编译器强迫package名的第一部分是类创建者的因特网域名。由于因特网域名肯定是独一无二的（由InterNIC保证——注释②，它控制着域名的分配），所以假如按这一约定行事，package的名称就肯定不会重复，所以永远不会遇到名称冲突的问题。换句话说，除非将自己的域名转让给其他人，而且对方也按照相同的路径名编写Java代码，否则名字的冲突是永远不会出现的。当然，如果你没有自己的域名，那么必须创造一个非常生僻的包名（例如自己的英文姓名），以便尽最大可能创建一个独一无二的包名。如决定发行自己的Java代码，那么强烈推荐去申请自己的域名，它所需的费用是非常低廉的。<br><br>②：ftp://ftp.internic.net<br><br>这个技巧的另一部分是将package名解析成自己机器上的一个目录。这样一来，Java程序运行并需要装载.class文件的时候（这是动态进行的，在程序需要创建属于那个类的一个对象，或者首次访问那个类的一个static成员时），它就可以找到.class文件驻留的那个目录。<br><br>Java解释器的工作程序如下：首先，它找到环境变量CLASSPATH（将Java或者具有Java解释能力的工具——如浏览器——安装到机器中时，通过操作系统进行设定）。CLASSPATH包含了一个或多个目录，它们作为一种特殊的“根”使用，从这里展开对.class文件的搜索。从那个根开始，解释器会寻找包名，并将每个点号（句点）替换成一个斜杠，从而生成从CLASSPATH根开始的一个路径名（所以package foo.bar.baz会变成foo\bar\baz或者foo/bar/baz；具体是正斜杠还是反斜杠由操作系统决定）。随后将它们连接到一起，成为CLASSPATH内的各个条目（入口）。以后搜索.class文件时，就可从这些地方开始查找与准备创建的类名对应的名字。此外，它也会搜索一些标准目录——这些目录与Java解释器驻留的地方有关。<br><br>为进一步理解这个问题，下面以我自己的域名为例，它是bruceeckel.com。将其反转过来后，com.bruceeckel就为我的类创建了独一无二的全局名称（com，edu，org，net等扩展名以前在Java包中都是大写的，但自Java 1.2以来，这种情况已发生了变化。现在整个包名都是小写的）。由于决定创建一个名为util的库，我可以进一步地分割它，所以最后得到的包名如下：<br><br>```<br>package com.bruceeckel.util;<br>```<br><br>现在，可将这个包名作为下述两个文件的“命名空间”使用：<br><br>```<br>//: Vector.java<br>// Creating a package<br>package com.bruceeckel.util;<br><br>public class Vector {<br>  public Vector() {<br>    System.out.println(<br>      "com.bruceeckel.util.Vector");<br>  }<br>} ///:~<br>```<br><br>创建自己的包时，要求package语句必须是文件中的第一个“非注释”代码。第二个文件表面看起来是类似的：<br><br>```<br>//: List.java<br>// Creating a package <br>package com.bruceeckel.util;<br><br>public class List {<br>  public List() {<br>    System.out.println(<br>      "com.bruceeckel.util.List");<br>  }<br>} ///:~<br>```<br><br>这两个文件都置于我自己系统的一个子目录中：<br><br>```<br>C:\DOC\JavaT\com\bruceeckel\util<br>```<br><br>若通过它往回走，就会发现包名com.bruceeckel.util，但路径的第一部分又是什么呢？这是由CLASSPATH环境变量决定的。在我的机器上，它是：<br><br>```<br>CLASSPATH=.;D:\JAVA\LIB;C:\DOC\JavaT<br>```<br><br>可以看出，CLASSPATH里能包含大量备用的搜索路径。然而，使用JAR文件时要注意一个问题：必须将JAR文件的名字置于类路径里，而不仅仅是它所在的路径。所以对一个名为grape.jar的JAR文件来说，我们的类路径需要包括：<br><br>```<br>CLASSPATH=.;D:\JAVA\LIB;C:\flavors\grape.jar<br>```<br><br>正确设置好类路径后，可将下面这个文件置于任何目录里（若在执行该程序时遇到麻烦，请参见第3章的3.1.2小节“赋值”）：<br><br>```<br>//: LibTest.java<br>// Uses the library<br>package c05;<br>import com.bruceeckel.util.*;<br><br>public class LibTest {<br>  public static void main(String[] args) {<br>    Vector v = new Vector();<br>    List l = new List();<br>  }<br>} ///:~<br>```<br><br>编译器遇到import语句后，它会搜索由CLASSPATH指定的目录，查找子目录com\bruceeckel\util，然后查找名称适当的已编译文件（对于Vector是Vector.class，对于List则是List.class）。注意Vector和List内无论类还是需要的方法都必须设为public。<br><br>1. 自动编译<br><br>为导入的类首次创建一个对象时（或者访问一个类的static成员时），编译器会在适当的目录里寻找同名的.class文件（所以如果创建类X的一个对象，就应该是X.class）。若只发现X.class，它就是必须使用的那一个类。然而，如果它在相同的目录中还发现了一个X.java，编译器就会比较两个文件的日期标记。如果X.java比X.class新，就会自动编译X.java，生成一个最新的X.class。<br>对于一个特定的类，或在与它同名的.java文件中没有找到它，就会对那个类采取上述的处理。<br><br>2. 冲突<br><br>若通过 `*` 导入了两个库，而且它们包括相同的名字，这时会出现什么情况呢？例如，假定一个程序使用了下述导入语句：<br><br>```<br>import com.bruceeckel.util.*;<br>import java.util.*;<br>```<br><br>由于 `java.util.*` 也包含了一个Vector类，所以这会造成潜在的冲突。然而，只要冲突并不真的发生，那么就不会产生任何问题——这当然是最理想的情况，因为否则的话，就需要进行大量编程工作，防范那些可能可能永远也不会发生的冲突。<br><br>如现在试着生成一个Vector，就肯定会发生冲突。如下所示：<br><br>```<br>Vector v = new Vector();<br>```<br><br>它引用的到底是哪个Vector类呢？编译器对这个问题没有答案，读者也不可能知道。所以编译器会报告一个错误，强迫我们进行明确的说明。例如，假设我想使用标准的Java Vector，那么必须象下面这样编程：<br><br>```<br>java.util.Vector v = new java.util.Vector();<br>```<br><br>由于它（与CLASSPATH一起）完整指定了那个Vector的位置，所以不再需要 `import java.util.*` 语句，除非还想使用来自java.util的其他东西。<br><br>5.1.2 自定义工具库<br><br>掌握前述的知识后，接下来就可以开始创建自己的工具库，以便减少或者完全消除重复的代码。例如，可为System.out.println()创建一个别名，减少重复键入的代码量。它可以是名为tools的一个包（package）的一部分：<br><br>```<br>//: P.java<br>// The P.rint & P.rintln shorthand<br>package com.bruceeckel.tools;<br><br>public class P {<br>  public static void rint(Object obj) {<br>    System.out.print(obj);<br>  }<br>  public static void rint(String s) {<br>    System.out.print(s);<br>  }<br>  public static void rint(char[] s) {<br>    System.out.print(s);<br>  }<br>  public static void rint(char c) {<br>    System.out.print(c);<br>  }<br>  public static void rint(int i) {<br>    System.out.print(i);<br>  }<br>  public static void rint(long l) {<br>    System.out.print(l);<br>  }<br>  public static void rint(float f) {<br>    System.out.print(f);<br>  }<br>  public static void rint(double d) {<br>    System.out.print(d);<br>  }<br>  public static void rint(boolean b) {<br>    System.out.print(b);<br>  }<br>  public static void rintln() {<br>    System.out.println();<br>  }<br>  public static void rintln(Object obj) {<br>    System.out.println(obj);<br>  }<br>  public static void rintln(String s) {<br>    System.out.println(s);<br>  }<br>  public static void rintln(char[] s) {<br>    System.out.println(s);<br>  }<br>  public static void rintln(char c) {<br>    System.out.println(c);<br>  }<br>  public static void rintln(int i) {<br>    System.out.println(i);<br>  }<br>  public static void rintln(long l) {<br>    System.out.println(l);<br>  }<br>  public static void rintln(float f) {<br>    System.out.println(f);<br>  }<br>  public static void rintln(double d) {<br>    System.out.println(d);<br>  }<br>  public static void rintln(boolean b) {<br>    System.out.println(b);<br>  }<br>} ///:~<br>```<br><br>所有不同的数据类型现在都可以在一个新行输出（P.rintln()），或者不在一个新行输出（P.rint()）。<br>大家可能会猜想这个文件所在的目录必须从某个CLASSPATH位置开始，然后继续com/bruceeckel/tools。编译完毕后，利用一个import语句，即可在自己系统的任何地方使用P.class文件。如下所示：<br><br>```<br>ToolTest.java <br>```<br><br>所以从现在开始，无论什么时候只要做出了一个有用的新工具，就可将其加入tools目录（或者自己的个人util或tools目录）。<br><br>1. CLASSPATH的陷阱<br><br>P.java文件存在一个非常有趣的陷阱。特别是对于早期的Java实现方案来说，类路径的正确设定通常都是很困难的一项工作。编写这本书的时候，我引入了P.java文件，它最初看起来似乎工作很正常。但在某些情况下，却开始出现中断。在很长的时间里，我都确信这是Java或其他什么在实现时一个错误。但最后，我终于发现在一个地方引入了一个程序（即第17章要说明的CodePackager.java），它使用了一个不同的类P。由于它作为一个工具使用，所以有时候会进入类路径里；另一些时候则不会这样。但只要它进入类路径，那么假若执行的程序需要寻找com.bruceeckel.tools中的类，Java首先发现的就是CodePackager.java中的P。此时，编译器会报告一个特定的方法没有找到。这当然是非常令人头疼的，因为我们在前面的类P里明明看到了这个方法，而且根本没有更多的诊断报告可为我们提供一条线索，让我们知道找到的是一个完全不同的类（那甚至不是public的）。<br><br>乍一看来，这似乎是编译器的一个错误，但假若考察import语句，就会发现它只是说：“在这里可能发现了P”。然而，我们假定的是编译器搜索自己类路径的任何地方，所以一旦它发现一个P，就会使用它；若在搜索过程中发现了“错误的”一个，它就会停止搜索。这与我们在前面表述的稍微有些区别，因为存在一些讨厌的类，它们都位于包内。而这里有一个不在包内的P，但仍可在常规的类路径搜索过程中找到。<br><br>如果您遇到象这样的情况，请务必保证对于类路径的每个地方，每个名字都仅存在一个类。<br><br>5.1.3 利用导入改变行为<br><br>Java已取消的一种特性是C的“条件编译”，它允许我们改变参数，获得不同的行为，同时不改变其他任何代码。Java之所以抛弃了这一特性，可能是由于该特性经常在C里用于解决跨平台问题：代码的不同部分根据具体的平台进行编译，否则不能在特定的平台上运行。由于Java的设计思想是成为一种自动跨平台的语言，所以这种特性是没有必要的。<br><br>然而，条件编译还有另一些非常有价值的用途。一种很常见的用途就是调试代码。调试特性可在开发过程中使用，但在发行的产品中却无此功能。Alen Holub（www.holub.com）提出了利用包（package）来模仿条件编译的概念。根据这一概念，它创建了C“断定机制”一个非常有用的Java版本。之所以叫作“断定机制”，是由于我们可以说“它应该为真”或者“它应该为假”。如果语句不同意你的断定，就可以发现相关的情况。这种工具在调试过程中是特别有用的。<br><br>可用下面这个类进行程序调试：<br><br>```<br>//: Assert.java<br>// Assertion tool for debugging<br>package com.bruceeckel.tools.debug;<br><br>public class Assert {<br>  private static void perr(String msg) {<br>    System.err.println(msg);<br>  }<br>  public final static void is_true(boolean exp) {<br>    if(!exp) perr("Assertion failed");<br>  }<br>  public final static void is_false(boolean exp){<br>    if(exp) perr("Assertion failed");<br>  }<br>  public final static void <br>  is_true(boolean exp, String msg) {<br>    if(!exp) perr("Assertion failed: " + msg);<br>  }<br>  public final static void <br>  is_false(boolean exp, String msg) {<br>    if(exp) perr("Assertion failed: " + msg);<br>  }<br>} ///:~<br>```<br><br>这个类只是简单地封装了布尔测试。如果失败，就显示出出错消息。在第9章，大家还会学习一个更高级的错误控制工具，名为“违例控制”。但在目前这种情况下，perr()方法已经可以很好地工作。<br>如果想使用这个类，可在自己的程序中加入下面这一行：<br><br>```<br>import com.bruceeckel.tools.debug.*;<br>```<br><br>如欲清除断定机制，以便自己能发行最终的代码，我们创建了第二个Assert类，但却是在一个不同的包里：<br><br>```<br>//: Assert.java<br>// Turning off the assertion output <br>// so you can ship the program.<br>package com.bruceeckel.tools;<br><br>public class Assert {<br>  public final static void is_true(boolean exp){}<br>  public final static void is_false(boolean exp){}<br>  public final static void <br>  is_true(boolean exp, String msg) {}<br>  public final static void <br>  is_false(boolean exp, String msg) {}<br>} ///:~<br>```<br><br>现在，假如将前一个import语句变成下面这个样子：<br><br>```<br>import com.bruceeckel.tools.*;<br>```<br><br>程序便不再显示出断言。下面是个例子：<br><br>```<br>//: TestAssert.java<br>// Demonstrating the assertion tool<br>package c05;<br>// Comment the following, and uncomment the<br>// subsequent line to change assertion behavior:<br>import com.bruceeckel.tools.debug.*;<br>// import com.bruceeckel.tools.*;<br><br>public class TestAssert {<br>  public static void main(String[] args) {<br>    Assert.is_true((2 + 2) == 5);<br>    Assert.is_false((1 + 1) == 2);<br>    Assert.is_true((2 + 2) == 5, "2 + 2 == 5");<br>    Assert.is_false((1 + 1) == 2, "1 +1 != 2");<br>  }<br>} ///:~<br>```<br><br>通过改变导入的package，我们可将自己的代码从调试版本变成最终的发行版本。这种技术可应用于任何种类的条件代码。<br><br>5.1.4 包的停用<br><br>大家应注意这样一个问题：每次创建一个包后，都在为包取名时间接地指定了一个目录结构。这个包必须存在（驻留）于由它的名字规定的目录内。而且这个目录必须能从CLASSPATH开始搜索并发现。最开始的时候，package关键字的运用可能会令人迷惑，因为除非坚持遵守根据目录路径指定包名的规则，否则就会在运行期获得大量莫名其妙的消息，指出找不到一个特定的类——即使那个类明明就在相同的目录中。若得到象这样的一条消息，请试着将package语句作为注释标记出去。如果这样做行得通，就可知道问题到底出在哪儿。<br></div></div>
			<nav>
				<ul class="pager">
				<li class='previous'><a href='42.html'>&larr; 第5章 隐藏实施过程</a></li>
			<li class='next'><a href='44.html'>5.2 Java访问指示符&rarr;</a></li>
				</ul>
			</nav>
</div>
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
			<!-- /.row -->
			  <hr>
        <!-- Footer -->
        <footer>
            <div class="row">
                <div class="col-xs-12">
                    <p>Copyright &copy; 小龙软件工作室 2016 粤icp备16103410</p>
                </div>
            </div>
        </footer>

    </div>
    <!-- /.container -->

    <!-- jQuery -->
    <script src="../../js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="../../js/bootstrap.min.js"></script>

</body>

</html>
