<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="content-type" content="text/html;charset=utf-8">
    <meta charset="utf-8">
<meta name="360-site-verification" content="cabcfb5a0f4c0d28d604e8a69e6c0cdb" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="baidu-site-verification" content="HknqsD2zhn" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>java编程思想(thinking in java)-编码助手网</title>
      <meta content="为编码人员提供在线文档、模板等帮助，提升解决问题效率" name="description">
			<meta content="java编程思想(thinking in java) Java, spring, tomcat, servlet, jsp, api doc, bootstrap" name="keywords">
<meta name="sogou_site_verification" content="42nApEZFKO"/>


    <!-- Bootstrap Core CSS -->
    <link href="../../css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="../../css/heroic-features.css" rel="stylesheet">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
		<script>
		var _hmt = _hmt || [];
		(function() {
		  var hm = document.createElement("script");
		  hm.src = "//hm.baidu.com/hm.js?dd1361ca20a10cc161e72d4bc4fef6df";
		  var s = document.getElementsByTagName("script")[0];
		  s.parentNode.insertBefore(hm, s);
		})();
		</script>

</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">编码助手网</a>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav">
                    <li>
                        <a href="/">首页</a>
                    </li>
										<li>
                        <a href="/template.html">模板</a>
                    </li>
										<li>
												<a href="/doc.html">文档</a>
										</li>
                    <li>
                        <a href="/contact.html">联系我们</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Content -->
    <div class="container">

			<div class="row">
					<div class="col-xs-4">
						<h4>java编程思想(thinking in java)</h4>
						<h6>感谢quanke.name提供内容</h6>
<ul><li><a href='./0.html'>Introduction</a></li><li><a href='./1.html'>写在前面的话</a></li><li><a href='./2.html'>引言</a></li><li><a href='./3.html'>第1章 对象入门</a></li><li><ul><li><a href='./4.html'>1.1 抽象的进步</a></li><li><a href='./5.html'>1.2 对象的接口</a></li><li><a href='./6.html'>1.3 实现方案的隐藏</a></li><li><a href='./7.html'>1.4 方案的重复使用</a></li><li><a href='./8.html'>1.5 继承：重新使用接口</a></li><li><a href='./9.html'>1.6 多形对象的互换使用</a></li><li><a href='./10.html'>1.7 对象的创建和存在时间</a></li><li><a href='./11.html'>1.8 违例控制：解决错误</a></li><li><a href='./12.html'>1.9 多线程</a></li><li><a href='./13.html'>1.10 永久性</a></li><li><a href='./14.html'>1.11 Java和因特网</a></li><li><a href='./15.html'>1.12 分析和设计</a></li><li><a href='./16.html'>1.13 Java还是C++</a></li></ul></li><li><a href='./17.html'>第2章 一切都是对象</a></li><li><ul><li><a href='./18.html'>2.1 用句柄操纵对象</a></li><li><a href='./19.html'>2.2 所有对象都必须创建</a></li><li><a href='./20.html'>2.3 绝对不要清除对象</a></li><li><a href='./21.html'>2.4 新建数据类型：类</a></li><li><a href='./22.html'>2.5 方法、自变量和返回值</a></li><li><a href='./23.html'>2.6 构建Java程序</a></li><li><a href='./24.html'>2.7 我们的第一个Java程序</a></li><li><a href='./25.html'>2.8 注释和嵌入文档</a></li><li><a href='./26.html'>2.9 编码样式</a></li><li><a href='./27.html'>2.10 总结</a></li><li><a href='./28.html'>2.11 练习</a></li></ul></li><li><a href='./29.html'>第3章 控制程序流程</a></li><li><ul><li><a href='./30.html'>3.1 使用Java运算符</a></li><li><a href='./31.html'>3.2 执行控制</a></li><li><a href='./32.html'>3.3 总结</a></li><li><a href='./33.html'>3.4 练习</a></li></ul></li><li><a href='./34.html'>第4章 初始化和清除</a></li><li><ul><li><a href='./35.html'>4.1 用构建器自动初始化</a></li><li><a href='./36.html'>4.2 方法过载</a></li><li><a href='./37.html'>4.3 清除：收尾和垃圾收集</a></li><li><a href='./38.html'>4.4 成员初始化</a></li><li><a href='./39.html'>4.5 数组初始化</a></li><li><a href='./40.html'>4.6 总结</a></li><li><a href='./41.html'>4.7 练习</a></li></ul></li><li><a href='./42.html'>第5章 隐藏实施过程</a></li><li><ul><li><a href='./43.html'>5.1 包：库单元</a></li><li><a href='./44.html'>5.2 Java访问指示符</a></li><li><a href='./45.html'>5.3 接口与实现</a></li><li><a href='./46.html'>5.4 类访问</a></li><li><a href='./47.html'>5.5 总结</a></li><li><a href='./48.html'>5.6 练习</a></li></ul></li><li><a href='./49.html'>第6章 类再生</a></li><li><ul><li><a href='./50.html'>6.1 合成的语法</a></li><li><a href='./51.html'>6.2 继承的语法</a></li><li><a href='./52.html'>6.3 合成与继承的结合</a></li><li><a href='./53.html'>6.4 到底选择合成还是继承</a></li><li><a href='./54.html'>6.5 protected</a></li><li><a href='./55.html'>6.6 累积开发</a></li><li><a href='./56.html'>6.7 上溯造型</a></li><li><a href='./57.html'>6.8 final关键字</a></li><li><a href='./58.html'>6.9 初始化和类装载</a></li><li><a href='./59.html'>6.10 总结</a></li><li><a href='./60.html'>6.11 练习</a></li></ul></li><li><a href='./61.html'>第7章 多形性</a></li><li><ul><li><a href='./62.html'>7.1 上溯造型</a></li><li><a href='./63.html'>7.2 深入理解</a></li><li><a href='./64.html'>7.3 覆盖与过载</a></li><li><a href='./65.html'>7.4 抽象类和方法</a></li><li><a href='./66.html'>7.5 接口</a></li><li><a href='./67.html'>7.6 内部类</a></li><li><a href='./68.html'>7.7 构建器和多形性</a></li><li><a href='./69.html'>7.8 通过继承进行设计</a></li><li><a href='./70.html'>7.9 总结</a></li><li><a href='./71.html'>7.10 练习</a></li></ul></li><li><a href='./72.html'>第8章 对象的容纳</a></li><li><ul><li><a href='./73.html'>8.1 数组</a></li><li><a href='./74.html'>8.2 集合</a></li><li><a href='./75.html'>8.3 枚举器（反复器）</a></li><li><a href='./76.html'>8.4 集合的类型</a></li><li><a href='./77.html'>8.5 排序</a></li><li><a href='./78.html'>8.6 通用集合库</a></li><li><a href='./79.html'>8.7 新集合</a></li><li><a href='./80.html'>8.8 总结</a></li><li><a href='./81.html'>8.9 练习</a></li></ul></li><li><a href='./82.html'>第9章 违例差错控制</a></li><li><ul><li><a href='./83.html'>9.1 基本违例</a></li><li><a href='./84.html'>9.2 违例的捕获</a></li><li><a href='./85.html'>9.3 标准Java违例</a></li><li><a href='./86.html'>9.4 创建自己的违例</a></li><li><a href='./87.html'>9.5 违例的限制</a></li><li><a href='./88.html'>9.6 用finally清除</a></li><li><a href='./89.html'>9.7 构建器</a></li><li><a href='./90.html'>9.8 违例匹配</a></li><li><a href='./91.html'>9.9 总结</a></li><li><a href='./92.html'>9.10 练习</a></li></ul></li><li><a href='./93.html'>第10章 Java IO系统</a></li><li><ul><li><a href='./94.html'>10.1 输入和输出</a></li><li><a href='./95.html'>10.2 增添属性和有用的接口</a></li><li><a href='./96.html'>10.3 本身的缺陷：RandomAccessFile</a></li><li><a href='./97.html'>10.4 File类</a></li><li><a href='./98.html'>10.5 IO流的典型应用</a></li><li><a href='./99.html'>10.6 StreamTokenizer</a></li><li><a href='./100.html'>10.7 Java 1.1的IO流</a></li><li><a href='./101.html'>10.8 压缩</a></li><li><a href='./102.html'>10.9 对象序列化</a></li><li><a href='./103.html'>10.10 总结</a></li><li><a href='./104.html'>10.11 练习</a></li></ul></li><li><a href='./105.html'>第11章 运行期类型鉴定</a></li><li><ul><li><a href='./106.html'>11.1 对RTTI的需要</a></li><li><a href='./107.html'>11.2 RTTI语法</a></li><li><a href='./108.html'>11.3 反射：运行期类信息</a></li><li><a href='./109.html'>11.4 总结</a></li><li><a href='./110.html'>11.5 练习</a></li></ul></li><li><a href='./111.html'>第12章 传递和返回对象</a></li><li><ul><li><a href='./112.html'>12.1 传递句柄</a></li><li><a href='./113.html'>12.2 制作本地副本</a></li><li><a href='./114.html'>12.3 克隆的控制</a></li><li><a href='./115.html'>12.4 只读类</a></li><li><a href='./116.html'>12.5 总结</a></li><li><a href='./117.html'>12.6 练习</a></li></ul></li><li><a href='./118.html'>第13章 创建窗口和程序片</a></li><li><a href='./119.html'>第14章 多线程</a></li><li><ul><li><a href='./120.html'>14.1 反应灵敏的用户界面</a></li><li><a href='./121.html'>14.2 共享有限的资源</a></li><li><a href='./122.html'>14.3 堵塞</a></li><li><a href='./123.html'>14.4 优先级</a></li><li><a href='./124.html'>14.5 回顾runnable</a></li><li><a href='./125.html'>14.6 总结</a></li><li><a href='./126.html'>14.7 练习</a></li></ul></li><li><a href='./127.html'>第15章 网络编程</a></li><li><ul><li><a href='./128.html'>15.1 机器的标识</a></li><li><a href='./129.html'>15.2 套接字</a></li><li><a href='./130.html'>15.3 服务多个客户</a></li><li><a href='./131.html'>15.4 数据报</a></li><li><a href='./132.html'>15.5 一个Web应用</a></li><li><a href='./133.html'>15.6 Java与CGI的沟通</a></li><li><a href='./134.html'>15.7 用JDBC连接数据库</a></li><li><a href='./135.html'>15.8 远程方法</a></li><li><a href='./136.html'>15.9 总结</a></li><li><a href='./137.html'>15.10 练习</a></li></ul></li><li><a href='./138.html'>第16章 设计范式</a></li><li><ul><li><a href='./139.html'>16.1 范式的概念</a></li><li><a href='./140.html'>16.2 观察器范式</a></li><li><a href='./141.html'>16.3 模拟垃圾回收站</a></li><li><a href='./142.html'>16.4 改进设计</a></li><li><a href='./143.html'>16.5 抽象的应用</a></li><li><a href='./144.html'>16.6 多重派遣</a></li><li><a href='./145.html'>16.7 访问器范式</a></li><li><a href='./146.html'>16.8 RTTI真的有害吗</a></li><li><a href='./147.html'>16.9 总结</a></li><li><a href='./148.html'>16.10 练习</a></li></ul></li><li><a href='./149.html'>第17章 项目</a></li><li><ul><li><a href='./150.html'>17.1 文字处理</a></li><li><a href='./151.html'>17.2 方法查找工具</a></li><li><a href='./152.html'>17.3 复杂性理论</a></li><li><a href='./153.html'>17.4 总结</a></li><li><a href='./154.html'>17.5 练习</a></li></ul></li><li><a href='./155.html'>附录A 使用非JAVA代码</a></li><li><a href='./156.html'>附录B 对比C++和Java</a></li><li><a href='./157.html'>附录C Java编程规则</a></li><li><a href='./158.html'>附录D 性能</a></li><li><a href='./159.html'>附录E 关于垃圾收集的一些话</a></li><li><a href='./160.html'>附录F 推荐读物</a></li><li></li>
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
<div class="col-xs-8">
	<nav>
		<ul class="pager">
			<li class='previous'><a href='120.html'>&larr; 14.1 反应灵敏的用户界面</a></li>
		<li class='next'><a href='122.html'>14.3 堵塞&rarr;</a></li>
		</ul>
	</nav>
			<div class="row"><div class="col-xs-12"># 14.2 共享有限的资源<br><br><br>可将单线程程序想象成一种孤立的实体，它能遍历我们的问题空间，而且一次只能做一件事情。由于只有一个实体，所以永远不必担心会有两个实体同时试图使用相同的资源，就象两个人同时都想停到一个车位，同时都想通过一扇门，甚至同时发话。<br><br>进入多线程环境后，它们则再也不是孤立的。可能会有两个甚至更多的线程试图同时同一个有限的资源。必须对这种潜在资源冲突进行预防，否则就可能发生两个线程同时访问一个银行帐号，打印到同一台计算机，以及对同一个值进行调整等等。<br><br>14.2.1 资源访问的错误方法<br><br>现在考虑换成另一种方式来使用本章频繁见到的计数器。在下面的例子中，每个线程都包含了两个计数器，它们在run()里增值以及显示。除此以外，我们使用了Watcher类的另一个线程。它的作用是监视计数器，检查它们是否保持相等。这表面是一项无意义的行动，因为如果查看代码，就会发现计数器肯定是相同的。但实际情况却不一定如此。下面是程序的第一个版本：<br><br>```<br>//: Sharing1.java<br>// Problems with resource sharing while threading<br>import java.awt.*;<br>import java.awt.event.*;<br>import java.applet.*;<br><br>class TwoCounter extends Thread {<br>  private boolean started = false;<br>  private TextField <br>    t1 = new TextField(5),<br>    t2 = new TextField(5);<br>  private Label l = <br>    new Label("count1 == count2");<br>  private int count1 = 0, count2 = 0;<br>  // Add the display components as a panel<br>  // to the given container:<br>  public TwoCounter(Container c) {<br>    Panel p = new Panel();<br>    p.add(t1);<br>    p.add(t2);<br>    p.add(l);<br>    c.add(p);<br>  }<br>  public void start() {<br>    if(!started) {<br>      started = true;<br>      super.start();<br>    }<br>  }<br>  public void run() {<br>    while (true) {<br>      t1.setText(Integer.toString(count1++));<br>      t2.setText(Integer.toString(count2++));<br>      try {<br>        sleep(500);<br>      } catch (InterruptedException e){}<br>    }<br>  }<br>  public void synchTest() {<br>    Sharing1.incrementAccess();<br>    if(count1 != count2)<br>      l.setText("Unsynched");<br>  }<br>}<br><br>class Watcher extends Thread {<br>  private Sharing1 p;<br>  public Watcher(Sharing1 p) { <br>    this.p = p;<br>    start();<br>  }<br>  public void run() {<br>    while(true) {<br>      for(int i = 0; i < p.s.length; i++)<br>        p.s[i].synchTest();<br>      try {<br>        sleep(500);<br>      } catch (InterruptedException e){}<br>    }<br>  }<br>}<br><br>public class Sharing1 extends Applet {<br>  TwoCounter[] s;<br>  private static int accessCount = 0;<br>  private static TextField aCount = <br>    new TextField("0", 10);<br>  public static void incrementAccess() {<br>    accessCount++;<br>    aCount.setText(Integer.toString(accessCount));<br>  }<br>  private Button <br>    start = new Button("Start"),<br>    observer = new Button("Observe");<br>  private boolean isApplet = true;<br>  private int numCounters = 0;<br>  private int numObservers = 0;<br>  public void init() {<br>    if(isApplet) {<br>      numCounters = <br>        Integer.parseInt(getParameter("size"));<br>      numObservers = <br>        Integer.parseInt(<br>          getParameter("observers"));<br>    }<br>    s = new TwoCounter[numCounters];<br>    for(int i = 0; i < s.length; i++)<br>      s[i] = new TwoCounter(this);<br>    Panel p = new Panel();<br>    start.addActionListener(new StartL());<br>    p.add(start);<br>    observer.addActionListener(new ObserverL());<br>    p.add(observer);<br>    p.add(new Label("Access Count"));<br>    p.add(aCount);<br>    add(p);<br>  }<br>  class StartL implements ActionListener {<br>    public void actionPerformed(ActionEvent e) {<br>      for(int i = 0; i < s.length; i++)<br>        s[i].start();<br>    }<br>  }<br>  class ObserverL implements ActionListener {<br>    public void actionPerformed(ActionEvent e) {<br>      for(int i = 0; i < numObservers; i++)<br>        new Watcher(Sharing1.this);<br>    }<br>  }<br>  public static void main(String[] args) {<br>    Sharing1 applet = new Sharing1();<br>    // This isn't an applet, so set the flag and<br>    // produce the parameter values from args:<br>    applet.isApplet = false;<br>    applet.numCounters = <br>      (args.length == 0 ? 5 :<br>        Integer.parseInt(args[0]));<br>    applet.numObservers =<br>      (args.length < 2 ? 5 :<br>        Integer.parseInt(args[1]));<br>    Frame aFrame = new Frame("Sharing1");<br>    aFrame.addWindowListener(<br>      new WindowAdapter() {<br>        public void windowClosing(WindowEvent e){<br>          System.exit(0);<br>        }<br>      });<br>    aFrame.add(applet, BorderLayout.CENTER);<br>    aFrame.setSize(350, applet.numCounters *100);<br>    applet.init();<br>    applet.start();<br>    aFrame.setVisible(true);<br>  }<br>} ///:~<br>```<br><br>和往常一样，每个计数器都包含了自己的显示组件：两个文本字段以及一个标签。根据它们的初始值，可知道计数是相同的。这些组件在TwoCounter构建器加入Container。由于这个线程是通过用户的一个“按下按钮”操作启动的，所以start()可能被多次调用。但对一个线程来说，对Thread.start()的多次调用是非法的（会产生违例）。在started标记和过载的start()方法中，大家可看到针对这一情况采取的防范措施。<br><br>在run()中，count1和count2的增值与显示方式表面上似乎能保持它们完全一致。随后会调用sleep()；若没有这个调用，程序便会出错，因为那会造成CPU难于交换任务。<br><br>synchTest()方法采取的似乎是没有意义的行动，它检查count1是否等于count2；如果不等，就把标签设为“Unsynched”（不同步）。但是首先，它调用的是类Sharing1的一个静态成员，以便增值和显示一个访问计数器，指出这种检查已成功进行了多少次（这样做的理由会在本例的其他版本中变得非常明显）。<br><br>Watcher类是一个线程，它的作用是为处于活动状态的所有TwoCounter对象都调用synchTest()。其间，它会对Sharing1对象中容纳的数组进行遍历。可将Watcher想象成它掠过TwoCounter对象的肩膀不断地“偷看”。<br><br>Sharing1包含了TwoCounter对象的一个数组，它通过init()进行初始化，并在我们按下“start”按钮后作为线程启动。以后若按下“Observe”（观察）按钮，就会创建一个或者多个观察器，并对毫不设防的TwoCounter进行调查。<br><br>注意为了让它作为一个程序片在浏览器中运行，Web页需要包含下面这几行：<br><br>```<br><applet code=Sharing1 width=650 height=500><br><param name=size value="20"><br><param name=observers value="1"><br></applet><br>```<br><br>可自行改变宽度、高度以及参数，根据自己的意愿进行试验。若改变了size和observers，程序的行为也会发生变化。我们也注意到，通过从命令行接受参数（或者使用默认值），它被设计成作为一个独立的应用程序运行。<br><br>下面才是最让人“不可思议”的。在TwoCounter.run()中，无限循环只是不断地重复相邻的行：<br><br>```<br>t1.setText(Integer.toString(count1++));<br>t2.setText(Integer.toString(count2++));<br>```<br><br>（和“睡眠”一样，不过在这里并不重要）。但在程序运行的时候，你会发现count1和count2被“观察”（用Watcher观察）的次数是不相等的！这是由线程的本质造成的——它们可在任何时候挂起（暂停）。所以在上述两行的执行时刻之间，有时会出现执行暂停现象。同时，Watcher线程也正好跟随着进来，并正好在这个时候进行比较，造成计数器出现不相等的情况。<br><br>本例揭示了使用线程时一个非常基本的问题。我们跟无从知道一个线程什么时候运行。想象自己坐在一张桌子前面，桌上放有一把叉子，准备叉起自己的最后一块食物。当叉子要碰到食物时，食物却突然消失了（因为这个线程已被挂起，同时另一个线程进来“偷”走了食物）。这便是我们要解决的问题。<br><br>有的时候，我们并不介意一个资源在尝试使用它的时候是否正被访问（食物在另一些盘子里）。但为了让多线程机制能够正常运转，需要采取一些措施来防止两个线程访问相同的资源——至少在关键的时期。<br><br>为防止出现这样的冲突，只需在线程使用一个资源时为其加锁即可。访问资源的第一个线程会其加上锁以后，其他线程便不能再使用那个资源，除非被解锁。如果车子的前座是有限的资源，高喊“这是我的！”的孩子会主张把它锁起来。<br><br>14.2.2 Java如何共享资源<br><br>对一种特殊的资源——对象中的内存——Java提供了内建的机制来防止它们的冲突。由于我们通常将数据元素设为从属于private（私有）类，然后只通过方法访问那些内存，所以只需将一个特定的方法设为synchronized（同步的），便可有效地防止冲突。在任何时刻，只可有一个线程调用特定对象的一个synchronized方法（尽管那个线程可以调用多个对象的同步方法）。下面列出简单的synchronized方法：<br><br><br>```<br>synchronized void f() { /* ... */ }<br>synchronized void g() { /* ... */ }<br>```<br><br>每个对象都包含了一把锁（也叫作“监视器”），它自动成为对象的一部分（不必为此写任何特殊的代码）。调用任何synchronized方法时，对象就会被锁定，不可再调用那个对象的其他任何synchronized方法，除非第一个方法完成了自己的工作，并解除锁定。在上面的例子中，如果为一个对象调用f()，便不能再为同样的对象调用g()，除非f()完成并解除锁定。因此，一个特定对象的所有synchronized方法都共享着一把锁，而且这把锁能防止多个方法对通用内存同时进行写操作（比如同时有多个线程）。<br><br>每个类也有自己的一把锁（作为类的Class对象的一部分），所以synchronized static方法可在一个类的范围内被相互间锁定起来，防止与static数据的接触。<br><br>注意如果想保护其他某些资源不被多个线程同时访问，可以强制通过synchronized方访问那些资源。<br><br>1. 计数器的同步<br><br>装备了这个新关键字后，我们能够采取的方案就更灵活了：可以只为TwoCounter中的方法简单地使用synchronized关键字。下面这个例子是对前例的改版，其中加入了新的关键字：<br><br>```<br>//: Sharing2.java<br>// Using the synchronized keyword to prevent<br>// multiple access to a particular resource.<br>import java.awt.*;<br>import java.awt.event.*;<br>import java.applet.*;<br><br>class TwoCounter2 extends Thread {<br>  private boolean started = false;<br>  private TextField <br>    t1 = new TextField(5),<br>    t2 = new TextField(5);<br>  private Label l = <br>    new Label("count1 == count2");<br>  private int count1 = 0, count2 = 0;<br>  public TwoCounter2(Container c) {<br>    Panel p = new Panel();<br>    p.add(t1);<br>    p.add(t2);<br>    p.add(l);<br>    c.add(p);<br>  }    <br>  public void start() {<br>    if(!started) {<br>      started = true;<br>      super.start();<br>    }<br>  }<br>  public synchronized void run() {<br>    while (true) {<br>      t1.setText(Integer.toString(count1++));<br>      t2.setText(Integer.toString(count2++));<br>      try {<br>        sleep(500);<br>      } catch (InterruptedException e){}<br>    }<br>  }<br>  public synchronized void synchTest() {<br>    Sharing2.incrementAccess();<br>    if(count1 != count2)<br>      l.setText("Unsynched");<br>  }<br>}<br><br>class Watcher2 extends Thread {<br>  private Sharing2 p;<br>  public Watcher2(Sharing2 p) { <br>    this.p = p;<br>    start();<br>  }<br>  public void run() {<br>    while(true) {<br>      for(int i = 0; i < p.s.length; i++)<br>        p.s[i].synchTest();<br>      try {<br>        sleep(500);<br>      } catch (InterruptedException e){}<br>    }<br>  }<br>}<br><br>public class Sharing2 extends Applet {<br>  TwoCounter2[] s;<br>  private static int accessCount = 0;<br>  private static TextField aCount = <br>    new TextField("0", 10);<br>  public static void incrementAccess() {<br>    accessCount++;<br>    aCount.setText(Integer.toString(accessCount));<br>  }<br>  private Button <br>    start = new Button("Start"),<br>    observer = new Button("Observe");<br>  private boolean isApplet = true;<br>  private int numCounters = 0;<br>  private int numObservers = 0;<br>  public void init() {<br>    if(isApplet) {<br>      numCounters = <br>        Integer.parseInt(getParameter("size"));<br>      numObservers = <br>        Integer.parseInt(<br>          getParameter("observers"));<br>    }<br>    s = new TwoCounter2[numCounters];<br>    for(int i = 0; i < s.length; i++)<br>      s[i] = new TwoCounter2(this);<br>    Panel p = new Panel();<br>    start.addActionListener(new StartL());<br>    p.add(start);<br>    observer.addActionListener(new ObserverL());<br>    p.add(observer);<br>    p.add(new Label("Access Count"));<br>    p.add(aCount);<br>    add(p);<br>  }<br>  class StartL implements ActionListener {<br>    public void actionPerformed(ActionEvent e) {<br>      for(int i = 0; i < s.length; i++)<br>        s[i].start();<br>    }<br>  }<br>  class ObserverL implements ActionListener {<br>    public void actionPerformed(ActionEvent e) {<br>      for(int i = 0; i < numObservers; i++)<br>        new Watcher2(Sharing2.this);<br>    }<br>  }<br>  public static void main(String[] args) {<br>    Sharing2 applet = new Sharing2();<br>    // This isn't an applet, so set the flag and<br>    // produce the parameter values from args:<br>    applet.isApplet = false;<br>    applet.numCounters = <br>      (args.length == 0 ? 5 :<br>        Integer.parseInt(args[0]));<br>    applet.numObservers =<br>      (args.length < 2 ? 5 :<br>        Integer.parseInt(args[1]));<br>    Frame aFrame = new Frame("Sharing2");<br>    aFrame.addWindowListener(<br>      new WindowAdapter() {<br>        public void windowClosing(WindowEvent e){<br>          System.exit(0);<br>        }<br>      });<br>    aFrame.add(applet, BorderLayout.CENTER);<br>    aFrame.setSize(350, applet.numCounters *100);<br>    applet.init();<br>    applet.start();<br>    aFrame.setVisible(true);<br>  }<br>} ///:~<br>```<br><br>我们注意到无论run()还是synchTest()都是“同步的”。如果只同步其中的一个方法，那么另一个就可以自由忽视对象的锁定，并可无碍地调用。所以必须记住一个重要的规则：对于访问某个关键共享资源的所有方法，都必须把它们设为synchronized，否则就不能正常地工作。<br><br>现在又遇到了一个新问题。Watcher2永远都不能看到正在进行的事情，因为整个run()方法已设为“同步”。而且由于肯定要为每个对象运行run()，所以锁永远不能打开，而synchTest()永远不会得到调用。之所以能看到这一结果，是因为accessCount根本没有变化。<br><br>为解决这个问题，我们能采取的一个办法是只将run()中的一部分代码隔离出来。想用这个办法隔离出来的那部分代码叫作“关键区域”，而且要用不同的方式来使用synchronized关键字，以设置一个关键区域。Java通过“同步块”提供对关键区域的支持；这一次，我们用synchronized关键字指出对象的锁用于对其中封闭的代码进行同步。如下所示：<br>synchronized(syncObject) {<br>  // This code can be accessed by only<br>  // one thread at a time, assuming all<br>  // threads respect syncObject's lock<br>}<br><br>在能进入同步块之前，必须在synchObject上取得锁。如果已有其他线程取得了这把锁，块便不能进入，必须等候那把锁被释放。<br>可从整个run()中删除synchronized关键字，换成用一个同步块包围两个关键行，从而完成对Sharing2例子的修改。但什么对象应作为锁来使用呢？那个对象已由synchTest()标记出来了——也就是当前对象（this）！所以修改过的run()方法象下面这个样子：<br><br>```<br>  public void run() {<br>    while (true) {<br>      synchronized(this) {<br>        t1.setText(Integer.toString(count1++));<br>        t2.setText(Integer.toString(count2++));<br>      }<br>      try {<br>        sleep(500);<br>      } catch (InterruptedException e){}<br>    }<br>  }<br>```<br><br>这是必须对Sharing2.java作出的唯一修改，我们会看到尽管两个计数器永远不会脱离同步（取决于允许Watcher什么时候检查它们），但在run()执行期间，仍然向Watcher提供了足够的访问权限。<br><br>当然，所有同步都取决于程序员是否勤奋：要访问共享资源的每一部分代码都必须封装到一个适当的同步块里。<br><br>2. 同步的效率<br><br>由于要为同样的数据编写两个方法，所以无论如何都不会给人留下效率很高的印象。看来似乎更好的一种做法是将所有方法都设为自动同步，并完全消除synchronized关键字（当然，含有synchronized run()的例子显示出这样做是很不通的）。但它也揭示出获取一把锁并非一种“廉价”方案——为一次方法调用付出的代价（进入和退出方法，不执行方法主体）至少要累加到四倍，而且根据我们的具体现方案，这一代价还有可能变得更高。所以假如已知一个方法不会造成冲突，最明智的做法便是撤消其中的synchronized关键字。<br><br>14.2.3 回顾Java Beans<br><br>我们现在已理解了同步，接着可换从另一个角度来考察Java Beans。无论什么时候创建了一个Bean，就必须假定它要在一个多线程的环境中运行。这意味着：<br><br>(1) 只要可行，Bean的所有公共方法都应同步。当然，这也带来了“同步”在运行期间的开销。若特别在意这个问题，在关键区域中不会造成问题的方法就可保留为“不同步”，但注意这通常都不是十分容易判断。有资格的方法倾向于规模很小（如下例的getCircleSize()）以及／或者“微小”。也就是说，这个方法调用在如此少的代码片里执行，以至于在执行期间对象不能改变。如果将这种方法设为“不同步”，可能对程序的执行速度不会有明显的影响。可能也将一个Bean的所有public方法都设为synchronized，并只有在保证特别必要、而且会造成一个差异的情况下，才将synchronized关键字删去。<br><br>(2) 如果将一个多造型事件送给一系列对那个事件感兴趣的“听众”，必须假在列表中移动的时候可以添加或者删除。<br><br>第一点很容易处理，但第二点需要考虑更多的东西。让我们以前一章提供的BangBean.java为例。在那个例子中，我们忽略了synchronized关键字（那时还没有引入呢），并将造型设为单造型，从而回避了多线程的问题。在下面这个修改过的版本中，我们使其能在多线程环境中工作，并为事件采用了多造型技术：<br><br>```<br>//: BangBean2.java<br>// You should write your Beans this way so they <br>// can run in a multithreaded environment.<br>import java.awt.*;<br>import java.awt.event.*;<br>import java.util.*;<br>import java.io.*;<br><br>public class BangBean2 extends Canvas <br>    implements Serializable {<br>  private int xm, ym;<br>  private int cSize = 20; // Circle size<br>  private String text = "Bang!";<br>  private int fontSize = 48;<br>  private Color tColor = Color.red;<br>  private Vector actionListeners = new Vector();<br>  public BangBean2() {<br>    addMouseListener(new ML());<br>    addMouseMotionListener(new MM());<br>  }<br>  public synchronized int getCircleSize() { <br>    return cSize; <br>  }<br>  public synchronized void <br>  setCircleSize(int newSize) {<br>    cSize = newSize;<br>  }<br>  public synchronized String getBangText() { <br>    return text; <br>  }<br>  public synchronized void <br>  setBangText(String newText) {<br>    text = newText;<br>  }<br>  public synchronized int getFontSize() { <br>    return fontSize; <br>  }<br>  public synchronized void <br>  setFontSize(int newSize) {<br>    fontSize = newSize;<br>  }<br>  public synchronized Color getTextColor() {<br>    return tColor; <br>  }<br>  public synchronized void <br>  setTextColor(Color newColor) {<br>    tColor = newColor;<br>  }<br>  public void paint(Graphics g) {<br>    g.setColor(Color.black);<br>    g.drawOval(xm - cSize/2, ym - cSize/2, <br>      cSize, cSize);<br>  }<br>  // This is a multicast listener, which is<br>  // more typically used than the unicast<br>  // approach taken in BangBean.java:<br>  public synchronized void addActionListener (<br>      ActionListener l) {<br>    actionListeners.addElement(l);<br>  }<br>  public synchronized void removeActionListener(<br>      ActionListener l) {<br>    actionListeners.removeElement(l);<br>  }<br>  // Notice this isn't synchronized:<br>  public void notifyListeners() {<br>    ActionEvent a =<br>      new ActionEvent(BangBean2.this,<br>        ActionEvent.ACTION_PERFORMED, null);<br>    Vector lv = null;<br>    // Make a copy of the vector in case someone<br>    // adds a listener while we're <br>    // calling listeners:<br>    synchronized(this) {<br>      lv = (Vector)actionListeners.clone();<br>    }<br>    // Call all the listener methods:<br>    for(int i = 0; i < lv.size(); i++) {<br>      ActionListener al = <br>        (ActionListener)lv.elementAt(i);<br>      al.actionPerformed(a);<br>    }<br>  }<br>  class ML extends MouseAdapter {<br>    public void mousePressed(MouseEvent e) {<br>      Graphics g = getGraphics();<br>      g.setColor(tColor);<br>      g.setFont(<br>        new Font(<br>          "TimesRoman", Font.BOLD, fontSize));<br>      int width = <br>        g.getFontMetrics().stringWidth(text);<br>      g.drawString(text, <br>        (getSize().width - width) /2,<br>        getSize().height/2);<br>      g.dispose();<br>      notifyListeners();<br>    }<br>  }<br>  class MM extends MouseMotionAdapter {<br>    public void mouseMoved(MouseEvent e) {<br>      xm = e.getX();<br>      ym = e.getY();<br>      repaint();<br>    }<br>  }<br>  // Testing the BangBean2:<br>  public static void main(String[] args) {<br>    BangBean2 bb = new BangBean2();<br>    bb.addActionListener(new ActionListener() {<br>      public void actionPerformed(ActionEvent e){<br>        System.out.println("ActionEvent" + e);<br>      }<br>    });<br>    bb.addActionListener(new ActionListener() {<br>      public void actionPerformed(ActionEvent e){<br>        System.out.println("BangBean2 action");<br>      }<br>    });<br>    bb.addActionListener(new ActionListener() {<br>      public void actionPerformed(ActionEvent e){<br>        System.out.println("More action");<br>      }<br>    });<br>    Frame aFrame = new Frame("BangBean2 Test");<br>    aFrame.addWindowListener(new WindowAdapter(){<br>      public void windowClosing(WindowEvent e) {<br>        System.exit(0);<br>      }<br>    });<br>    aFrame.add(bb, BorderLayout.CENTER);<br>    aFrame.setSize(300,300);<br>    aFrame.setVisible(true);<br>  }<br>} ///:~<br>```<br><br>很容易就可以为方法添加synchronized。但注意在addActionListener()和removeActionListener()中，现在添加了ActionListener，并从一个Vector中移去，所以能够根据自己愿望使用任意多个。<br><br>我们注意到，notifyListeners()方法并未设为“同步”。可从多个线程中发出对这个方法的调用。另外，在对notifyListeners()调用的中途，也可能发出对addActionListener()和removeActionListener()的调用。这显然会造成问题，因为它否定了Vector actionListeners。为缓解这个问题，我们在一个synchronized从句中“克隆”了Vector，并对克隆进行了否定。这样便可在不影响notifyListeners()的前提下，对Vector进行操纵。<br><br>paint()方法也没有设为“同步”。与单纯地添加自己的方法相比，决定是否对过载的方法进行同步要困难得多。在这个例子中，无论paint()是否“同步”，它似乎都能正常地工作。但必须考虑的问题包括：<br><br>(1) 方法会在对象内部修改“关键”变量的状态吗？为判断一个变量是否“关键”，必须知道它是否会被程序中的其他线程读取或设置（就目前的情况看，读取或设置几乎肯定是通过“同步”方法进行的，所以可以只对它们进行检查）。对paint()的情况来说，不会发生任何修改。<br><br>(2) 方法要以这些“关键”变量的状态为基础吗？如果一个“同步”方法修改了一个变量，而我们的方法要用到这个变量，那么一般都愿意把自己的方法也设为“同步”。基于这一前提，大家可观察到cSize由“同步”方法进行了修改，所以paint()应当是“同步”的。但在这里，我们可以问：“假如cSize在paint()执行期间发生了变化，会发生的最糟糕的事情是什么呢？”如果发现情况不算太坏，而且仅仅是暂时的效果，那么最好保持paint()的“不同步”状态，以避免同步方法调用带来的额外开销。<br><br>(3) 要留意的第三条线索是paint()基础类版本是否“同步”，在这里它不是同步的。这并不是一个非常严格的参数，仅仅是一条“线索”。比如在目前的情况下，通过同步方法（好cSize）改变的一个字段已合成到paint()公式里，而且可能已改变了情况。但请注意，synchronized不能继承——也就是说，假如一个方法在基础类中是“同步”的，那么在衍生类过载版本中，它不会自动进入“同步”状态。<br><br>TestBangBean2中的测试代码已在前一章的基础上进行了修改，已在其中加入了额外的“听众”，从而演示了BangBean2的多造型能力。<br></div></div>
			<nav>
				<ul class="pager">
				<li class='previous'><a href='120.html'>&larr; 14.1 反应灵敏的用户界面</a></li>
			<li class='next'><a href='122.html'>14.3 堵塞&rarr;</a></li>
				</ul>
			</nav>
</div>
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
			<!-- /.row -->
			  <hr>
        <!-- Footer -->
        <footer>
            <div class="row">
                <div class="col-xs-12">
                    <p>Copyright &copy; 小龙软件工作室 2016 粤icp备16103410</p>
                </div>
            </div>
        </footer>

    </div>
    <!-- /.container -->

    <!-- jQuery -->
    <script src="../../js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="../../js/bootstrap.min.js"></script>

</body>

</html>
