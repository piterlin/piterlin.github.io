<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="content-type" content="text/html;charset=utf-8">
    <meta charset="utf-8">
<meta name="360-site-verification" content="cabcfb5a0f4c0d28d604e8a69e6c0cdb" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="baidu-site-verification" content="HknqsD2zhn" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>java编程思想(thinking in java)-编码助手网</title>
      <meta content="为编码人员提供在线文档、模板等帮助，提升解决问题效率" name="description">
			<meta content="java编程思想(thinking in java) Java, spring, tomcat, servlet, jsp, api doc, bootstrap" name="keywords">
<meta name="sogou_site_verification" content="42nApEZFKO"/>


    <!-- Bootstrap Core CSS -->
    <link href="../../css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="../../css/heroic-features.css" rel="stylesheet">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
		<script>
		var _hmt = _hmt || [];
		(function() {
		  var hm = document.createElement("script");
		  hm.src = "//hm.baidu.com/hm.js?dd1361ca20a10cc161e72d4bc4fef6df";
		  var s = document.getElementsByTagName("script")[0];
		  s.parentNode.insertBefore(hm, s);
		})();
		</script>

</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">编码助手网</a>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav">
                    <li>
                        <a href="/">首页</a>
                    </li>
										<li>
                        <a href="/template.html">模板</a>
                    </li>
										<li>
												<a href="/doc.html">文档</a>
										</li>
                    <li>
                        <a href="/contact.html">联系我们</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Content -->
    <div class="container">

			<div class="row">
					<div class="col-xs-4">
						<h4>java编程思想(thinking in java)</h4>
						<h6>感谢http://quanke.name提供内容</h6>
<ul><li><a href='./1479436214592_-168316990.html'>Introduction</a></li><li><a href='./1479436214605_802664538.html'>写在前面的话</a></li><li><a href='./1479436214605_-791815332.html'>引言</a></li><li><a href='./1479436214605_1266451767.html'>第1章 对象入门</a></li><li><ul><li><a href='./1479436214606_-1211955969.html'>1.1 抽象的进步</a></li><li><a href='./1479436214606_-985491570.html'>1.2 对象的接口</a></li><li><a href='./1479436214606_421738363.html'>1.3 实现方案的隐藏</a></li><li><a href='./1479436214607_1726094433.html'>1.4 方案的重复使用</a></li><li><a href='./1479436214607_-1917493719.html'>1.5 继承：重新使用接口</a></li><li><a href='./1479436214607_-994529289.html'>1.6 多形对象的互换使用</a></li><li><a href='./1479436214608_695543294.html'>1.7 对象的创建和存在时间</a></li><li><a href='./1479436214609_186799536.html'>1.8 违例控制：解决错误</a></li><li><a href='./1479436214609_225257298.html'>1.9 多线程</a></li><li><a href='./1479436214610_-1377857368.html'>1.10 永久性</a></li><li><a href='./1479436214610_-1567485742.html'>1.11 Java和因特网</a></li><li><a href='./1479436214610_-534049255.html'>1.12 分析和设计</a></li><li><a href='./1479436214611_-516206529.html'>1.13 Java还是C++</a></li></ul></li><li><a href='./1479436214611_-833808368.html'>第2章 一切都是对象</a></li><li><ul><li><a href='./1479436214611_160489487.html'>2.1 用句柄操纵对象</a></li><li><a href='./1479436214611_-395400265.html'>2.2 所有对象都必须创建</a></li><li><a href='./1479436214612_-105112715.html'>2.3 绝对不要清除对象</a></li><li><a href='./1479436214612_-1081120728.html'>2.4 新建数据类型：类</a></li><li><a href='./1479436214612_437273775.html'>2.5 方法、自变量和返回值</a></li><li><a href='./1479436214612_968479086.html'>2.6 构建Java程序</a></li><li><a href='./1479436214612_-1963386412.html'>2.7 我们的第一个Java程序</a></li><li><a href='./1479436214613_988202688.html'>2.8 注释和嵌入文档</a></li><li><a href='./1479436214613_-642199972.html'>2.9 编码样式</a></li><li><a href='./1479436214613_-1135594618.html'>2.10 总结</a></li><li><a href='./1479436214613_976703976.html'>2.11 练习</a></li></ul></li><li><a href='./1479436214614_1617201657.html'>第3章 控制程序流程</a></li><li><ul><li><a href='./1479436214614_479400700.html'>3.1 使用Java运算符</a></li><li><a href='./1479436214614_-9479532.html'>3.2 执行控制</a></li><li><a href='./1479436214614_198965659.html'>3.3 总结</a></li><li><a href='./1479436214615_-634539581.html'>3.4 练习</a></li></ul></li><li><a href='./1479436214615_-1049694152.html'>第4章 初始化和清除</a></li><li><ul><li><a href='./1479436214615_-614369641.html'>4.1 用构建器自动初始化</a></li><li><a href='./1479436214615_-2107354158.html'>4.2 方法过载</a></li><li><a href='./1479436214616_2106438365.html'>4.3 清除：收尾和垃圾收集</a></li><li><a href='./1479436214616_-1969096840.html'>4.4 成员初始化</a></li><li><a href='./1479436214616_55724218.html'>4.5 数组初始化</a></li><li><a href='./1479436214616_-51810259.html'>4.6 总结</a></li><li><a href='./1479436214616_749059750.html'>4.7 练习</a></li></ul></li><li><a href='./1479436214617_-1201809261.html'>第5章 隐藏实施过程</a></li><li><ul><li><a href='./1479436214617_75246657.html'>5.1 包：库单元</a></li><li><a href='./1479436214617_-738077386.html'>5.2 Java访问指示符</a></li><li><a href='./1479436214617_-131608479.html'>5.3 接口与实现</a></li><li><a href='./1479436214617_-1940689271.html'>5.4 类访问</a></li><li><a href='./1479436214618_1119703547.html'>5.5 总结</a></li><li><a href='./1479436214618_-768700500.html'>5.6 练习</a></li></ul></li><li><a href='./1479436214618_303969565.html'>第6章 类再生</a></li><li><ul><li><a href='./1479436214618_1498787567.html'>6.1 合成的语法</a></li><li><a href='./1479436214618_1797834651.html'>6.2 继承的语法</a></li><li><a href='./1479436214619_128080957.html'>6.3 合成与继承的结合</a></li><li><a href='./1479436214619_-538376950.html'>6.4 到底选择合成还是继承</a></li><li><a href='./1479436214619_754950718.html'>6.5 protected</a></li><li><a href='./1479436214619_68859466.html'>6.6 累积开发</a></li><li><a href='./1479436214620_1707544672.html'>6.7 上溯造型</a></li><li><a href='./1479436214620_-1441830877.html'>6.8 final关键字</a></li><li><a href='./1479436214620_1153478487.html'>6.9 初始化和类装载</a></li><li><a href='./1479436214620_-39288028.html'>6.10 总结</a></li><li><a href='./1479436214620_537511919.html'>6.11 练习</a></li></ul></li><li><a href='./1479436214621_636771584.html'>第7章 多形性</a></li><li><ul><li><a href='./1479436214621_14200843.html'>7.1 上溯造型</a></li><li><a href='./1479436214621_-125275107.html'>7.2 深入理解</a></li><li><a href='./1479436214621_-1006098686.html'>7.3 覆盖与过载</a></li><li><a href='./1479436214622_1469935979.html'>7.4 抽象类和方法</a></li><li><a href='./1479436214622_-321517007.html'>7.5 接口</a></li><li><a href='./1479436214622_-1548998791.html'>7.6 内部类</a></li><li><a href='./1479436214622_-1125287817.html'>7.7 构建器和多形性</a></li><li><a href='./1479436214622_1541346557.html'>7.8 通过继承进行设计</a></li><li><a href='./1479436214623_1527391664.html'>7.9 总结</a></li><li><a href='./1479436214623_-953872192.html'>7.10 练习</a></li></ul></li><li><a href='./1479436214623_-1694327281.html'>第8章 对象的容纳</a></li><li><ul><li><a href='./1479436214623_1677953038.html'>8.1 数组</a></li><li><a href='./1479436214623_157279663.html'>8.2 集合</a></li><li><a href='./1479436214624_2028486897.html'>8.3 枚举器（反复器）</a></li><li><a href='./1479436214624_1552417959.html'>8.4 集合的类型</a></li><li><a href='./1479436214624_-1236839872.html'>8.5 排序</a></li><li><a href='./1479436214624_948884352.html'>8.6 通用集合库</a></li><li><a href='./1479436214624_-29314847.html'>8.7 新集合</a></li><li><a href='./1479436214625_950741899.html'>8.8 总结</a></li><li><a href='./1479436214625_-235386019.html'>8.9 练习</a></li></ul></li><li><a href='./1479436214625_-1144170168.html'>第9章 违例差错控制</a></li><li><ul><li><a href='./1479436214625_1164481198.html'>9.1 基本违例</a></li><li><a href='./1479436214625_639309640.html'>9.2 违例的捕获</a></li><li><a href='./1479436214625_545387660.html'>9.3 标准Java违例</a></li><li><a href='./1479436214625_1703684624.html'>9.4 创建自己的违例</a></li><li><a href='./1479436214626_-1814781625.html'>9.5 违例的限制</a></li><li><a href='./1479436214626_1362968450.html'>9.6 用finally清除</a></li><li><a href='./1479436214626_1696138810.html'>9.7 构建器</a></li><li><a href='./1479436214626_-946669500.html'>9.8 违例匹配</a></li><li><a href='./1479436214626_1369629725.html'>9.9 总结</a></li><li><a href='./1479436214626_1887454245.html'>9.10 练习</a></li></ul></li><li><a href='./1479436214627_-823192075.html'>第10章 Java IO系统</a></li><li><ul><li><a href='./1479436214627_793225325.html'>10.1 输入和输出</a></li><li><a href='./1479436214627_-1441186029.html'>10.2 增添属性和有用的接口</a></li><li><a href='./1479436214627_1039462397.html'>10.3 本身的缺陷：RandomAccessFile</a></li><li><a href='./1479436214627_1841380738.html'>10.4 File类</a></li><li><a href='./1479436214628_2095064408.html'>10.5 IO流的典型应用</a></li><li><a href='./1479436214628_1699205963.html'>10.6 StreamTokenizer</a></li><li><a href='./1479436214628_-1183832916.html'>10.7 Java 1.1的IO流</a></li><li><a href='./1479436214628_1169764652.html'>10.8 压缩</a></li><li><a href='./1479436214628_599949674.html'>10.9 对象序列化</a></li><li><a href='./1479436214629_822501598.html'>10.10 总结</a></li><li><a href='./1479436214629_784582642.html'>10.11 练习</a></li></ul></li><li><a href='./1479436214629_-446109494.html'>第11章 运行期类型鉴定</a></li><li><ul><li><a href='./1479436214629_615980680.html'>11.1 对RTTI的需要</a></li><li><a href='./1479436214629_1591261577.html'>11.2 RTTI语法</a></li><li><a href='./1479436214629_-479724471.html'>11.3 反射：运行期类信息</a></li><li><a href='./1479436214630_1962275414.html'>11.4 总结</a></li><li><a href='./1479436214630_-104101779.html'>11.5 练习</a></li></ul></li><li><a href='./1479436214630_2105662301.html'>第12章 传递和返回对象</a></li><li><ul><li><a href='./1479436214630_-381058478.html'>12.1 传递句柄</a></li><li><a href='./1479436214630_1317862656.html'>12.2 制作本地副本</a></li><li><a href='./1479436214630_66286946.html'>12.3 克隆的控制</a></li><li><a href='./1479436214631_1628962510.html'>12.4 只读类</a></li><li><a href='./1479436214631_178950784.html'>12.5 总结</a></li><li><a href='./1479436214631_204549698.html'>12.6 练习</a></li></ul></li><li><a href='./1479436214631_1667056471.html'>第13章 创建窗口和程序片</a></li><li><a href='./1479436214631_1646591288.html'>第14章 多线程</a></li><li><ul><li><a href='./1479436214631_-2057627207.html'>14.1 反应灵敏的用户界面</a></li><li><a href='./1479436214631_1635675213.html'>14.2 共享有限的资源</a></li><li><a href='./1479436214632_1587335383.html'>14.3 堵塞</a></li><li><a href='./1479436214632_1322789348.html'>14.4 优先级</a></li><li><a href='./1479436214632_1679851836.html'>14.5 回顾runnable</a></li><li><a href='./1479436214632_-914514060.html'>14.6 总结</a></li><li><a href='./1479436214632_1301544438.html'>14.7 练习</a></li></ul></li><li><a href='./1479436214633_1637559906.html'>第15章 网络编程</a></li><li><ul><li><a href='./1479436214633_-2140545630.html'>15.1 机器的标识</a></li><li><a href='./1479436214633_946775708.html'>15.2 套接字</a></li><li><a href='./1479436214634_1854884592.html'>15.3 服务多个客户</a></li><li><a href='./1479436214634_1410414288.html'>15.4 数据报</a></li><li><a href='./1479436214634_224372951.html'>15.5 一个Web应用</a></li><li><a href='./1479436214634_-1622230225.html'>15.6 Java与CGI的沟通</a></li><li><a href='./1479436214634_-903287570.html'>15.7 用JDBC连接数据库</a></li><li><a href='./1479436214634_-416599191.html'>15.8 远程方法</a></li><li><a href='./1479436214635_-917204139.html'>15.9 总结</a></li><li><a href='./1479436214635_-540223303.html'>15.10 练习</a></li></ul></li><li><a href='./1479436214635_339847129.html'>第16章 设计范式</a></li><li><ul><li><a href='./1479436214635_1826776975.html'>16.1 范式的概念</a></li><li><a href='./1479436214635_1309397010.html'>16.2 观察器范式</a></li><li><a href='./1479436214636_132034955.html'>16.3 模拟垃圾回收站</a></li><li><a href='./1479436214636_1756675694.html'>16.4 改进设计</a></li><li><a href='./1479436214636_-1966590010.html'>16.5 抽象的应用</a></li><li><a href='./1479436214636_-1831214784.html'>16.6 多重派遣</a></li><li><a href='./1479436214636_1935634882.html'>16.7 访问器范式</a></li><li><a href='./1479436214636_1843093443.html'>16.8 RTTI真的有害吗</a></li><li><a href='./1479436214636_-1838860121.html'>16.9 总结</a></li><li><a href='./1479436214637_-1901505940.html'>16.10 练习</a></li></ul></li><li><a href='./1479436214637_-387290815.html'>第17章 项目</a></li><li><ul><li><a href='./1479436214637_-498587551.html'>17.1 文字处理</a></li><li><a href='./1479436214637_1300299412.html'>17.2 方法查找工具</a></li><li><a href='./1479436214637_1681291541.html'>17.3 复杂性理论</a></li><li><a href='./1479436214637_-1113877505.html'>17.4 总结</a></li><li><a href='./1479436214638_-1637352061.html'>17.5 练习</a></li></ul></li><li><a href='./1479436214638_931172498.html'>附录A 使用非JAVA代码</a></li><li><a href='./1479436214638_882880730.html'>附录B 对比C++和Java</a></li><li><a href='./1479436214638_-283304223.html'>附录C Java编程规则</a></li><li><a href='./1479436214638_-1842547113.html'>附录D 性能</a></li><li><a href='./1479436214638_749950023.html'>附录E 关于垃圾收集的一些话</a></li><li><a href='./1479436214639_2079199942.html'>附录F 推荐读物</a></li><li></li>
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
					<div class="col-xs-8">
# 15.7 用JDBC连接数据库<br><br><br>据估算，将近一半的软件开发都要涉及客户（机）／服务器方面的操作。Java为自己保证的一项出色能力就是构建与平台无关的客户机／服务器数据库应用。在Java 1.1中，这一保证通过Java数据库连接（JDBC）实现了。<br><br>数据库最主要的一个问题就是各家公司之间的规格大战。确实存在一种“标准”数据库语言，即“结构查询语言”（SQL-92），但通常都必须确切知道自己要和哪家数据库公司打交道，否则极易出问题，尽管存在所谓的“标准”。JDBC是面向“与平台无关”设计的，所以在编程的时候不必关心自己要使用的是什么数据库产品。然而，从JDBC里仍有可能发出对某些数据库公司专用功能的调用，所以仍然不可任性妄为。<br><br>和Java中的许多API一样，JDBC也做到了尽量的简化。我们发出的方法调用对应于从数据库收集数据时想当然的做法：同数据库连接，创建一个语句并执行查询，然后处理结果集。<br><br>为实现这一“与平台无关”的特点，JDBC为我们提供了一个“驱动程序管理器”，它能动态维护数据库查询所需的所有驱动程序对象。所以假如要连接由三家公司开发的不同种类的数据库，就需要三个单独的驱动程序对象。驱动程序对象会在装载时由“驱动程序管理器”自动注册，并可用Class.forName()强行装载。<br><br>为打开一个数据库，必须创建一个“数据库URL”，它要指定下述三方面的内容：<br><br>(1) 用“jdbc”指出要使用JDBC。<br><br>(2) “子协议”：驱动程序的名字或者一种数据库连接机制的名称。由于JDBC的设计从ODBC吸收了许多灵感，所以可以选用的第一种子协议就是“jdbc-odbc桥”，它用“odbc”关键字即可指定。<br><br>(3) 数据库标识符：随使用的数据库驱动程序的不同而变化，但一般都提供了一个比较符合逻辑的名称，由数据库管理软件映射（对应）到保存了数据表的一个物理目录。为使自己的数据库标识符具有任何含义，必须用自己的数据库管理软件为自己喜欢的名字注册（注册的具体过程又随运行平台的不同而变化）。<br><br>所有这些信息都统一编译到一个字串里，即“数据库URL”。举个例子来说，若想通过ODBC子协议同一个标识为“people”的数据库连接，相应的数据库URL可设为：<br><br>```<br>String dbUrl = "jdbc:odbc:people"<br>```<br><br>如果通过一个网络连接，数据库URL也需要包含对远程机器进行标识的信息。<br><br>准备好同数据库连接后，可调用静态方法DriverManager.getConnection()，将数据库的URL以及进入那个数据库所需的用户名密码传递给它。得到的返回结果是一个Connection对象，利用它即可查询和操纵数据库。<br><br>下面这个例子将打开一个联络信息数据库，并根据命令行提供的参数查询一个人的姓（Last Name）。它只选择那些有E-mail地址的人的名字，然后列印出符合查询条件的所有人：<br><br>```<br>//: Lookup.java<br>// Looks up email addresses in a <br>// local database using JDBC<br>import java.sql.*;<br><br>public class Lookup {<br>  public static void main(String[] args) {<br>    String dbUrl = "jdbc:odbc:people";<br>    String user = "";<br>    String password = "";<br>    try {<br>      // Load the driver (registers itself)<br>      Class.forName(<br>        "sun.jdbc.odbc.JdbcOdbcDriver");<br>      Connection c = DriverManager.getConnection(<br>        dbUrl, user, password);<br>      Statement s = c.createStatement();<br>      // SQL code:<br>      ResultSet r = <br>        s.executeQuery(<br>          "SELECT FIRST, LAST, EMAIL " +<br>          "FROM people.csv people " +<br>          "WHERE " +<br>          "(LAST='" + args[0] + "') " +<br>          " AND (EMAIL Is Not Null) " +<br>          "ORDER BY FIRST");<br>      while(r.next()) {<br>        // Capitalization doesn't matter:<br>        System.out.println(<br>          r.getString("Last") + ", " <br>          + r.getString("fIRST")<br>          + ": " + r.getString("EMAIL") );<br>      }<br>      s.close(); // Also closes ResultSet<br>    } catch(Exception e) {<br>      e.printStackTrace();<br>    }<br>  }<br>} ///:~<br>```<br><br>可以看到，数据库URL的创建过程与我们前面讲述的完全一样。在该例中，数据库未设密码保护，所以用户名和密码都是空串。<br>用DriverManager.getConnection()建好连接后，接下来可根据结果Connection对象创建一个Statement（语句）对象，这是用createStatement()方法实现的。根据结果Statement，我们可调用executeQuery()，向其传递包含了SQL-92标准SQL语句的一个字串（不久就会看到如何自动创建这类语句，所以没必要在这里知道关于SQL更多的东西）。<br><br>executeQuery()方法会返回一个ResultSet（结果集）对象，它与继承器非常相似：next()方法将继承器移至语句中的下一条记录；如果已抵达结果集的末尾，则返回null。我们肯定能从executeQuery()返回一个ResultSet对象，即使查询结果是个空集（也就是说，不会产生一个违例）。注意在试图读取任何记录数据之前，都必须调用一次next()。若结果集为空，那么对next()的这个首次调用就会返回false。对于结果集中的每条记录，都可将字段名作为字串使用（当然还有其他方法），从而选择不同的字段。另外要注意的是字段名的大小写是无关紧要的——SQL数据库不在乎这个问题。为决定返回的类型，可调用getString()，getFloat()等等。到这个时候，我们已经用Java的原始格式得到了自己的数据库数据，接下去可用Java代码做自己想做的任何事情了。<br><br>15.7.1 让示例运行起来<br><br>就JDBC来说，代码本身是很容易理解的。最令人迷惑的部分是如何使它在自己特定的系统上运行起来。之所以会感到迷惑，是由于它要求我们掌握如何才能使JDBC驱动程序正确装载，以及如何用我们的数据库管理软件来设置一个数据库。<br>当然，具体的操作过程在不同的机器上也会有所区别。但这儿提供的在32位Windows环境下操作过程可有效帮助大家理解在其他平台上的操作。<br><br>1. 步骤1：寻找JDBC驱动程序<br><br>上述程序包含了下面这条语句：<br><br>```<br>Class.forName("sun.jdbc.odbc.JdbcOdbcDriver");<br>```<br><br>这似乎暗示着一个目录结构，但大家不要被它蒙骗了。在我手上这个JDK 1.1安装版本中，根本不存在叫作JdbcOdbcDriver.class的一个文件。所以假如在看了这个例子后去寻找它，那么必然会徒劳而返。另一些人提供的例子使用的是一个假名字，如“myDriver.ClassName”，但人们从字面上得不到任何帮助。事实上，上述用于装载jdbc-odbc驱动程序（实际是与JDK 1.1配套提供的唯一驱动）的语句在联机文档的多处地方均有出现（特别是在一个标记为“JDBC-ODBC Bridge Driver”的页内）。若上面的装载语句不能工作，那么它的名字可能已随着Java新版本的发布而改变了；此时应到联机文档里寻找新的表述方式。<br><br>若装载语句出错，会在这个时候得到一个违例。为了检验驱动程序装载语句是不是能正常工作，请将该语句后面直到catch从句之间的代码暂时设为注释。如果程序运行时未出现违例，表明驱动程序的装载是正确的。<br><br>2. 步骤2：配置数据库<br><br>同样地，我们只限于在32位Windows环境中工作；您可能需要研究一下自己的操作系统，找出适合自己平台的配置方法。<br><br>首先打开控制面板。其中可能有两个图标都含有“ODBC”字样，必须选择那个“32位ODBC”，因为另一个是为了保持与16位软件的向后兼容而设置的，和JDBC混用没有任何结果。双击“32位ODBC”图标后，看到的应该是一个卡片式对话框，上面一排有多个卡片标签，其中包括“用户DSN”、“系统DSN”、“文件DSN”等等。其中，“DSN”代表“数据源名称”（Data Source Name）。它们都与JDBC-ODBC桥有关，但设置数据库时唯一重要的地方“系统DSN”。尽管如此，由于需要测试自己的配置以及创建查询，所以也需要在“文件DSN”中设置自己的数据库。这样便可让Microsoft Query工具（与Microsoft Office配套提供）正确地找到数据库。注意一些软件公司也设计了自己的查询工具。<br><br>最有趣的数据库是我们已经使用过的一个。标准ODBC支持多种文件格式，其中包括由不同公司专用的一些格式，如dBASE。然而，它也包括了简单的“逗号分隔ASCII”格式，它几乎是每种数据工具都能够生成的。就目前的例子来说，我只选择自己的“people”数据库。这是我多年来一直在维护的一个数据库，中间使用了各种联络管理工具。我把它导出成为一个逗号分隔的ASCII文件（一般有个.csv扩展名，用Outlook Express导出通信簿时亦可选用同样的文件格式）。在“文件DSN”区域，我按下“添加”按钮，选择用于控制逗号分隔ASCII文件的文本驱动程序（Microsoft Text Driver），然后撤消对“使用当前目录”的选择，以便导出数据文件时可以自行指定目录。<br><br>大家会注意到在进行这些工作的时候，并没有实际指定一个文件，只是一个目录。那是因为数据库通常是由某个目录下的一系列文件构成的（尽管也可能采用其他形式）。每个文件一般都包含了单个“数据表”，而且SQL语句可以产生从数据库中多个表摘取出来的结果（这叫作“联合”，或者join）只包含了单张表的数据库（就象目前这个）通常叫作“平面文件数据库”。对于大多数问题，如果已经超过了简单的数据存储与获取力所能及的范围，那么必须使用多个数据表。通过“联合”，从而获得希望的结果。我们把这些叫作“关系型”数据库。<br><br>3. 步骤3：测试配置<br><br>为了对配置进行测试，需用一种方式核实数据库是否可由查询它的一个程序“见到”。当然，可以简单地运行上述的JDBC示范程序，并加入下述语句：<br><br>```<br>Connection c = DriverManager.getConnection(<br>dbUrl, user, password);<br>```<br><br>若掷出一个违例，表明你的配置有误。<br><br>然而，此时很有必要使用一个自动化的查询生成工具。我使用的是与Microsoft Office配套提供的Microsoft Query，但你完全可以自行选择一个。查询工具必须知道数据库在什么地方，而Microsoft Query要求我进入ODBC Administrator的“文件DSN”卡片，并在那里新添一个条目。同样指定文本驱动程序以及保存数据库的目录。虽然可将这个条目命名为自己喜欢的任何东西，但最好还是使用与“系统DSN”中相同的名字。<br><br>做完这些工作后，再用查询工具创建一个新查询时，便会发现自己的数据库可以使用了。<br><br>4. 步骤4：建立自己的SQL查询<br><br>我用Microsoft Query创建的查询不仅指出目标数据库存在且次序良好，也会自动生成SQL代码，以便将其插入我自己的Java程序。我希望这个查询能够检查记录中是否存在与启动Java程序时在命令行键入的相同的“姓”（Last Name）。所以作为一个起点，我搜索自己的姓“Eckel”。另外，我希望只显示出有对应E-mail地址的那些名字。创建这个查询的步骤如下：<br><br>(1) 启动一个新查询，并使用查询向导（Query Wizard）。选择“people”数据库（等价于用适应的数据库URL打开数据库连接）。<br><br>(2) 选择数据库中的“people”表。从这张数据表中，选择FIRST，LAST和EMAIL列。<br><br>(3) 在“Filter Data”（过滤器数据库）下，选择LAST，并选择“equals”（等于），加上参数Eckel。点选“And”单选钮。<br><br>(4) 选择EMAIL，并选中“Is not Null”（不为空）。<br><br>(5) 在“Sort By”下，选择FIRST。<br><br>查询结果会向我们展示出是否能得到自己希望的东西。<br>现在可以按下SQL按钮。不需要我们任何方面的介入，正确的SQL代码会立即弹现出来，以便我们粘贴和复制。对于这个查询，相应的SQL代码如下：<br><br>```<br>SELECT people.FIRST, people.LAST, people.EMAIL<br>FROM people.csv people<br>WHERE (people.LAST='Eckel') AND <br>(people.EMAIL Is Not Null)<br>ORDER BY people.FIRST<br>```<br><br>若查询比较复杂，手工编码极易出错。但利用一个查询工具，就可以交互式地测试自己的查询，并自动获得正确的代码。事实上，亲手为这些事情编码是难以让人接受的。<br><br>5. 步骤5：在自己的查询中修改和粘贴<br><br>我们注意到上述代码与程序中使用的代码是有所区别的。那是由于查询工具对所有名字都进行了限定，即便涉及的仅有一个数据表（若真的涉及多个数据表，这种限定可避免来自不同表的同名数据列发生冲突）。由于这个查询只需要用到一个数据表，所以可考虑从大多数名字中删除“people”限定符，就象下面这样：<br><br>```<br>SELECT FIRST, LAST, EMAIL<br>FROM people.csv people<br>WHERE (LAST='Eckel') AND <br>(EMAIL Is Not Null)<br>ORDER BY FIRST<br>```<br><br>此外，我们不希望“硬编码”这个程序，从而只能查找一个特定的名字。相反，它应该能查找我们在命令行动态提供的一个名字。所以还要进行必要的修改，并将SQL语句转换成一个动态生成的字串。如下所示：<br><br>```<br>"SELECT FIRST, LAST, EMAIL " +<br>"FROM people.csv people " +<br>"WHERE " +<br>"(LAST='" + args[0] + "') " +<br>" AND (EMAIL Is Not Null) " +<br>"ORDER BY FIRST");<br>```<br><br>SQL还有一种方式可将名字插入一个查询，名为“程序”（Procedures），它的速度非常快。但对于我们的大多数实验性数据库操作，以及一些初级应用，用Java构建查询字串已经很不错了。<br><br>从这个例子可以看出，利用目前找得到的工具——特别是查询构建工具——涉及SQL及JDBC的数据库编程是非常简单和直观的。<br><br>15.7.2 查找程序的GUI版本<br><br>最好的方法是让查找程序一直保持运行，要查找什么东西时只需简单地切换到它，并键入要查找的名字即可。下面这个程序将查找程序作为一个“application/applet”创建，且添加了名字自动填写功能，所以不必键入完整的姓，即可看到数据：<br><br>```<br>//: VLookup.java<br>// GUI version of Lookup.java<br>import java.awt.*;<br>import java.awt.event.*;<br>import java.applet.*;<br>import java.sql.*;<br><br>public class VLookup extends Applet {<br>  String dbUrl = "jdbc:odbc:people";<br>  String user = "";<br>  String password = "";<br>  Statement s;<br>  TextField searchFor = new TextField(20);<br>  Label completion = <br>    new Label("                        ");<br>  TextArea results = new TextArea(40, 20);<br>  public void init() {<br>    searchFor.addTextListener(new SearchForL());<br>    Panel p = new Panel();<br>    p.add(new Label("Last name to search for:"));<br>    p.add(searchFor);<br>    p.add(completion);<br>    setLayout(new BorderLayout());<br>    add(p, BorderLayout.NORTH);<br>    add(results, BorderLayout.CENTER);<br>    try {<br>      // Load the driver (registers itself)<br>      Class.forName(<br>        "sun.jdbc.odbc.JdbcOdbcDriver");<br>      Connection c = DriverManager.getConnection(<br>        dbUrl, user, password);<br>      s = c.createStatement();<br>    } catch(Exception e) {<br>      results.setText(e.getMessage());<br>    }<br>  }<br>  class SearchForL implements TextListener {<br>    public void textValueChanged(TextEvent te) {<br>      ResultSet r;<br>      if(searchFor.getText().length() == 0) {<br>        completion.setText("");<br>        results.setText("");<br>        return;<br>      }<br>      try {<br>        // Name completion:<br>        r = s.executeQuery(<br>          "SELECT LAST FROM people.csv people " +<br>          "WHERE (LAST Like '" +<br>          searchFor.getText()  + <br>          "%') ORDER BY LAST");<br>        if(r.next()) <br>          completion.setText(<br>            r.getString("last"));<br>        r = s.executeQuery(<br>          "SELECT FIRST, LAST, EMAIL " +<br>          "FROM people.csv people " +<br>          "WHERE (LAST='" + <br>          completion.getText() +<br>          "') AND (EMAIL Is Not Null) " +<br>          "ORDER BY FIRST");<br>      } catch(Exception e) {<br>        results.setText(<br>          searchFor.getText() + "\n");<br>        results.append(e.getMessage());<br>        return; <br>      }<br>      results.setText("");<br>      try {<br>        while(r.next()) {<br>          results.append(<br>            r.getString("Last") + ", " <br>            + r.getString("fIRST") + <br>            ": " + r.getString("EMAIL") + "\n");<br>        }<br>      } catch(Exception e) {<br>        results.setText(e.getMessage());<br>      }<br>    }<br>  }<br>  public static void main(String[] args) {<br>    VLookup applet = new VLookup();<br>    Frame aFrame = new Frame("Email lookup");<br>    aFrame.addWindowListener(<br>      new WindowAdapter() {<br>        public void windowClosing(WindowEvent e) {<br>          System.exit(0);<br>        }<br>      });<br>    aFrame.add(applet, BorderLayout.CENTER);<br>    aFrame.setSize(500,200);<br>    applet.init();<br>    applet.start();<br>    aFrame.setVisible(true);<br>  }<br>} ///:~<br>```<br><br>数据库的许多逻辑都是相同的，但大家可看到这里添加了一个TextListener，用于监视在TextField（文本字段）的输入。所以只要键入一个新字符，它首先就会试着查找数据库中的“姓”，并显示出与当前输入相符的第一条记录（将其置入completion Label，并用它作为要查找的文本）。因此，只要我们键入了足够的字符，使程序能找到与之相符的唯一一条记录，就可以停手了。<br><br>15.7.3 JDBC API为何如何复杂<br><br>阅览JDBC的联机帮助文档时，我们往往会产生畏难情绪。特别是DatabaseMetaData接口——与Java中看到的大多数接口相反，它的体积显得非常庞大——存在着数量众多的方法，比如dataDefinitionCausesTransactionCommit()，getMaxColumnNameLength()，getMaxStatementLength()，storesMixedCaseQuotedIdentifiers()，supportsANSI92IntermediateSQL()，supportsLimitedOuterJoins()等等。它们有这儿有什么意义吗？<br><br>正如早先指出的那样，数据库起初一直处于一种混乱状态。这主要是由于各种数据库应用提出的要求造成的，所以数据库工具显得非常“强大”——换言之，“庞大”。只是近几年才涌现出了SQL的通用语言（常用的还有其他许多数据库语言）。但即便象SQL这样的“标准”，也存在无数的变种，所以JDBC必须提供一个巨大的DatabaseMetaData接口，使我们的代码能真正利用当前要连接的一种“标准”SQL数据库的能力。简言之，我们可编写出简单的、能移植的SQL。但如果想优化代码的执行速度，那么为了适应不同数据库类型的特点，我们的编写代码的麻烦就大了。<br><br>当然，这并不是Java的缺陷。数据库产品之间的差异是我们和JDBC都要面对的一个现实。但是，如果能编写通用的查询，而不必太关心性能，那么事情就要简单得多。即使必须对性能作一番调整，只要知道最终面向的平台，也不必针对每一种情况都编写不同的优化代码。<br><br>在Sun发布的Java 1.1产品中，配套提供了一系列电子文档，其中有对JDBC更全面的介绍。此外，在由Hamilton Cattel和Fisher编著、Addison-Wesley于1997年出版的《JDBC Database Access with Java》中，也提供了有关这一主题的许多有用资料。同时，书店里也经常出现一些有关JDBC的新书。<br>
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
			</div>
			<!-- /.row -->
			  <hr>
        <!-- Footer -->
        <footer>
            <div class="row">
                <div class="col-lg-12">
                    <p>Copyright &copy; 小龙软件工作室 2016</p>
                </div>
            </div>
        </footer>

    </div>
    <!-- /.container -->

    <!-- jQuery -->
    <script src="../../js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="../../js/bootstrap.min.js"></script>

</body>

</html>
