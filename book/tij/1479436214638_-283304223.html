<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="content-type" content="text/html;charset=utf-8">
    <meta charset="utf-8">
<meta name="360-site-verification" content="cabcfb5a0f4c0d28d604e8a69e6c0cdb" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="baidu-site-verification" content="HknqsD2zhn" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>java编程思想(thinking in java)-编码助手网</title>
      <meta content="为编码人员提供在线文档、模板等帮助，提升解决问题效率" name="description">
			<meta content="java编程思想(thinking in java) Java, spring, tomcat, servlet, jsp, api doc, bootstrap" name="keywords">
<meta name="sogou_site_verification" content="42nApEZFKO"/>


    <!-- Bootstrap Core CSS -->
    <link href="../../css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="../../css/heroic-features.css" rel="stylesheet">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
		<script>
		var _hmt = _hmt || [];
		(function() {
		  var hm = document.createElement("script");
		  hm.src = "//hm.baidu.com/hm.js?dd1361ca20a10cc161e72d4bc4fef6df";
		  var s = document.getElementsByTagName("script")[0];
		  s.parentNode.insertBefore(hm, s);
		})();
		</script>

</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">编码助手网</a>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav">
                    <li>
                        <a href="/">首页</a>
                    </li>
										<li>
                        <a href="/template.html">模板</a>
                    </li>
										<li>
												<a href="/doc.html">文档</a>
										</li>
                    <li>
                        <a href="/contact.html">联系我们</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Content -->
    <div class="container">

			<div class="row">
					<div class="col-xs-4">
						<h4>java编程思想(thinking in java)</h4>
						<h6>感谢http://quanke.name提供内容</h6>
<ul><li><a href='./1479436214592_-168316990.html'>Introduction</a></li><li><a href='./1479436214605_802664538.html'>写在前面的话</a></li><li><a href='./1479436214605_-791815332.html'>引言</a></li><li><a href='./1479436214605_1266451767.html'>第1章 对象入门</a></li><li><ul><li><a href='./1479436214606_-1211955969.html'>1.1 抽象的进步</a></li><li><a href='./1479436214606_-985491570.html'>1.2 对象的接口</a></li><li><a href='./1479436214606_421738363.html'>1.3 实现方案的隐藏</a></li><li><a href='./1479436214607_1726094433.html'>1.4 方案的重复使用</a></li><li><a href='./1479436214607_-1917493719.html'>1.5 继承：重新使用接口</a></li><li><a href='./1479436214607_-994529289.html'>1.6 多形对象的互换使用</a></li><li><a href='./1479436214608_695543294.html'>1.7 对象的创建和存在时间</a></li><li><a href='./1479436214609_186799536.html'>1.8 违例控制：解决错误</a></li><li><a href='./1479436214609_225257298.html'>1.9 多线程</a></li><li><a href='./1479436214610_-1377857368.html'>1.10 永久性</a></li><li><a href='./1479436214610_-1567485742.html'>1.11 Java和因特网</a></li><li><a href='./1479436214610_-534049255.html'>1.12 分析和设计</a></li><li><a href='./1479436214611_-516206529.html'>1.13 Java还是C++</a></li></ul></li><li><a href='./1479436214611_-833808368.html'>第2章 一切都是对象</a></li><li><ul><li><a href='./1479436214611_160489487.html'>2.1 用句柄操纵对象</a></li><li><a href='./1479436214611_-395400265.html'>2.2 所有对象都必须创建</a></li><li><a href='./1479436214612_-105112715.html'>2.3 绝对不要清除对象</a></li><li><a href='./1479436214612_-1081120728.html'>2.4 新建数据类型：类</a></li><li><a href='./1479436214612_437273775.html'>2.5 方法、自变量和返回值</a></li><li><a href='./1479436214612_968479086.html'>2.6 构建Java程序</a></li><li><a href='./1479436214612_-1963386412.html'>2.7 我们的第一个Java程序</a></li><li><a href='./1479436214613_988202688.html'>2.8 注释和嵌入文档</a></li><li><a href='./1479436214613_-642199972.html'>2.9 编码样式</a></li><li><a href='./1479436214613_-1135594618.html'>2.10 总结</a></li><li><a href='./1479436214613_976703976.html'>2.11 练习</a></li></ul></li><li><a href='./1479436214614_1617201657.html'>第3章 控制程序流程</a></li><li><ul><li><a href='./1479436214614_479400700.html'>3.1 使用Java运算符</a></li><li><a href='./1479436214614_-9479532.html'>3.2 执行控制</a></li><li><a href='./1479436214614_198965659.html'>3.3 总结</a></li><li><a href='./1479436214615_-634539581.html'>3.4 练习</a></li></ul></li><li><a href='./1479436214615_-1049694152.html'>第4章 初始化和清除</a></li><li><ul><li><a href='./1479436214615_-614369641.html'>4.1 用构建器自动初始化</a></li><li><a href='./1479436214615_-2107354158.html'>4.2 方法过载</a></li><li><a href='./1479436214616_2106438365.html'>4.3 清除：收尾和垃圾收集</a></li><li><a href='./1479436214616_-1969096840.html'>4.4 成员初始化</a></li><li><a href='./1479436214616_55724218.html'>4.5 数组初始化</a></li><li><a href='./1479436214616_-51810259.html'>4.6 总结</a></li><li><a href='./1479436214616_749059750.html'>4.7 练习</a></li></ul></li><li><a href='./1479436214617_-1201809261.html'>第5章 隐藏实施过程</a></li><li><ul><li><a href='./1479436214617_75246657.html'>5.1 包：库单元</a></li><li><a href='./1479436214617_-738077386.html'>5.2 Java访问指示符</a></li><li><a href='./1479436214617_-131608479.html'>5.3 接口与实现</a></li><li><a href='./1479436214617_-1940689271.html'>5.4 类访问</a></li><li><a href='./1479436214618_1119703547.html'>5.5 总结</a></li><li><a href='./1479436214618_-768700500.html'>5.6 练习</a></li></ul></li><li><a href='./1479436214618_303969565.html'>第6章 类再生</a></li><li><ul><li><a href='./1479436214618_1498787567.html'>6.1 合成的语法</a></li><li><a href='./1479436214618_1797834651.html'>6.2 继承的语法</a></li><li><a href='./1479436214619_128080957.html'>6.3 合成与继承的结合</a></li><li><a href='./1479436214619_-538376950.html'>6.4 到底选择合成还是继承</a></li><li><a href='./1479436214619_754950718.html'>6.5 protected</a></li><li><a href='./1479436214619_68859466.html'>6.6 累积开发</a></li><li><a href='./1479436214620_1707544672.html'>6.7 上溯造型</a></li><li><a href='./1479436214620_-1441830877.html'>6.8 final关键字</a></li><li><a href='./1479436214620_1153478487.html'>6.9 初始化和类装载</a></li><li><a href='./1479436214620_-39288028.html'>6.10 总结</a></li><li><a href='./1479436214620_537511919.html'>6.11 练习</a></li></ul></li><li><a href='./1479436214621_636771584.html'>第7章 多形性</a></li><li><ul><li><a href='./1479436214621_14200843.html'>7.1 上溯造型</a></li><li><a href='./1479436214621_-125275107.html'>7.2 深入理解</a></li><li><a href='./1479436214621_-1006098686.html'>7.3 覆盖与过载</a></li><li><a href='./1479436214622_1469935979.html'>7.4 抽象类和方法</a></li><li><a href='./1479436214622_-321517007.html'>7.5 接口</a></li><li><a href='./1479436214622_-1548998791.html'>7.6 内部类</a></li><li><a href='./1479436214622_-1125287817.html'>7.7 构建器和多形性</a></li><li><a href='./1479436214622_1541346557.html'>7.8 通过继承进行设计</a></li><li><a href='./1479436214623_1527391664.html'>7.9 总结</a></li><li><a href='./1479436214623_-953872192.html'>7.10 练习</a></li></ul></li><li><a href='./1479436214623_-1694327281.html'>第8章 对象的容纳</a></li><li><ul><li><a href='./1479436214623_1677953038.html'>8.1 数组</a></li><li><a href='./1479436214623_157279663.html'>8.2 集合</a></li><li><a href='./1479436214624_2028486897.html'>8.3 枚举器（反复器）</a></li><li><a href='./1479436214624_1552417959.html'>8.4 集合的类型</a></li><li><a href='./1479436214624_-1236839872.html'>8.5 排序</a></li><li><a href='./1479436214624_948884352.html'>8.6 通用集合库</a></li><li><a href='./1479436214624_-29314847.html'>8.7 新集合</a></li><li><a href='./1479436214625_950741899.html'>8.8 总结</a></li><li><a href='./1479436214625_-235386019.html'>8.9 练习</a></li></ul></li><li><a href='./1479436214625_-1144170168.html'>第9章 违例差错控制</a></li><li><ul><li><a href='./1479436214625_1164481198.html'>9.1 基本违例</a></li><li><a href='./1479436214625_639309640.html'>9.2 违例的捕获</a></li><li><a href='./1479436214625_545387660.html'>9.3 标准Java违例</a></li><li><a href='./1479436214625_1703684624.html'>9.4 创建自己的违例</a></li><li><a href='./1479436214626_-1814781625.html'>9.5 违例的限制</a></li><li><a href='./1479436214626_1362968450.html'>9.6 用finally清除</a></li><li><a href='./1479436214626_1696138810.html'>9.7 构建器</a></li><li><a href='./1479436214626_-946669500.html'>9.8 违例匹配</a></li><li><a href='./1479436214626_1369629725.html'>9.9 总结</a></li><li><a href='./1479436214626_1887454245.html'>9.10 练习</a></li></ul></li><li><a href='./1479436214627_-823192075.html'>第10章 Java IO系统</a></li><li><ul><li><a href='./1479436214627_793225325.html'>10.1 输入和输出</a></li><li><a href='./1479436214627_-1441186029.html'>10.2 增添属性和有用的接口</a></li><li><a href='./1479436214627_1039462397.html'>10.3 本身的缺陷：RandomAccessFile</a></li><li><a href='./1479436214627_1841380738.html'>10.4 File类</a></li><li><a href='./1479436214628_2095064408.html'>10.5 IO流的典型应用</a></li><li><a href='./1479436214628_1699205963.html'>10.6 StreamTokenizer</a></li><li><a href='./1479436214628_-1183832916.html'>10.7 Java 1.1的IO流</a></li><li><a href='./1479436214628_1169764652.html'>10.8 压缩</a></li><li><a href='./1479436214628_599949674.html'>10.9 对象序列化</a></li><li><a href='./1479436214629_822501598.html'>10.10 总结</a></li><li><a href='./1479436214629_784582642.html'>10.11 练习</a></li></ul></li><li><a href='./1479436214629_-446109494.html'>第11章 运行期类型鉴定</a></li><li><ul><li><a href='./1479436214629_615980680.html'>11.1 对RTTI的需要</a></li><li><a href='./1479436214629_1591261577.html'>11.2 RTTI语法</a></li><li><a href='./1479436214629_-479724471.html'>11.3 反射：运行期类信息</a></li><li><a href='./1479436214630_1962275414.html'>11.4 总结</a></li><li><a href='./1479436214630_-104101779.html'>11.5 练习</a></li></ul></li><li><a href='./1479436214630_2105662301.html'>第12章 传递和返回对象</a></li><li><ul><li><a href='./1479436214630_-381058478.html'>12.1 传递句柄</a></li><li><a href='./1479436214630_1317862656.html'>12.2 制作本地副本</a></li><li><a href='./1479436214630_66286946.html'>12.3 克隆的控制</a></li><li><a href='./1479436214631_1628962510.html'>12.4 只读类</a></li><li><a href='./1479436214631_178950784.html'>12.5 总结</a></li><li><a href='./1479436214631_204549698.html'>12.6 练习</a></li></ul></li><li><a href='./1479436214631_1667056471.html'>第13章 创建窗口和程序片</a></li><li><a href='./1479436214631_1646591288.html'>第14章 多线程</a></li><li><ul><li><a href='./1479436214631_-2057627207.html'>14.1 反应灵敏的用户界面</a></li><li><a href='./1479436214631_1635675213.html'>14.2 共享有限的资源</a></li><li><a href='./1479436214632_1587335383.html'>14.3 堵塞</a></li><li><a href='./1479436214632_1322789348.html'>14.4 优先级</a></li><li><a href='./1479436214632_1679851836.html'>14.5 回顾runnable</a></li><li><a href='./1479436214632_-914514060.html'>14.6 总结</a></li><li><a href='./1479436214632_1301544438.html'>14.7 练习</a></li></ul></li><li><a href='./1479436214633_1637559906.html'>第15章 网络编程</a></li><li><ul><li><a href='./1479436214633_-2140545630.html'>15.1 机器的标识</a></li><li><a href='./1479436214633_946775708.html'>15.2 套接字</a></li><li><a href='./1479436214634_1854884592.html'>15.3 服务多个客户</a></li><li><a href='./1479436214634_1410414288.html'>15.4 数据报</a></li><li><a href='./1479436214634_224372951.html'>15.5 一个Web应用</a></li><li><a href='./1479436214634_-1622230225.html'>15.6 Java与CGI的沟通</a></li><li><a href='./1479436214634_-903287570.html'>15.7 用JDBC连接数据库</a></li><li><a href='./1479436214634_-416599191.html'>15.8 远程方法</a></li><li><a href='./1479436214635_-917204139.html'>15.9 总结</a></li><li><a href='./1479436214635_-540223303.html'>15.10 练习</a></li></ul></li><li><a href='./1479436214635_339847129.html'>第16章 设计范式</a></li><li><ul><li><a href='./1479436214635_1826776975.html'>16.1 范式的概念</a></li><li><a href='./1479436214635_1309397010.html'>16.2 观察器范式</a></li><li><a href='./1479436214636_132034955.html'>16.3 模拟垃圾回收站</a></li><li><a href='./1479436214636_1756675694.html'>16.4 改进设计</a></li><li><a href='./1479436214636_-1966590010.html'>16.5 抽象的应用</a></li><li><a href='./1479436214636_-1831214784.html'>16.6 多重派遣</a></li><li><a href='./1479436214636_1935634882.html'>16.7 访问器范式</a></li><li><a href='./1479436214636_1843093443.html'>16.8 RTTI真的有害吗</a></li><li><a href='./1479436214636_-1838860121.html'>16.9 总结</a></li><li><a href='./1479436214637_-1901505940.html'>16.10 练习</a></li></ul></li><li><a href='./1479436214637_-387290815.html'>第17章 项目</a></li><li><ul><li><a href='./1479436214637_-498587551.html'>17.1 文字处理</a></li><li><a href='./1479436214637_1300299412.html'>17.2 方法查找工具</a></li><li><a href='./1479436214637_1681291541.html'>17.3 复杂性理论</a></li><li><a href='./1479436214637_-1113877505.html'>17.4 总结</a></li><li><a href='./1479436214638_-1637352061.html'>17.5 练习</a></li></ul></li><li><a href='./1479436214638_931172498.html'>附录A 使用非JAVA代码</a></li><li><a href='./1479436214638_882880730.html'>附录B 对比C++和Java</a></li><li><a href='./1479436214638_-283304223.html'>附录C Java编程规则</a></li><li><a href='./1479436214638_-1842547113.html'>附录D 性能</a></li><li><a href='./1479436214638_749950023.html'>附录E 关于垃圾收集的一些话</a></li><li><a href='./1479436214639_2079199942.html'>附录F 推荐读物</a></li><li></li>
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
					<div class="col-xs-8">
# 附录C Java编程规则<br><br><br>本附录包含了大量有用的建议，帮助大家进行低级程序设计，并提供了代码编写的一般性指导：<br><br>(1) 类名首字母应该大写。字段、方法以及对象（句柄）的首字母应小写。对于所有标识符，其中包含的所有单词都应紧靠在一起，而且大写中间单词的首字母。例如：<br><br>```<br>ThisIsAClassName<br>thisIsMethodOrFieldName<br>```<br><br>若在定义中出现了常数初始化字符，则大写static final基本类型标识符中的所有字母。这样便可标志出它们属于编译期的常数。<br><br>Java包（Package）属于一种特殊情况：它们全都是小写字母，即便中间的单词亦是如此。对于域名扩展名称，如com，org，net或者edu等，全部都应小写（这也是Java 1.1和Java 1.2的区别之一）。<br><br>(2) 为了常规用途而创建一个类时，请采取“经典形式”，并包含对下述元素的定义：<br><br>```<br>equals()<br>hashCode()<br>toString()<br>clone()（implement Cloneable）<br>implement Serializable<br>```<br><br>(3) 对于自己创建的每一个类，都考虑置入一个main()，其中包含了用于测试那个类的代码。为使用一个项目中的类，我们没必要删除测试代码。若进行了任何形式的改动，可方便地返回测试。这些代码也可作为如何使用类的一个示例使用。<br><br>(4) 应将方法设计成简要的、功能性单元，用它描述和实现一个不连续的类接口部分。理想情况下，方法应简明扼要。若长度很大，可考虑通过某种方式将其分割成较短的几个方法。这样做也便于类内代码的重复使用（有些时候，方法必须非常大，但它们仍应只做同样的一件事情）。<br><br>(5) 设计一个类时，请设身处地为客户程序员考虑一下（类的使用方法应该是非常明确的）。然后，再设身处地为管理代码的人考虑一下（预计有可能进行哪些形式的修改，想想用什么方法可把它们变得更简单）。<br><br>(6) 使类尽可能短小精悍，而且只解决一个特定的问题。下面是对类设计的一些建议：<br><br>■一个复杂的开关语句：考虑采用“多形”机制<br><br>■数量众多的方法涉及到类型差别极大的操作：考虑用几个类来分别实现<br><br>■许多成员变量在特征上有很大的差别：考虑使用几个类<br><br>(7) 让一切东西都尽可能地“私有”——private。可使库的某一部分“公共化”（一个方法、类或者一个字段等等），就永远不能把它拿出。若强行拿出，就可能破坏其他人现有的代码，使他们不得不重新编写和设计。若只公布自己必须公布的，就可放心大胆地改变其他任何东西。在多线程环境中，隐私是特别重要的一个因素——只有private字段才能在非同步使用的情况下受到保护。<br><br>(8) 谨惕“巨大对象综合症”。对一些习惯于顺序编程思维、且初涉OOP领域的新手，往往喜欢先写一个顺序执行的程序，再把它嵌入一个或两个巨大的对象里。根据编程原理，对象表达的应该是应用程序的概念，而非应用程序本身。<br><br>(9) 若不得已进行一些不太雅观的编程，至少应该把那些代码置于一个类的内部。<br><br>(10) 任何时候只要发现类与类之间结合得非常紧密，就需要考虑是否采用内部类，从而改善编码及维护工作（参见第14章14.1.2小节的“用内部类改进代码”）。<br><br>(11) 尽可能细致地加上注释，并用javadoc注释文档语法生成自己的程序文档。<br><br>(12) 避免使用“魔术数字”，这些数字很难与代码很好地配合。如以后需要修改它，无疑会成为一场噩梦，因为根本不知道“100”到底是指“数组大小”还是“其他全然不同的东西”。所以，我们应创建一个常数，并为其使用具有说服力的描述性名称，并在整个程序中都采用常数标识符。这样可使程序更易理解以及更易维护。<br><br>(13) 涉及构建器和异常的时候，通常希望重新丢弃在构建器中捕获的任何异常——如果它造成了那个对象的创建失败。这样一来，调用者就不会以为那个对象已正确地创建，从而盲目地继续。<br><br>(14) 当客户程序员用完对象以后，若你的类要求进行任何清除工作，可考虑将清除代码置于一个良好定义的方法里，采用类似于cleanup()这样的名字，明确表明自己的用途。除此以外，可在类内放置一个boolean（布尔）标记，指出对象是否已被清除。在类的finalize()方法里，请确定对象已被清除，并已丢弃了从RuntimeException继承的一个类（如果还没有的话），从而指出一个编程错误。在采取象这样的方案之前，请确定finalize()能够在自己的系统中工作（可能需要调用System.runFinalizersOnExit(true)，从而确保这一行为）。<br><br>(15) 在一个特定的作用域内，若一个对象必须清除（非由垃圾收集机制处理），请采用下述方法：初始化对象；若成功，则立即进入一个含有finally从句的try块，开始清除工作。<br><br>(16) 若在初始化过程中需要覆盖（取消）finalize()，请记住调用super.finalize()（若Object属于我们的直接超类，则无此必要）。在对finalize()进行覆盖的过程中，对super.finalize()的调用应属于最后一个行动，而不应是第一个行动，这样可确保在需要基础类组件的时候它们依然有效。<br><br>(17) 创建大小固定的对象集合时，请将它们传输至一个数组（若准备从一个方法里返回这个集合，更应如此操作）。这样一来，我们就可享受到数组在编译期进行类型检查的好处。此外，为使用它们，数组的接收者也许并不需要将对象“造型”到数组里。<br><br>(18) 尽量使用interfaces，不要使用abstract类。若已知某样东西准备成为一个基础类，那么第一个选择应是将其变成一个interface（接口）。只有在不得不使用方法定义或者成员变量的时候，才需要将其变成一个abstract（抽象）类。接口主要描述了客户希望做什么事情，而一个类则致力于（或允许）具体的实施细节。<br><br>(19) 在构建器内部，只进行那些将对象设为正确状态所需的工作。尽可能地避免调用其他方法，因为那些方法可能被其他人覆盖或取消，从而在构建过程中产生不可预知的结果（参见第7章的详细说明）。<br><br>(20) 对象不应只是简单地容纳一些数据；它们的行为也应得到良好的定义。<br><br>(21) 在现成类的基础上创建新类时，请首先选择“新建”或“创作”。只有自己的设计要求必须继承时，才应考虑这方面的问题。若在本来允许新建的场合使用了继承，则整个设计会变得没有必要地复杂。<br><br>(22) 用继承及方法覆盖来表示行为间的差异，而用字段表示状态间的区别。一个非常极端的例子是通过对不同类的继承来表示颜色，这是绝对应该避免的：应直接使用一个“颜色”字段。<br><br>(23) 为避免编程时遇到麻烦，请保证在自己类路径指到的任何地方，每个名字都仅对应一个类。否则，编译器可能先找到同名的另一个类，并报告出错消息。若怀疑自己碰到了类路径问题，请试试在类路径的每一个起点，搜索一下同名的.class文件。<br><br>(24) 在Java 1.1 AWT中使用事件“适配器”时，特别容易碰到一个陷阱。若覆盖了某个适配器方法，同时拼写方法没有特别讲究，最后的结果就是新添加一个方法，而不是覆盖现成方法。然而，由于这样做是完全合法的，所以不会从编译器或运行期系统获得任何出错提示——只不过代码的工作就变得不正常了。<br><br>(25) 用合理的设计方案消除“伪功能”。也就是说，假若只需要创建类的一个对象，就不要提前限制自己使用应用程序，并加上一条“只生成其中一个”注释。请考虑将其封装成一个“独生子”的形式。若在主程序里有大量散乱的代码，用于创建自己的对象，请考虑采纳一种创造性的方案，将些代码封装起来。<br><br>(26) 警惕“分析瘫痪”。请记住，无论如何都要提前了解整个项目的状况，再去考察其中的细节。由于把握了全局，可快速认识自己未知的一些因素，防止在考察细节的时候陷入“死逻辑”中。<br><br>(27) 警惕“过早优化”。首先让它运行起来，再考虑变得更快——但只有在自己必须这样做、而且经证实在某部分代码中的确存在一个性能瓶颈的时候，才应进行优化。除非用专门的工具分析瓶颈，否则很有可能是在浪费自己的时间。性能提升的隐含代价是自己的代码变得难于理解，而且难于维护。<br><br>(28) 请记住，阅读代码的时间比写代码的时间多得多。思路清晰的设计可获得易于理解的程序，但注释、细致的解释以及一些示例往往具有不可估量的价值。无论对你自己，还是对后来的人，它们都是相当重要的。如对此仍有怀疑，那么请试想自己试图从联机Java文档里找出有用信息时碰到的挫折，这样或许能将你说服。<br><br>(29) 如认为自己已进行了良好的分析、设计或者实施，那么请稍微更换一下思维角度。试试邀请一些外来人士——并不一定是专家，但可以是来自本公司其他部门的人。请他们用完全新鲜的眼光考察你的工作，看看是否能找出你一度熟视无睹的问题。采取这种方式，往往能在最适合修改的阶段找出一些关键性的问题，避免产品发行后再解决问题而造成的金钱及精力方面的损失。<br><br>(30) 良好的设计能带来最大的回报。简言之，对于一个特定的问题，通常会花较长的时间才能找到一种最恰当的解决方案。但一旦找到了正确的方法，以后的工作就轻松多了，再也不用经历数小时、数天或者数月的痛苦挣扎。我们的努力工作会带来最大的回报（甚至无可估量）。而且由于自己倾注了大量心血，最终获得一个出色的设计方案，成功的快感也是令人心动的。坚持抵制草草完工的诱惑——那样做往往得不偿失。<br><br>(31) 可在Web上找到大量的编程参考资源，甚至包括大量新闻组、讨论组、邮寄列表等。下面这个地方提供了大量有益的链接：<br><br>http://www.ulb.ac.be/esp/ip-Links/Java/joodcs/mm-WebBiblio.html
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
			</div>
			<!-- /.row -->
			  <hr>
        <!-- Footer -->
        <footer>
            <div class="row">
                <div class="col-lg-12">
                    <p>Copyright &copy; 小龙软件工作室 2016</p>
                </div>
            </div>
        </footer>

    </div>
    <!-- /.container -->

    <!-- jQuery -->
    <script src="../../js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="../../js/bootstrap.min.js"></script>

</body>

</html>
