<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="content-type" content="text/html;charset=utf-8">
    <meta charset="utf-8">
<meta name="360-site-verification" content="cabcfb5a0f4c0d28d604e8a69e6c0cdb" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="baidu-site-verification" content="HknqsD2zhn" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>java编程思想(thinking in java)-编码助手网</title>
      <meta content="为编码人员提供在线文档、模板等帮助，提升解决问题效率" name="description">
			<meta content="java编程思想(thinking in java) Java, spring, tomcat, servlet, jsp, api doc, bootstrap" name="keywords">
<meta name="sogou_site_verification" content="42nApEZFKO"/>


    <!-- Bootstrap Core CSS -->
    <link href="../../css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="../../css/heroic-features.css" rel="stylesheet">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
		<script>
		var _hmt = _hmt || [];
		(function() {
		  var hm = document.createElement("script");
		  hm.src = "//hm.baidu.com/hm.js?dd1361ca20a10cc161e72d4bc4fef6df";
		  var s = document.getElementsByTagName("script")[0];
		  s.parentNode.insertBefore(hm, s);
		})();
		</script>

</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">编码助手网</a>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav">
                    <li>
                        <a href="/">首页</a>
                    </li>
										<li>
                        <a href="/template.html">模板</a>
                    </li>
										<li>
												<a href="/doc.html">文档</a>
										</li>
                    <li>
                        <a href="/contact.html">联系我们</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Content -->
    <div class="container">

			<div class="row">
					<div class="col-xs-4">
						<h4>java编程思想(thinking in java)</h4>
						<h6>感谢http://quanke.name提供内容</h6>
<ul><li><a href='./1479436214592_-168316990.html'>Introduction</a></li><li><a href='./1479436214605_802664538.html'>写在前面的话</a></li><li><a href='./1479436214605_-791815332.html'>引言</a></li><li><a href='./1479436214605_1266451767.html'>第1章 对象入门</a></li><li><ul><li><a href='./1479436214606_-1211955969.html'>1.1 抽象的进步</a></li><li><a href='./1479436214606_-985491570.html'>1.2 对象的接口</a></li><li><a href='./1479436214606_421738363.html'>1.3 实现方案的隐藏</a></li><li><a href='./1479436214607_1726094433.html'>1.4 方案的重复使用</a></li><li><a href='./1479436214607_-1917493719.html'>1.5 继承：重新使用接口</a></li><li><a href='./1479436214607_-994529289.html'>1.6 多形对象的互换使用</a></li><li><a href='./1479436214608_695543294.html'>1.7 对象的创建和存在时间</a></li><li><a href='./1479436214609_186799536.html'>1.8 违例控制：解决错误</a></li><li><a href='./1479436214609_225257298.html'>1.9 多线程</a></li><li><a href='./1479436214610_-1377857368.html'>1.10 永久性</a></li><li><a href='./1479436214610_-1567485742.html'>1.11 Java和因特网</a></li><li><a href='./1479436214610_-534049255.html'>1.12 分析和设计</a></li><li><a href='./1479436214611_-516206529.html'>1.13 Java还是C++</a></li></ul></li><li><a href='./1479436214611_-833808368.html'>第2章 一切都是对象</a></li><li><ul><li><a href='./1479436214611_160489487.html'>2.1 用句柄操纵对象</a></li><li><a href='./1479436214611_-395400265.html'>2.2 所有对象都必须创建</a></li><li><a href='./1479436214612_-105112715.html'>2.3 绝对不要清除对象</a></li><li><a href='./1479436214612_-1081120728.html'>2.4 新建数据类型：类</a></li><li><a href='./1479436214612_437273775.html'>2.5 方法、自变量和返回值</a></li><li><a href='./1479436214612_968479086.html'>2.6 构建Java程序</a></li><li><a href='./1479436214612_-1963386412.html'>2.7 我们的第一个Java程序</a></li><li><a href='./1479436214613_988202688.html'>2.8 注释和嵌入文档</a></li><li><a href='./1479436214613_-642199972.html'>2.9 编码样式</a></li><li><a href='./1479436214613_-1135594618.html'>2.10 总结</a></li><li><a href='./1479436214613_976703976.html'>2.11 练习</a></li></ul></li><li><a href='./1479436214614_1617201657.html'>第3章 控制程序流程</a></li><li><ul><li><a href='./1479436214614_479400700.html'>3.1 使用Java运算符</a></li><li><a href='./1479436214614_-9479532.html'>3.2 执行控制</a></li><li><a href='./1479436214614_198965659.html'>3.3 总结</a></li><li><a href='./1479436214615_-634539581.html'>3.4 练习</a></li></ul></li><li><a href='./1479436214615_-1049694152.html'>第4章 初始化和清除</a></li><li><ul><li><a href='./1479436214615_-614369641.html'>4.1 用构建器自动初始化</a></li><li><a href='./1479436214615_-2107354158.html'>4.2 方法过载</a></li><li><a href='./1479436214616_2106438365.html'>4.3 清除：收尾和垃圾收集</a></li><li><a href='./1479436214616_-1969096840.html'>4.4 成员初始化</a></li><li><a href='./1479436214616_55724218.html'>4.5 数组初始化</a></li><li><a href='./1479436214616_-51810259.html'>4.6 总结</a></li><li><a href='./1479436214616_749059750.html'>4.7 练习</a></li></ul></li><li><a href='./1479436214617_-1201809261.html'>第5章 隐藏实施过程</a></li><li><ul><li><a href='./1479436214617_75246657.html'>5.1 包：库单元</a></li><li><a href='./1479436214617_-738077386.html'>5.2 Java访问指示符</a></li><li><a href='./1479436214617_-131608479.html'>5.3 接口与实现</a></li><li><a href='./1479436214617_-1940689271.html'>5.4 类访问</a></li><li><a href='./1479436214618_1119703547.html'>5.5 总结</a></li><li><a href='./1479436214618_-768700500.html'>5.6 练习</a></li></ul></li><li><a href='./1479436214618_303969565.html'>第6章 类再生</a></li><li><ul><li><a href='./1479436214618_1498787567.html'>6.1 合成的语法</a></li><li><a href='./1479436214618_1797834651.html'>6.2 继承的语法</a></li><li><a href='./1479436214619_128080957.html'>6.3 合成与继承的结合</a></li><li><a href='./1479436214619_-538376950.html'>6.4 到底选择合成还是继承</a></li><li><a href='./1479436214619_754950718.html'>6.5 protected</a></li><li><a href='./1479436214619_68859466.html'>6.6 累积开发</a></li><li><a href='./1479436214620_1707544672.html'>6.7 上溯造型</a></li><li><a href='./1479436214620_-1441830877.html'>6.8 final关键字</a></li><li><a href='./1479436214620_1153478487.html'>6.9 初始化和类装载</a></li><li><a href='./1479436214620_-39288028.html'>6.10 总结</a></li><li><a href='./1479436214620_537511919.html'>6.11 练习</a></li></ul></li><li><a href='./1479436214621_636771584.html'>第7章 多形性</a></li><li><ul><li><a href='./1479436214621_14200843.html'>7.1 上溯造型</a></li><li><a href='./1479436214621_-125275107.html'>7.2 深入理解</a></li><li><a href='./1479436214621_-1006098686.html'>7.3 覆盖与过载</a></li><li><a href='./1479436214622_1469935979.html'>7.4 抽象类和方法</a></li><li><a href='./1479436214622_-321517007.html'>7.5 接口</a></li><li><a href='./1479436214622_-1548998791.html'>7.6 内部类</a></li><li><a href='./1479436214622_-1125287817.html'>7.7 构建器和多形性</a></li><li><a href='./1479436214622_1541346557.html'>7.8 通过继承进行设计</a></li><li><a href='./1479436214623_1527391664.html'>7.9 总结</a></li><li><a href='./1479436214623_-953872192.html'>7.10 练习</a></li></ul></li><li><a href='./1479436214623_-1694327281.html'>第8章 对象的容纳</a></li><li><ul><li><a href='./1479436214623_1677953038.html'>8.1 数组</a></li><li><a href='./1479436214623_157279663.html'>8.2 集合</a></li><li><a href='./1479436214624_2028486897.html'>8.3 枚举器（反复器）</a></li><li><a href='./1479436214624_1552417959.html'>8.4 集合的类型</a></li><li><a href='./1479436214624_-1236839872.html'>8.5 排序</a></li><li><a href='./1479436214624_948884352.html'>8.6 通用集合库</a></li><li><a href='./1479436214624_-29314847.html'>8.7 新集合</a></li><li><a href='./1479436214625_950741899.html'>8.8 总结</a></li><li><a href='./1479436214625_-235386019.html'>8.9 练习</a></li></ul></li><li><a href='./1479436214625_-1144170168.html'>第9章 违例差错控制</a></li><li><ul><li><a href='./1479436214625_1164481198.html'>9.1 基本违例</a></li><li><a href='./1479436214625_639309640.html'>9.2 违例的捕获</a></li><li><a href='./1479436214625_545387660.html'>9.3 标准Java违例</a></li><li><a href='./1479436214625_1703684624.html'>9.4 创建自己的违例</a></li><li><a href='./1479436214626_-1814781625.html'>9.5 违例的限制</a></li><li><a href='./1479436214626_1362968450.html'>9.6 用finally清除</a></li><li><a href='./1479436214626_1696138810.html'>9.7 构建器</a></li><li><a href='./1479436214626_-946669500.html'>9.8 违例匹配</a></li><li><a href='./1479436214626_1369629725.html'>9.9 总结</a></li><li><a href='./1479436214626_1887454245.html'>9.10 练习</a></li></ul></li><li><a href='./1479436214627_-823192075.html'>第10章 Java IO系统</a></li><li><ul><li><a href='./1479436214627_793225325.html'>10.1 输入和输出</a></li><li><a href='./1479436214627_-1441186029.html'>10.2 增添属性和有用的接口</a></li><li><a href='./1479436214627_1039462397.html'>10.3 本身的缺陷：RandomAccessFile</a></li><li><a href='./1479436214627_1841380738.html'>10.4 File类</a></li><li><a href='./1479436214628_2095064408.html'>10.5 IO流的典型应用</a></li><li><a href='./1479436214628_1699205963.html'>10.6 StreamTokenizer</a></li><li><a href='./1479436214628_-1183832916.html'>10.7 Java 1.1的IO流</a></li><li><a href='./1479436214628_1169764652.html'>10.8 压缩</a></li><li><a href='./1479436214628_599949674.html'>10.9 对象序列化</a></li><li><a href='./1479436214629_822501598.html'>10.10 总结</a></li><li><a href='./1479436214629_784582642.html'>10.11 练习</a></li></ul></li><li><a href='./1479436214629_-446109494.html'>第11章 运行期类型鉴定</a></li><li><ul><li><a href='./1479436214629_615980680.html'>11.1 对RTTI的需要</a></li><li><a href='./1479436214629_1591261577.html'>11.2 RTTI语法</a></li><li><a href='./1479436214629_-479724471.html'>11.3 反射：运行期类信息</a></li><li><a href='./1479436214630_1962275414.html'>11.4 总结</a></li><li><a href='./1479436214630_-104101779.html'>11.5 练习</a></li></ul></li><li><a href='./1479436214630_2105662301.html'>第12章 传递和返回对象</a></li><li><ul><li><a href='./1479436214630_-381058478.html'>12.1 传递句柄</a></li><li><a href='./1479436214630_1317862656.html'>12.2 制作本地副本</a></li><li><a href='./1479436214630_66286946.html'>12.3 克隆的控制</a></li><li><a href='./1479436214631_1628962510.html'>12.4 只读类</a></li><li><a href='./1479436214631_178950784.html'>12.5 总结</a></li><li><a href='./1479436214631_204549698.html'>12.6 练习</a></li></ul></li><li><a href='./1479436214631_1667056471.html'>第13章 创建窗口和程序片</a></li><li><a href='./1479436214631_1646591288.html'>第14章 多线程</a></li><li><ul><li><a href='./1479436214631_-2057627207.html'>14.1 反应灵敏的用户界面</a></li><li><a href='./1479436214631_1635675213.html'>14.2 共享有限的资源</a></li><li><a href='./1479436214632_1587335383.html'>14.3 堵塞</a></li><li><a href='./1479436214632_1322789348.html'>14.4 优先级</a></li><li><a href='./1479436214632_1679851836.html'>14.5 回顾runnable</a></li><li><a href='./1479436214632_-914514060.html'>14.6 总结</a></li><li><a href='./1479436214632_1301544438.html'>14.7 练习</a></li></ul></li><li><a href='./1479436214633_1637559906.html'>第15章 网络编程</a></li><li><ul><li><a href='./1479436214633_-2140545630.html'>15.1 机器的标识</a></li><li><a href='./1479436214633_946775708.html'>15.2 套接字</a></li><li><a href='./1479436214634_1854884592.html'>15.3 服务多个客户</a></li><li><a href='./1479436214634_1410414288.html'>15.4 数据报</a></li><li><a href='./1479436214634_224372951.html'>15.5 一个Web应用</a></li><li><a href='./1479436214634_-1622230225.html'>15.6 Java与CGI的沟通</a></li><li><a href='./1479436214634_-903287570.html'>15.7 用JDBC连接数据库</a></li><li><a href='./1479436214634_-416599191.html'>15.8 远程方法</a></li><li><a href='./1479436214635_-917204139.html'>15.9 总结</a></li><li><a href='./1479436214635_-540223303.html'>15.10 练习</a></li></ul></li><li><a href='./1479436214635_339847129.html'>第16章 设计范式</a></li><li><ul><li><a href='./1479436214635_1826776975.html'>16.1 范式的概念</a></li><li><a href='./1479436214635_1309397010.html'>16.2 观察器范式</a></li><li><a href='./1479436214636_132034955.html'>16.3 模拟垃圾回收站</a></li><li><a href='./1479436214636_1756675694.html'>16.4 改进设计</a></li><li><a href='./1479436214636_-1966590010.html'>16.5 抽象的应用</a></li><li><a href='./1479436214636_-1831214784.html'>16.6 多重派遣</a></li><li><a href='./1479436214636_1935634882.html'>16.7 访问器范式</a></li><li><a href='./1479436214636_1843093443.html'>16.8 RTTI真的有害吗</a></li><li><a href='./1479436214636_-1838860121.html'>16.9 总结</a></li><li><a href='./1479436214637_-1901505940.html'>16.10 练习</a></li></ul></li><li><a href='./1479436214637_-387290815.html'>第17章 项目</a></li><li><ul><li><a href='./1479436214637_-498587551.html'>17.1 文字处理</a></li><li><a href='./1479436214637_1300299412.html'>17.2 方法查找工具</a></li><li><a href='./1479436214637_1681291541.html'>17.3 复杂性理论</a></li><li><a href='./1479436214637_-1113877505.html'>17.4 总结</a></li><li><a href='./1479436214638_-1637352061.html'>17.5 练习</a></li></ul></li><li><a href='./1479436214638_931172498.html'>附录A 使用非JAVA代码</a></li><li><a href='./1479436214638_882880730.html'>附录B 对比C++和Java</a></li><li><a href='./1479436214638_-283304223.html'>附录C Java编程规则</a></li><li><a href='./1479436214638_-1842547113.html'>附录D 性能</a></li><li><a href='./1479436214638_749950023.html'>附录E 关于垃圾收集的一些话</a></li><li><a href='./1479436214639_2079199942.html'>附录F 推荐读物</a></li><li></li>
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
					<div class="col-xs-8">
# 10.7 Java 1.1的IO流<br><br><br>到这个时候，大家或许会陷入一种困境之中，怀疑是否存在IO流的另一种设计方案，并可能要求更大的代码量。还有人能提出一种更古怪的设计吗？事实上，Java 1.1对IO流库进行了一些重大的改进。看到Reader和Writer类时，大多数人的第一个印象（就象我一样）就是它们用来替换原来的InputStream和OutputStream类。但实情并非如此。尽管不建议使用原始数据流库的某些功能（如使用它们，会从编译器收到一条警告消息），但原来的数据流依然得到了保留，以便维持向后兼容，而且：<br><br>(1) 在老式层次结构里加入了新类，所以Sun公司明显不会放弃老式数据流。<br><br>(2) 在许多情况下，我们需要与新结构中的类联合使用老结构中的类。为达到这个目的，需要使用一些“桥”类：<br><br>InputStreamReader将一个InputStream转换成Reader，OutputStreamWriter将一个OutputStream转换成Writer。<br>所以与原来的IO流库相比，经常都要对新IO流进行层次更多的封装。同样地，这也属于装饰器方案的一个缺点——需要为额外的灵活性付出代价。<br><br>之所以在Java 1.1里添加了Reader和Writer层次，最重要的原因便是国际化的需求。老式IO流层次结构只支持8位字节流，不能很好地控制16位Unicode字符。由于Unicode主要面向的是国际化支持（Java内含的char是16位的Unicode），所以添加了Reader和Writer层次，以提供对所有IO操作中的Unicode的支持。除此之外，新库也对速度进行了优化，可比旧库更快地运行。<br>与本书其他地方一样，我会试着提供对类的一个概述，但假定你会利用联机文档搞定所有的细节，比如方法的详尽列表等。<br><br>10.7.1 数据的发起与接收<br><br>Java 1.0的几乎所有IO流类都有对应的Java 1.1类，用于提供内建的Unicode管理。似乎最容易的事情就是“全部使用新类，再也不要用旧的”，但实际情况并没有这么简单。有些时候，由于受到库设计的一些限制，我们不得不使用Java 1.0的IO流类。特别要指出的是，在旧流库的基础上新加了java.util.zip库，它们依赖旧的流组件。所以最明智的做法是“尝试性”地使用Reader和Writer类。若代码不能通过编译，便知道必须换回老式库。<br><br>下面这张表格分旧库与新库分别总结了信息发起与接收之间的对应关系。<br><br>```<br>Sources & Sinks:<br>Java 1.0 class<br><br>Corresponding Java 1.1 class<br><br>InputStream<br><br>Reader <br>converter: InputStreamReader<br><br>OutputStream<br><br>Writer <br>converter: OutputStreamWriter<br><br>FileInputStream<br><br>FileReader<br><br>FileOutputStream<br><br>FileWriter<br><br>StringBufferInputStream<br><br>StringReader<br><br>(no corresponding class)<br><br>StringWriter<br><br>ByteArrayInputStream<br><br>CharArrayReader<br><br>ByteArrayOutputStream<br><br>CharArrayWriter<br><br>PipedInputStream<br><br>PipedReader<br><br>PipedOutputStream<br><br>PipedWriter<br><br>```<br><br>我们发现即使不完全一致，但旧库组件中的接口与新接口通常也是类似的。<br><br>10.7.2 修改数据流的行为<br><br>在Java 1.0中，数据流通过FilterInputStream和FilterOutputStream的“装饰器”（Decorator）子类适应特定的需求。Java 1.1的IO流沿用了这一思想，但没有继续采用所有装饰器都从相同“filter”（过滤器）基础类中衍生这一做法。若通过观察类的层次结构来理解它，这可能令人出现少许的困惑。<br><br>在下面这张表格中，对应关系比上一张表要粗糙一些。之所以会出现这个差别，是由类的组织造成的：尽管BufferedOutputStream是FilterOutputStream的一个子类，但是BufferedWriter并不是FilterWriter的子类（对后者来说，尽管它是一个抽象类，但没有自己的子类或者近似子类的东西，也没有一个“占位符”可用，所以不必费心地寻找）。然而，两个类的接口是非常相似的，而且不管在什么情况下，显然应该尽可能地使用新版本，而不应考虑旧版本（也就是说，除非在一些类中必须生成一个Stream，不可生成Reader或者Writer）。<br><br>```<br>Filters:<br>Java 1.0 class<br><br>Corresponding Java 1.1 class<br><br>FilterInputStream<br><br>FilterReader<br><br>FilterOutputStream<br><br>FilterWriter (abstract class with no subclasses)<br><br>BufferedInputStream<br><br>BufferedReader<br>(also has readLine( ))<br><br>BufferedOutputStream<br><br>BufferedWriter<br><br>DataInputStream<br><br>use DataInputStream<br>(Except when you need to use readLine( ), when you should use a BufferedReader)<br><br>PrintStream<br><br>PrintWriter<br><br>LineNumberInputStream<br><br>LineNumberReader<br><br>StreamTokenizer<br><br>StreamTokenizer<br>(use constructor that takes a Reader instead)<br><br>PushBackInputStream<br><br>PushBackReader<br>```<br><br><br>过滤器：Java 1.0类 对应的Java 1.1类<br><br>```<br>FilterInputStream FilterReader<br>FilterOutputStream FilterWriter（没有子类的抽象类）<br>BufferedInputStream BufferedReader（也有readLine()）<br>BufferedOutputStream BufferedWriter<br>DataInputStream 使用DataInputStream（除非要使用readLine()，那时需要使用一个BufferedReader）<br>PrintStream PrintWriter<br>LineNumberInputStream LineNumberReader<br>StreamTokenizer StreamTokenizer（用构建器取代Reader）<br>PushBackInputStream PushBackReader<br>```<br><br>有一条规律是显然的：若想使用readLine()，就不要再用一个DataInputStream来实现（否则会在编译期得到一条出错消息），而应使用一个BufferedReader。但除这种情况以外，DataInputStream仍是Java 1.1 IO库的“首选”成员。<br><br>为了将向PrintWriter的过渡变得更加自然，它提供了能采用任何OutputStream对象的构建器。PrintWriter提供的格式化支持没有PrintStream那么多；但接口几乎是相同的。<br><br>10.7.3 未改变的类<br><br>显然，Java库的设计人员觉得以前的一些类毫无问题，所以没有对它们作任何修改，可象以前那样继续使用它们：<br><br>没有对应Java 1.1类的Java 1.0类<br><br>```<br>DataOutputStream<br>File<br>RandomAccessFile<br>SequenceInputStream<br>```<br><br>特别未加改动的是DataOutputStream，所以为了用一种可转移的格式保存和获取数据，必须沿用InputStream和OutputStream层次结构。<br><br>10.7.4 一个例子<br><br>为体验新类的效果，下面让我们看看如何修改IOStreamDemo.java示例的相应区域，以便使用Reader和Writer类：<br><br>```<br>//: NewIODemo.java<br>// Java 1.1 IO typical usage<br>import java.io.*;<br><br>public class NewIODemo {<br>  public static void main(String[] args) {<br>    try {<br>      // 1. Reading input by lines:<br>      BufferedReader in =<br>        new BufferedReader(<br>          new FileReader(args[0]));<br>      String s, s2 = new String();<br>      while((s = in.readLine())!= null)<br>        s2 += s + "\n";<br>      in.close();<br><br>      // 1b. Reading standard input:<br>      BufferedReader stdin =<br>        new BufferedReader(<br>          new InputStreamReader(System.in));      <br>      System.out.print("Enter a line:");<br>      System.out.println(stdin.readLine());<br><br>      // 2. Input from memory<br>      StringReader in2 = new StringReader(s2);<br>      int c;<br>      while((c = in2.read()) != -1)<br>        System.out.print((char)c);<br><br>      // 3. Formatted memory input<br>      try {<br>        DataInputStream in3 =<br>          new DataInputStream(<br>            // Oops: must use deprecated class:<br>            new StringBufferInputStream(s2));<br>        while(true)<br>          System.out.print((char)in3.readByte());<br>      } catch(EOFException e) {<br>        System.out.println("End of stream");<br>      }<br><br>      // 4. Line numbering & file output<br>      try {<br>        LineNumberReader li =<br>          new LineNumberReader(<br>            new StringReader(s2));<br>        BufferedReader in4 =<br>          new BufferedReader(li);<br>        PrintWriter out1 =<br>          new PrintWriter(<br>            new BufferedWriter(<br>              new FileWriter("IODemo.out")));<br>        while((s = in4.readLine()) != null )<br>          out1.println(<br>            "Line " + li.getLineNumber() + s);<br>        out1.close();<br>      } catch(EOFException e) {<br>        System.out.println("End of stream");<br>      }<br><br>      // 5. Storing & recovering data<br>      try {<br>        DataOutputStream out2 =<br>          new DataOutputStream(<br>            new BufferedOutputStream(<br>              new FileOutputStream("Data.txt")));<br>        out2.writeDouble(3.14159);<br>        out2.writeBytes("That was pi");<br>        out2.close();<br>        DataInputStream in5 =<br>          new DataInputStream(<br>            new BufferedInputStream(<br>              new FileInputStream("Data.txt")));<br>        BufferedReader in5br =<br>          new BufferedReader(<br>            new InputStreamReader(in5));<br>        // Must use DataInputStream for data:<br>        System.out.println(in5.readDouble());<br>        // Can now use the "proper" readLine():<br>        System.out.println(in5br.readLine());<br>      } catch(EOFException e) {<br>        System.out.println("End of stream");<br>      }<br><br>      // 6. Reading and writing random access<br>      // files is the same as before.<br>      // (not repeated here)<br><br>    } catch(FileNotFoundException e) {<br>      System.out.println(<br>        "File Not Found:" + args[1]);<br>    } catch(IOException e) {<br>      System.out.println("IO Exception");<br>    }<br>  }<br>} ///:~<br>```<br><br>大家一般看见的是转换过程非常直观，代码看起来也颇相似。但这些都不是重要的区别。最重要的是，由于随机访问文件已经改变，所以第6节未再重复。<br><br>第1节收缩了一点儿，因为假如要做的全部事情就是读取行输入，那么只需要将一个FileReader封装到BufferedReader之内即可。第1b节展示了封装System.in，以便读取控制台输入的新方法。这里的代码量增多了一些，因为System.in是一个DataInputStream，而且BufferedReader需要一个Reader参数，所以要用InputStreamReader来进行转换。<br><br>在2节，可以看到如果有一个字串，而且想从中读取数据，只需用一个StringReader替换StringBufferInputStream，剩下的代码是完全相同的。<br>```<br>第3节揭示了新IO流库设计中的一个错误。如果有一个字串，而且想从中读取数据，那么不能再以任何形式使用StringBufferInputStream。若编译一个涉及StringBufferInputStream的代码，会得到一条“反对”消息，告诉我们不要用它。此时最好换用一个StringReader。但是，假如要象第3节这样进行格式化的内存输入，就必须使用DataInputStream——没有什么“DataReader”可以代替它——而DataInputStream很不幸地要求用到一个InputStream参数。所以我们没有选择的余地，只好使用编译器不赞成的StringBufferInputStream类。编译器同样会发出反对信息，但我们对此束手无策（注释②）。<br>StringReader替换StringBufferInputStream，剩下的代码是完全相同的。<br><br>②：到你现在正式使用的时候，这个错误可能已经修正。<br><br>第4节明显是从老式数据流到新数据流的一个直接转换，没有需要特别指出的。在第5节中，我们被强迫使用所有的老式数据流，因为DataOutputStream和DataInputStream要求用到它们，而且没有可供替换的东西。然而，编译期间不会产生任何“反对”信息。若不赞成一种数据流，通常是由于它的构建器产生了一条反对消息，禁止我们使用整个类。但在DataInputStream的情况下，只有readLine()是不赞成使用的，因为我们最好为readLine()使用一个BufferedReader（但为其他所有格式化输入都使用一个DataInputStream）。<br><br>若比较第5节和IOStreamDemo.java中的那一小节，会注意到在这个版本中，数据是在文本之前写入的。那是由于Java 1.1本身存在一个错误，如下述代码所示：<br><br>```<br>//: IOBug.java<br>// Java 1.1 (and higher?) IO Bug<br>import java.io.*;<br><br>public class IOBug {<br>  public static void main(String[] args) <br>  throws Exception {<br>    DataOutputStream out =<br>      new DataOutputStream(<br>        new BufferedOutputStream(<br>          new FileOutputStream("Data.txt")));<br>    out.writeDouble(3.14159);<br>    out.writeBytes("That was the value of pi\n");<br>    out.writeBytes("This is pi/2:\n");<br>    out.writeDouble(3.14159/2);<br>    out.close();<br><br>    DataInputStream in =<br>      new DataInputStream(<br>        new BufferedInputStream(<br>          new FileInputStream("Data.txt")));<br>    BufferedReader inbr =<br>      new BufferedReader(<br>        new InputStreamReader(in));<br>    // The doubles written BEFORE the line of text<br>    // read back correctly:<br>    System.out.println(in.readDouble());<br>    // Read the lines of text:<br>    System.out.println(inbr.readLine());<br>    System.out.println(inbr.readLine());<br>    // Trying to read the doubles after the line<br>    // produces an end-of-file exception:<br>    System.out.println(in.readDouble());<br>  }<br>} ///:~<br>```<br><br>看起来，我们在对一个writeBytes()的调用之后写入的任何东西都不是能够恢复的。这是一个十分有限的错误，希望在你读到本书的时候已获得改正。为检测是否改正，请运行上述程序。若没有得到一个违例，而且值都能正确打印出来，就表明已经改正。<br><br>10.7.5 重导向标准IO<br><br>Java 1.1在System类中添加了特殊的方法，允许我们重新定向标准输入、输出以及错误IO流。此时要用到下述简单的静态方法调用：<br><br>```<br>setIn(InputStream)<br>setOut(PrintStream)<br>setErr(PrintStream)<br>```<br><br>如果突然要在屏幕上生成大量输出，而且滚动的速度快于人们的阅读速度，输出的重定向就显得特别有用。在一个命令行程序中，如果想重复测试一个特定的用户输入序列，输入的重定向也显得特别有价值。下面这个简单的例子展示了这些方法的使用：<br><br>```<br>//: Redirecting.java<br>// Demonstrates the use of redirection for <br>// standard IO in Java 1.1<br>import java.io.*;<br><br>class Redirecting {<br>  public static void main(String[] args) {<br>    try {<br>      BufferedInputStream in = <br>        new BufferedInputStream(<br>          new FileInputStream(<br>            "Redirecting.java"));<br>      // Produces deprecation message:<br>      PrintStream out =<br>        new PrintStream(<br>          new BufferedOutputStream(<br>            new FileOutputStream("test.out")));<br>      System.setIn(in);<br>      System.setOut(out);<br>      System.setErr(out);<br><br>      BufferedReader br = <br>        new BufferedReader(<br>          new InputStreamReader(System.in));<br>      String s;<br>      while((s = br.readLine()) != null)<br>        System.out.println(s);<br>      out.close(); // Remember this!<br>    } catch(IOException e) {<br>      e.printStackTrace();<br>    }<br>  }<br>} ///:~<br><br>```<br><br>这个程序的作用是将标准输入同一个文件连接起来，并将标准输出和错误重定向至另一个文件。<br>这是不可避免会遇到“反对”消息的另一个例子。用-deprecation标志编译时得到的消息如下：<br><br><br><br>> Note:The constructor java.io.PrintStream(java.io.OutputStream) has been deprecated.<br>注意：不推荐使用构建器java.io.PrintStream（java.io.OutputStream）。<br><br>然而，无论System.setOut()还是System.setErr()都要求用一个PrintStream作为参数使用，所以必须调用PrintStream构建器。所以大家可能会觉得奇怪，既然Java 1.1通过反对构建器而反对了整个PrintStream，为什么库的设计人员在添加这个反对的同时，依然为System添加了新方法，且指明要求用PrintStream，而不是用PrintWriter呢？毕竟，后者是一个崭新和首选的替换措施呀？这真令人费解。<br>
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
			</div>
			<!-- /.row -->
			  <hr>
        <!-- Footer -->
        <footer>
            <div class="row">
                <div class="col-lg-12">
                    <p>Copyright &copy; 小龙软件工作室 2016</p>
                </div>
            </div>
        </footer>

    </div>
    <!-- /.container -->

    <!-- jQuery -->
    <script src="../../js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="../../js/bootstrap.min.js"></script>

</body>

</html>
