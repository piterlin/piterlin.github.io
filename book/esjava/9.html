<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="content-type" content="text/html;charset=utf-8">
    <meta charset="utf-8">
<meta name="360-site-verification" content="cabcfb5a0f4c0d28d604e8a69e6c0cdb" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="baidu-site-verification" content="HknqsD2zhn" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Java 编程要点-编码助手网</title>
      <meta content="为编码人员提供在线文档、模板等帮助，提升解决问题效率" name="description">
			<meta content="Java 编程要点 Java, spring, tomcat, servlet, jsp, api doc, bootstrap" name="keywords">
<meta name="sogou_site_verification" content="42nApEZFKO"/>


    <!-- Bootstrap Core CSS -->
    <link href="../../css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="../../css/heroic-features.css" rel="stylesheet">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
		<script>
		var _hmt = _hmt || [];
		(function() {
		  var hm = document.createElement("script");
		  hm.src = "//hm.baidu.com/hm.js?dd1361ca20a10cc161e72d4bc4fef6df";
		  var s = document.getElementsByTagName("script")[0];
		  s.parentNode.insertBefore(hm, s);
		})();
		</script>

</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">编码助手网</a>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav">
                    <li>
                        <a href="/">首页</a>
                    </li>
										<li>
                        <a href="/template.html">模板</a>
                    </li>
										<li>
												<a href="/doc.html">文档</a>
										</li>
                    <li>
                        <a href="/contact.html">联系我们</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Content -->
    <div class="container">

			<div class="row">
					<div class="col-xs-4">
						<h4>Java 编程要点</h4>
						<h6>感谢2015 Way Lau提供内容</h6>
<ul><li><a href='./0.html'>快速开始</a></li><li><a href='./1.html'>Java概述</a></li><li><a href='./2.html'>面向对象编程</a></li><li><a href='./3.html'>语言基础</a></li><li><ul><li><a href='./4.html'>变量</a></li><li><a href='./5.html'>运算符</a></li><li><a href='./6.html'>表达式、语句和块</a></li><li><a href='./7.html'>控制流程语句</a></li></ul></li><li><a href='./8.html'>类和对象</a></li><li><a href='./9.html'>注解</a></li><li><a href='./10.html'>泛型</a></li><li><a href='./11.html'>关键字</a></li><li><a href='./12.html'>IO</a></li><li><ul><li><a href='./13.html'>I/O 流</a></li><li><a href='./14.html'>文件 I/O</a></li></ul></li><li><a href='./15.html'>并发</a></li><li><ul><li><a href='./16.html'>进程（Processes ）和线程（Threads）</a></li><li><a href='./17.html'>同步</a></li><li><a href='./18.html'>活跃度（Liveness）</a></li><li><a href='./19.html'>Guarded Blocks</a></li><li><a href='./20.html'>不可变对象（Immutable Objects)</a></li><li><a href='./21.html'>高级并发对象</a></li></ul></li><li><a href='./22.html'>集合框架</a></li><li><a href='./23.html'>网络基础</a></li><li><ul><li><a href='./24.html'>Socket</a></li><li><a href='./25.html'>I/O 模型的演进</a></li></ul></li><li><a href='./26.html'>JDBC</a></li><li><a href='./27.html'>附录</a></li><li></li>
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
<div class="col-xs-8">
	<nav>
		<ul class="pager">
			<li class='previous'><a href='8.html'>&larr; 类和对象</a></li>
		<li class='next'><a href='10.html'>泛型&rarr;</a></li>
		</ul>
	</nav>
			<div class="row"><div class="col-xs-12"># 注解（Annotations）<br><br>注解为程序提供元数据，但是，它不是程序的一部分。它们不会直接影响在注解的代码操作。<br><br>注解有如下的使用场景：<br><br>* 编译器信息— 编译器用注解检测到错误或抑制警告。<br>* 编译时和部署时的处理 — 软件工具可以处理注释的信息来生成代码，XML文件，等等。<br>* 运行时处理 — 有些注解是在运行时进行检查.<br><br>## 注解的格式<br><br>格式如下：<br><br>```<br>@Entity<br>```<br><br>符号`@`告诉编译器这是个注解。<br><br>注解可以包含有名字或者没有名字的元素（elements），如：<br><br>```<br>@Author(<br>   name = "Benjamin Franklin",<br>   date = "3/27/2003"<br>)<br>class MyClass() { ... }<br>```<br><br>或者<br><br>```<br>@SuppressWarnings(value = "unchecked")<br>void myMethod() { ... }<br>```<br><br>当只有一个元素名字是 value 时，该名字可以省略，如：<br><br>```<br>@SuppressWarnings("unchecked")<br>void myMethod() { ... }<br>```<br><br>若注解没有元素，则连圆括号都可以省略。<br><br>同一个声明可以用多个注解：<br><br>```<br>@Author(name = "Jane Doe")<br>@EBook<br>class MyClass { ... }<br>```<br><br>若注解包含相同的类型，则被称为重复注解(repeating annotation)：<br><br>```<br>@Author(name = "Jane Doe")<br>@Author(name = "John Smith")<br>class MyClass { ... }<br>```<br><br>重复注解是 Java SE 8 里面支持的。<br><br>## 注解使用的地方<br><br>注解可以应用到程序声明的类，字段，方法，和其他程序元素。当在一个声明中使用，按照惯例，每个注解经常会出现在它自己的行。<br><br>Java SE8 开始，注解也可以应用于类型使用（type use），称为类型注解（type annotation）。 这里有些例子：<br><br>* 类实例创建表达式<br><br>```<br>new @Interned MyObject()<br>```<br><br>* 类型投射<br><br>```<br>myString = (@NonNull String) str;<br>```<br><br>* 实现条款<br><br>```<br>class UnmodifiableList<T> implements<br>        @Readonly List<@Readonly T> { ... }<br>```<br><br>* 抛出异常声明<br><br>```<br>void monitorTemperature() throws<br>        @Critical TemperatureException { ... }<br>```<br><br>## 声明一个注解类型<br><br>许多注解取代了本来已经在代码中的注释。<br><br>假设传统的软件组在每个类的类体的开始，使用注释提供了重要的信息：<br><br>```java<br>public class Generation3List extends Generation2List {<br><br>   // Author: John Doe<br>   // Date: 3/17/2002<br>   // Current revision: 6<br>   // Last modified: 4/12/2004<br>   // By: Jane Doe<br>   // Reviewers: Alice, Bill, Cindy<br><br>   // class code goes here<br><br>}<br>```<br><br>使用注解提供一样的元数据，首先要声明一个注解类型，语法是：<br><br>```java<br>@interface ClassPreamble {<br>   String author();<br>   String date();<br>   int currentRevision() default 1;<br>   String lastModified() default "N/A";<br>   String lastModifiedBy() default "N/A";<br>   // Note use of array<br>   String[] reviewers();<br>}<br>```<br><br>注解的声明，就像在 interface 声明前面添加一个`@`字符(`@`是AT,即 Annotation Type)。注解类型，其实是接口的一种形式，后面会讲到。就目前而言，你不需要了解。<br><br>注解的声明的正文，包括注解元素的声明，看起来很像方法。注意，这里可以定义可选的默认值。<br><br>一旦注解定义好了，就可以在使用注解时，填充注解的值，就像这样：<br><br>```<br>@ClassPreamble (<br>   author = "John Doe",<br>   date = "3/17/2002",<br>   currentRevision = 6,<br>   lastModified = "4/12/2004",<br>   lastModifiedBy = "Jane Doe",<br>   // Note array notation<br>   reviewers = {"Alice", "Bob", "Cindy"}<br>)<br>public class Generation3List extends Generation2List {<br><br>// class code goes here<br><br>}<br>```<br><br>**注：**要让`@ClassPreamble`的信息出现在 Javadoc 生成的文档，必须使用`@Documented`注解定义`@ClassPreamble`<br><br>```java<br>// import this to use @Documented<br>import java.lang.annotation.*;<br><br>@Documented<br>@interface ClassPreamble {<br><br>   // Annotation element definitions<br>   <br>}<br>```<br><br>## 预定义注解的类型<br><br>有这么几种注解类型预定义在  Java SE API 了。一些注解类型是供 Java 编译器使用，一些是供其他注解使用。<br><br>### Java 语言使用的注解<br><br>定义在 java.lang 中的是  `@Deprecated`, `@Override`, 和 `@SuppressWarnings`<br><br>`@Deprecated`注解指示，标识的元素是废弃的(deprecated)，不应该再使用。编译器会在任何使用到`@Deprecated`的类，方法，字段的程序时产生警告。当元素是废弃的，它也应该使用 Javadoc 的 `@deprecated` 标识文档化，如下面的例子。两个Javadoc 注释和注解中的“@”符号的使用不是巧合 - 它们是相关的概念上。另外，请注意Javadoc标记开始用小写字母“d”和注解开始以大写字母“D”。<br><br>```<br>// Javadoc comment follows<br>    /**<br>     * @deprecated<br>     * explanation of why it was deprecated<br>     */<br>    @Deprecated<br>    static void deprecatedMethod() { }<br>}<br>```<br><br>`@Override`注解通知编译器，覆盖父类声明的元素。<br><br>```<br>// mark method as a superclass method<br>// that has been overridden<br>@Override <br>int overriddenMethod() { }<br>```<br><br>虽然不要求在覆盖方法时，必须使用注解，但是它可以避免错误。如果一个方法标记为`@Override`，但是无法正确覆盖父类的任何方法，编译器会产生错误。<br><br>`@SuppressWarnings`告诉编译器，抑制正常情况下会产生的特定的警告。下面的例子，一个废弃的方法被使用，编译器正常会产生警告，而这个情况下，这个注解导致警告会被抑制。<br><br>```java<br>// use a deprecated method and tell <br>// compiler not to generate a warning<br>@SuppressWarnings("deprecation")<br>void useDeprecatedMethod() {<br>    // deprecation warning<br>    // - suppressed<br>    objectOne.deprecatedMethod();<br>}<br>```<br><br>每个编译器的警告属于一个类别。Java 语言规范有两个类别："deprecation" 和"unchecked"。"unchecked" 会在使用以前的写的泛型的遗留代码进行交互时，产生警告。抑制更多类别的警告，使用下面的语法：<br><br>```<br>@SuppressWarnings({"unchecked", "deprecation"})<br>```<br><br>`@SafeVarargs`注解，当应用于方法或构造，断言代码不对其可变参数（varargs）的参数进行潜在的不安全操作。当使用这个注释类型时，与可变参数相关未检查警告被抑制。<br><br>`@FunctionalInterface`是在 Java SE 8 中引入，由 Java 语言规范定义的那样，表示该类型声明意在成为功能性的接口。<br><br>### 注解应用于其他注解<br><br>注解应用于其他注解称为元注解（ meta-annotations）。java.lang.annotation 中定义了多种元注解。<br><br>`@Retention` 注解指定了标记的注解如何存储：<br><br>* RetentionPolicy.SOURCE - 该标记注解只保留在源码级，而由编译器忽略。<br>* RetentionPolicy.CLASS - 该标记注释是由编译器在编译时保留，但由 Java 虚拟机（JVM）忽略。<br>* RetentionPolicy.RUNTIME - 该标记注解由JVM保留，因此可以使用在运行时环境。<br><br>`@Documented`注释表明，只要指定哪些元素应该使用 Javadoc 工具。 （默认情况下，注解不包括在 Javadoc 中。）有关详细信息，请参阅的 [Javadoc 工具页面](https://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/index.html)。<br><br>`@Target` 用于标记其他注解，限制什么样的 Java 元素的注解可以应用到。`@Target` 注解指定以下元素类型作为其值之一：<br><br>* ElementType.ANNOTATION_TYPE 可以应用于注释类型。<br>* ElementType.CONSTRUCTOR 可以应用于构造体。<br>* ElementType.FIELD 可以应用于一个字段或属性。<br>* ElementType.LOCAL_VARIABLE 可以应用到局部变量。<br>* ElementType.METHOD 可以应用于一方法级注释。<br>* ElementType.PACKAGE 可以应用到一个包声明。<br>* ElementType.PARAMETER 可以应用于方法的参数。<br>* ElementType.TYPE 可以应用于类的任意元素。<br><br>`@Inherited` 指示注释类型可以从超类继承。（默认不是 true）。当用户查询注释类型,类没有这种类型注释，此时从这个类的父类中查询注释类型。这个注释只适用于类的声明。<br><br>`@Repeatable`注解，在 Java SE 8 中引入的，表示该标记的注解可以多次应用到同一声明或类型使用。欲了解更多信息，请参阅重复注解。<br> <br>## 类型注解以及可拔插的类型系统<br><br>Java SE8 之前，注解只能用于声明，从 Java SE8 开始，注解也可以应用于类型使用（type use），称为类型注解（type annotation）。意味着，注解可以使用在任何使用的类型。<br><br>类型注解为 Java 程序提供了更强的类型检查分析。Java SE 8 版本不提供类​​型检查的框架，但它可以让你自己写（或下载）类型检查框架，该框架实现了与 Java 编译器一起使用的一个或多个可插拔模块。<br><br>例如，要确保在你的程序中一个特定变量从未被分配到 null ,从而避免引发NullPointerException 异常。您可以编写自定义插件来检查这一点。然后，您可以修改代码以注明这个特定变量，以表明它是永远不会分配给 null。变量声明可能是这样的：<br><br>```<br>@NonNull String str;<br>```<br><br>当您编译代码，包括在命令行中的 NonNull 模块，如果它检测到潜在的问题，编译器输出警告，让您可以修改代码以避免错误。在更正代码后，消除所有警告，当程序运行时不会发生此​​特定错误。<br><br>您可以使用多个类型检查的模块，每个模块检查不同类型的错误。通过这种方式，你可以建立在 Java 类型系统之上，随时随地添加您想要的特定检查。<br><br>通过明智地使用类型注解和可插拔的类型检查器，你写的代码，将更强大，更不易出错。<br><br>在很多情况下，你不必写自己的类型检查模块。第三方组织已经在做这个工作了。例如，华盛顿大学(the University of Washington)创建的  Checker Framework 。该框架包括一个 NonNull 模块，以及一个正则表达式模块和互斥锁模块。欲了解更多信息，请参见 [Checker Framework](http://types.cs.washington.edu/checker-framework/)。<br><br>## 重复注解<br><br>若注解包含相同的类型，则被称为重复注解(repeating annotation)，这个是 Java SE 8 之后所支持的。<br><br>比如，你正在编写的代码使用计时器服务，使您能够在特定的时间或在某个计划，类似于 UNIX cron 服务运行的方法。现在，你要设置一个计时器，在下午 11:00 运行的方法，doPeriodicCleanup，在每月和每周五的最后一天要设置定时运行，创建一个`@Schedule`注释，并两次将其应用到了 doPeriodicCleanup 方法。在第一次使用指定月的最后一天和第二指定星期五在下午11点，使用如下：<br><br>```<br>@Schedule(dayOfMonth="last")<br>@Schedule(dayOfWeek="Fri", hour="23")<br>public void doPeriodicCleanup() { ... }<br>```<br><br>上面的示例是将注解应用在方法上。你可以在任何使用标准的注解地方使用重复注解。例如，你有一个类来处理未授权的访问异常。有一个`@Alert`注解的类标注为管理人员和另一个用于管理员：<br><br>```<br>@Alert(role="Manager")<br>@Alert(role="Administrator")<br>public class UnauthorizedAccessException extends SecurityException { ... }<br>```<br><br>由于兼容性的原因，重复的注释被存储在一个由 Java 编译器自动产生的容器注解（container annotation）里。为了使编译器要做到这一点，你的代码里两个声明都需要。<br><br>### 第一步：声明一个重复注解<br><br>重复注解用 @Repeatable 元注解标记。下面例子定义一个自定义的 @Schedule 重复注解：<br><br>```<br>import java.lang.annotation.Repeatable;<br><br>@Repeatable(Schedules.class)<br>public @interface Schedule {<br>  String dayOfMonth() default "first";<br>  String dayOfWeek() default "Mon";<br>  int hour() default 12;<br>}<br>```<br><br>`@Repeatable`元注解的值是由 Java 编译器生成存储重复注解的容器注解的类型。在本例中，容器注解的类型是 Schedules，所以重复注解 `@Schedule` 被存储在`@Schedules` 注解中。<br><br>应用相同注解到声明但没有首先声明它是可重复的，则在编译时会出错。<br><br>### 步骤2：声明容器注解类型<br><br>容器注解类型必须有数组类型的元素 value,而数组类型的组件类型必须是重复注解类型，示例如下：<br><br>```<br>public @interface Schedules {<br>    Schedule[] value();<br>}<br>```<br><br>### 检索注解<br><br>反射 API 有几种方法可用于检索注解。返回单个注解的方法的行为，如[AnnotatedElement.getAnnotationByType(Class<T>)](https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AnnotatedElement.html#getAnnotationByType-java.lang.Class-)，如果所请求的类型的注解类型只存在一个则仅返回一个注解，则该行为是没有改变的。如果有多个请求类型的注解类型存在，则可以通过先得到他们的容器注解从而获取它们。这种方式下，传统代码继续工作。其他方法是在 Java SE 8 中，通过容器注释扫描到一次返回多个注解，如 [AnnotatedElement.getAnnotations(Class<T>)](https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AnnotatedElement.html#getAnnotations-java.lang.Class-)。见[AnnotatedElement](https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AnnotatedElement.html) 类的规范，查看所有的可用方法的信息。<br><br>### 设计考虑<br><br>当设计一个注解类型，你必须考虑到该类型的注解的基数(cardinality)。现在可以使用一个注释零次，一次，或者，如果注解的类型被标以`@Repeatable`，则不止一次。另外，也可以通过使用`@Target`元注解来限制注解类型在哪里使用。例如，您可以创建一个只能在方法和字段使用可重复的注解类型。精心设计的注解类型是非常重要的，要确保使用注解的程序员感觉越灵活和强大越好。</div></div>
			<nav>
				<ul class="pager">
				<li class='previous'><a href='8.html'>&larr; 类和对象</a></li>
			<li class='next'><a href='10.html'>泛型&rarr;</a></li>
				</ul>
			</nav>
</div>
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
			<!-- /.row -->
			  <hr>
        <!-- Footer -->
        <footer>
            <div class="row">
                <div class="col-xs-12">
                    <p>Copyright &copy; 小龙软件工作室 2016 粤icp备16103410</p>
                </div>
            </div>
        </footer>

    </div>
    <!-- /.container -->

    <!-- jQuery -->
    <script src="../../js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="../../js/bootstrap.min.js"></script>

</body>

</html>
