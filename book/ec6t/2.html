<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="content-type" content="text/html;charset=utf-8">
    <meta charset="utf-8">
<meta name="360-site-verification" content="cabcfb5a0f4c0d28d604e8a69e6c0cdb" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="baidu-site-verification" content="HknqsD2zhn" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>ECMAScript 6入门-编码助手网</title>
      <meta content="为编码人员提供在线文档、模板等帮助，提升解决问题效率" name="description">
			<meta content="ECMAScript 6入门 Java, spring, tomcat, servlet, jsp, api doc, bootstrap" name="keywords">
<meta name="sogou_site_verification" content="42nApEZFKO"/>


    <!-- Bootstrap Core CSS -->
    <link href="../../css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="../../css/heroic-features.css" rel="stylesheet">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
		<script>
		var _hmt = _hmt || [];
		(function() {
		  var hm = document.createElement("script");
		  hm.src = "//hm.baidu.com/hm.js?dd1361ca20a10cc161e72d4bc4fef6df";
		  var s = document.getElementsByTagName("script")[0];
		  s.parentNode.insertBefore(hm, s);
		})();
		</script>

</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">编码助手网</a>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav">
                    <li>
                        <a href="/">首页</a>
                    </li>
										<li>
                        <a href="/template.html">模板</a>
                    </li>
										<li>
												<a href="/doc.html">文档</a>
										</li>
                    <li>
                        <a href="/contact.html">联系我们</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Content -->
    <div class="container">

			<div class="row">
					<div class="col-xs-4">
						<h4>ECMAScript 6入门</h4>
						<h6>感谢Ruan YiFeng提供内容</h6>
<ul><li><a href='./0.html'>前言</a></li><li><a href='./1.html'>ECMAScript 6简介</a></li><li><a href='./2.html'>let和const命令</a></li><li><a href='./3.html'>变量的解构赋值</a></li><li><a href='./4.html'>字符串的扩展</a></li><li><a href='./5.html'>正则的扩展</a></li><li><a href='./6.html'>数值的扩展</a></li><li><a href='./7.html'>数组的扩展</a></li><li><a href='./8.html'>函数的扩展</a></li><li><a href='./9.html'>对象的扩展</a></li><li><a href='./10.html'>Symbol</a></li><li><a href='./11.html'>Proxy和Reflect</a></li><li><a href='./12.html'>Set和Map数据结构</a></li><li><a href='./13.html'>Iterator和for...of循环</a></li><li><a href='./14.html'>Generator函数</a></li><li><a href='./15.html'>Promise对象</a></li><li><a href='./16.html'>异步操作和Async函数</a></li><li><a href='./17.html'>Class</a></li><li><a href='./18.html'>Decorator</a></li><li><a href='./19.html'>Module</a></li><li><a href='./20.html'>编程风格</a></li><li><a href='./21.html'>读懂规格</a></li><li><a href='./22.html'>二进制数组</a></li><li><a href='./23.html'>SIMD</a></li><li><a href='./24.html'>参考链接</a></li><li></li>
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
<div class="col-xs-8">
	<nav>
		<ul class="pager">
			<li class='previous'><a href='1.html'>&larr; ECMAScript 6简介</a></li>
		<li class='next'><a href='3.html'>变量的解构赋值&rarr;</a></li>
		</ul>
	</nav>
			<div class="row"><div class="col-xs-12"># let和const命令<br><br>## let命令<br><br>### 基本用法<br><br>ES6新增了`let`命令，用来声明变量。它的用法类似于`var`，但是所声明的变量，只在`let`命令所在的代码块内有效。<br><br>```javascript<br>{<br>  let a = 10;<br>  var b = 1;<br>}<br><br>a // ReferenceError: a is not defined.<br>b // 1<br>```<br><br>上面代码在代码块之中，分别用`let`和`var`声明了两个变量。然后在代码块之外调用这两个变量，结果`let`声明的变量报错，`var`声明的变量返回了正确的值。这表明，`let`声明的变量只在它所在的代码块有效。<br><br>`for`循环的计数器，就很合适使用`let`命令。<br><br>```javascript<br>for (let i = 0; i < 10; i++) {}<br><br>console.log(i);<br>//ReferenceError: i is not defined<br>```<br><br>上面代码中，计数器`i`只在`for`循环体内有效，在循环体外引用就会报错。<br><br>下面的代码如果使用`var`，最后输出的是10。<br><br>```javascript<br>var a = [];<br>for (var i = 0; i < 10; i++) {<br>  a[i] = function () {<br>    console.log(i);<br>  };<br>}<br>a[6](); // 10<br>```<br><br>上面代码中，变量`i`是`var`声明的，在全局范围内都有效。所以每一次循环，新的`i`值都会覆盖旧值，导致最后输出的是最后一轮的`i`的值。<br><br>如果使用`let`，声明的变量仅在块级作用域内有效，最后输出的是6。<br><br>```javascript<br>var a = [];<br>for (let i = 0; i < 10; i++) {<br>  a[i] = function () {<br>    console.log(i);<br>  };<br>}<br>a[6](); // 6<br>```<br><br>上面代码中，变量`i`是`let`声明的，当前的`i`只在本轮循环有效，所以每一次循环的`i`其实都是一个新的变量，所以最后输出的是6。<br><br>### 不存在变量提升<br><br>`let`不像`var`那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错。<br><br>```javascript<br>console.log(foo); // 输出undefined<br>console.log(bar); // 报错ReferenceError<br><br>var foo = 2;<br>let bar = 2;<br>```<br><br>上面代码中，变量`foo`用`var`命令声明，会发生变量提升，即脚本开始运行时，变量`foo`已经存在了，但是没有值，所以会输出`undefined`。变量`bar`用`let`命令声明，不会发生变量提升。这表示在声明它之前，变量`bar`是不存在的，这时如果用到它，就会抛出一个错误。<br><br>### 暂时性死区<br><br>只要块级作用域内存在`let`命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。<br><br>```javascript<br>var tmp = 123;<br><br>if (true) {<br>  tmp = 'abc'; // ReferenceError<br>  let tmp;<br>}<br>```<br><br>上面代码中，存在全局变量`tmp`，但是块级作用域内`let`又声明了一个局部变量`tmp`，导致后者绑定这个块级作用域，所以在`let`声明变量前，对`tmp`赋值会报错。<br><br>ES6明确规定，如果区块中存在`let`和`const`命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。<br><br>总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）。<br><br>```javascript<br>if (true) {<br>  // TDZ开始<br>  tmp = 'abc'; // ReferenceError<br>  console.log(tmp); // ReferenceError<br><br>  let tmp; // TDZ结束<br>  console.log(tmp); // undefined<br><br>  tmp = 123;<br>  console.log(tmp); // 123<br>}<br>```<br><br>上面代码中，在`let`命令声明变量`tmp`之前，都属于变量`tmp`的“死区”。<br><br>“暂时性死区”也意味着`typeof`不再是一个百分之百安全的操作。<br><br>```javascript<br>typeof x; // ReferenceError<br>let x;<br>```<br><br>上面代码中，变量`x`使用`let`命令声明，所以在声明之前，都属于`x`的“死区”，只要用到该变量就会报错。因此，`typeof`运行时就会抛出一个`ReferenceError`。<br><br>作为比较，如果一个变量根本没有被声明，使用`typeof`反而不会报错。<br><br>```javascript<br>typeof undeclared_variable // "undefined"<br>```<br><br>上面代码中，`undeclared_variable`是一个不存在的变量名，结果返回“undefined”。所以，在没有`let`之前，`typeof`运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。<br><br>有些“死区”比较隐蔽，不太容易发现。<br><br>```javascript<br>function bar(x = y, y = 2) {<br>  return [x, y];<br>}<br><br>bar(); // 报错<br>```<br><br>上面代码中，调用`bar`函数之所以报错（某些实现可能不报错），是因为参数`x`默认值等于另一个参数`y`，而此时`y`还没有声明，属于”死区“。如果`y`的默认值是`x`，就不会报错，因为此时`x`已经声明了。<br><br>```javascript<br>function bar(x = 2, y = x) {<br>  return [x, y];<br>}<br>bar(); // [2, 2]<br>```<br><br>ES6规定暂时性死区和`let`、`const`语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在ES5是很常见的，现在有了这种规定，避免此类错误就很容易了。<br><br>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。<br><br>### 不允许重复声明<br><br>let不允许在相同作用域内，重复声明同一个变量。<br><br>```javascript<br>// 报错<br>function () {<br>  let a = 10;<br>  var a = 1;<br>}<br><br>// 报错<br>function () {<br>  let a = 10;<br>  let a = 1;<br>}<br>```<br><br>因此，不能在函数内部重新声明参数。<br><br>```javascript<br>function func(arg) {<br>  let arg; // 报错<br>}<br><br>function func(arg) {<br>  {<br>    let arg; // 不报错<br>  }<br>}<br>```<br><br>## 块级作用域<br><br>### 为什么需要块级作用域？<br><br>ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。<br><br>第一种场景，内层变量可能会覆盖外层变量。<br><br>```javascript<br>var tmp = new Date();<br><br>function f() {<br>  console.log(tmp);<br>  if (false) {<br>    var tmp = "hello world";<br>  }<br>}<br><br>f(); // undefined<br>```<br><br>上面代码中，函数f执行后，输出结果为`undefined`，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。<br><br>第二种场景，用来计数的循环变量泄露为全局变量。<br><br>```javascript<br>var s = 'hello';<br><br>for (var i = 0; i < s.length; i++) {<br>  console.log(s[i]);<br>}<br><br>console.log(i); // 5<br>```<br><br>上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。<br><br>### ES6的块级作用域<br><br>`let`实际上为JavaScript新增了块级作用域。<br><br>```javascript<br>function f1() {<br>  let n = 5;<br>  if (true) {<br>    let n = 10;<br>  }<br>  console.log(n); // 5<br>}<br>```<br><br>上面的函数有两个代码块，都声明了变量`n`，运行后输出5。这表示外层代码块不受内层代码块的影响。如果使用`var`定义变量`n`，最后输出的值就是10。<br><br>ES6允许块级作用域的任意嵌套。<br><br>```javascript<br>{{{{{let insane = 'Hello World'}}}}};<br>```<br><br>上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。<br><br>```javascript<br>{{{{<br>  {let insane = 'Hello World'}<br>  console.log(insane); // 报错<br>}}}};<br>```<br><br>内层作用域可以定义外层作用域的同名变量。<br><br>```javascript<br>{{{{<br>  let insane = 'Hello World';<br>  {let insane = 'Hello World'}<br>}}}};<br>```<br><br>块级作用域的出现，实际上使得获得广泛应用的立即执行匿名函数（IIFE）不再必要了。<br><br>```javascript<br>// IIFE写法<br>(function () {<br>  var tmp = ...;<br>  ...<br>}());<br><br>// 块级作用域写法<br>{<br>  let tmp = ...;<br>  ...<br>}<br>```<br><br>### 块级作用域与函数声明<br><br>函数能不能在块级作用域之中声明，是一个相当令人混淆的问题。<br><br>ES5规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。<br><br>```javascript<br>// 情况一<br>if (true) {<br>  function f() {}<br>}<br><br>// 情况二<br>try {<br>  function f() {}<br>} catch(e) {<br>}<br>```<br><br>上面代码的两种函数声明，根据ES5的规定都是非法的。<br><br>但是，浏览器没有遵守这个规定，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。不过，“严格模式”下还是会报错。<br><br>```javascript<br>// ES5严格模式<br>'use strict';<br>if (true) {<br>  function f() {}<br>}<br>// 报错<br>```<br><br>ES6引入了块级作用域，明确允许在块级作用域之中声明函数。<br><br>```javascript<br>// ES6严格模式<br>'use strict';<br>if (true) {<br>  function f() {}<br>}<br>// 不报错<br>```<br><br>并且ES6规定，块级作用域之中，函数声明语句的行为类似于`let`，在块级作用域之外不可引用。<br><br>```javascript<br>function f() { console.log('I am outside!'); }<br>(function () {<br>  if (false) {<br>    // 重复声明一次函数f<br>    function f() { console.log('I am inside!'); }<br>  }<br><br>  f();<br>}());<br>```<br><br>上面代码在ES5中运行，会得到“I am inside!”，因为在`if`内声明的函数`f`会被提升到函数头部，实际运行的代码如下。<br><br>```javascript<br>// ES5版本<br>function f() { console.log('I am outside!'); }<br>(function () {<br>  function f() { console.log('I am inside!'); }<br>  if (false) {<br>  }<br>  f();<br>}());<br>```<br><br>ES6的运行结果就完全不一样了，会得到“I am outside!”。因为块级作用域内声明的函数类似于`let`，对作用域之外没有影响，实际运行的代码如下。<br><br>```javascript<br>// ES6版本<br>function f() { console.log('I am outside!'); }<br>(function () {<br>  f();<br>}());<br>```<br><br>很显然，这种行为差异会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6在[附录B](http://www.ecma-international.org/ecma-262/6.0/index.html#sec-block-level-function-declarations-web-legacy-compatibility-semantics)里面规定，浏览器的实现可以不遵守上面的规定，有自己的[行为方式](http://stackoverflow.com/questions/31419897/what-are-the-precise-semantics-of-block-level-functions-in-es6)。<br><br>- 允许在块级作用域内声明函数。<br>- 函数声明类似于`var`，即会提升到全局作用域或函数作用域的头部。<br>- 同时，函数声明还会提升到所在的块级作用域的头部。<br><br>注意，上面三条规则只对ES6的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作`let`处理。<br><br>前面那段代码，在Chrome环境下运行会报错。<br><br>```javascript<br>// ES6的浏览器环境<br>function f() { console.log('I am outside!'); }<br>(function () {<br>  if (false) {<br>    // 重复声明一次函数f<br>    function f() { console.log('I am inside!'); }<br>  }<br><br>  f();<br>}());<br>// Uncaught TypeError: f is not a function<br>```<br><br>上面的代码报错，是因为实际运行的是下面的代码。<br><br>```javascript<br>// ES6的浏览器环境<br>function f() { console.log('I am outside!'); }<br>(function () {<br>  var f = undefined;<br>  if (false) {<br>    function f() { console.log('I am inside!'); }<br>  }<br><br>  f();<br>}());<br>// Uncaught TypeError: f is not a function<br>```<br><br>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。<br><br>```javascript<br>// 函数声明语句<br>{<br>  let a = 'secret';<br>  function f() {<br>    return a;<br>  }<br>}<br><br>// 函数表达式<br>{<br>  let a = 'secret';<br>  let f = function () {<br>    return a;<br>  };<br>}<br>```<br><br>另外，还有一个需要注意的地方。ES6的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。<br><br>```javascript<br>// 不报错<br>'use strict';<br>if (true) {<br>  function f() {}<br>}<br><br>// 报错<br>'use strict';<br>if (true)<br>  function f() {}<br>```<br><br>## const命令<br><br>`const`声明一个只读的常量。一旦声明，常量的值就不能改变。<br><br>```javascript<br>const PI = 3.1415;<br>PI // 3.1415<br><br>PI = 3;<br>// TypeError: Assignment to constant variable.<br>```<br><br>上面代码表明改变常量的值会报错。<br><br>`const`声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。<br><br>```javascript<br>const foo;<br>// SyntaxError: Missing initializer in const declaration<br>```<br><br>上面代码表示，对于`const`来说，只声明不赋值，就会报错。<br><br>`const`的作用域与`let`命令相同：只在声明所在的块级作用域内有效。<br><br>```javascript<br>if (true) {<br>  const MAX = 5;<br>}<br><br>MAX // Uncaught ReferenceError: MAX is not defined<br>```<br><br>`const`命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。<br><br>```javascript<br>if (true) {<br>  console.log(MAX); // ReferenceError<br>  const MAX = 5;<br>}<br>```<br><br>上面代码在常量`MAX`声明之前就调用，结果报错。<br><br>`const`声明的常量，也与`let`一样不可重复声明。<br><br>```javascript<br>var message = "Hello!";<br>let age = 25;<br><br>// 以下两行都会报错<br>const message = "Goodbye!";<br>const age = 30;<br>```<br><br>对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。`const`命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。<br><br>```javascript<br>const foo = {};<br>foo.prop = 123;<br><br>foo.prop<br>// 123<br><br>foo = {}; // TypeError: "foo" is read-only<br>```<br><br>上面代码中，常量`foo`储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把`foo`指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。<br><br>下面是另一个例子。<br><br>```js<br>const a = [];<br>a.push('Hello'); // 可执行<br>a.length = 0;    // 可执行<br>a = ['Dave'];    // 报错<br>```<br><br>上面代码中，常量`a`是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给`a`，就会报错。<br><br>如果真的想将对象冻结，应该使用`Object.freeze`方法。<br><br>```javascript<br>const foo = Object.freeze({});<br><br>// 常规模式时，下面一行不起作用；<br>// 严格模式时，该行会报错<br>foo.prop = 123;<br>```<br><br>上面代码中，常量`foo`指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。<br><br>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。<br><br>```javascript<br>var constantize = (obj) => {<br>  Object.freeze(obj);<br>  Object.keys(obj).forEach( (key, value) => {<br>    if ( typeof obj[key] === 'object' ) {<br>      constantize( obj[key] );<br>    }<br>  });<br>};<br>```<br><br>ES5只有两种声明变量的方法：`var`命令和`function`命令。ES6除了添加`let`和`const`命令，后面章节还会提到，另外两种声明变量的方法：`import`命令和`class`命令。所以，ES6一共有6种声明变量的方法。<br><br>## 顶层对象的属性<br><br>顶层对象，在浏览器环境指的是`window`对象，在Node指的是`global`对象。ES5之中，顶层对象的属性与全局变量是等价的。<br><br>```javascript<br>window.a = 1;<br>a // 1<br><br>a = 2;<br>window.a // 2<br>```<br><br>上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。<br><br>顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，`window`对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。<br><br>ES6为了改变这一点，一方面规定，为了保持兼容性，`var`命令和`function`命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，`let`命令、`const`命令、`class`命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。<br><br>```javascript<br>var a = 1;<br>// 如果在Node的REPL环境，可以写成global.a<br>// 或者采用通用方法，写成this.a<br>window.a // 1<br><br>let b = 1;<br>window.b // undefined<br>```<br><br>上面代码中，全局变量`a`由`var`命令声明，所以它是顶层对象的属性；全局变量`b`由`let`命令声明，所以它不是顶层对象的属性，返回`undefined`。<br><br>## 顶层对象<br><br>ES5的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。<br><br>- 浏览器里面，顶层对象是`window`，但Node和Web Worker没有`window`。<br>- 浏览器和Web Worker里面，`self`也指向顶层对象，但是Node没有`self`。<br>- Node里面，顶层对象是`global`，但其他环境都不支持。<br><br>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用`this`变量，但是有局限性。<br><br>- 全局环境中，`this`会返回顶层对象。但是，Node模块和ES6模块中，`this`返回的是当前模块。<br>- 函数里面的`this`，如果函数不是作为对象的方法运行，而是单纯作为函数运行，`this`会指向顶层对象。但是，严格模式下，这时`this`会返回`undefined`。<br>- 不管是严格模式，还是普通模式，`new Function('return this')()`，总是会返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全政策），那么`eval`、`new Function`这些方法都可能无法使用。<br><br>综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。<br><br>```javascript<br>// 方法一<br>(typeof window !== 'undefined'<br>   ? window<br>   : (typeof process === 'object' &&<br>      typeof require === 'function' &&<br>      typeof global === 'object')<br>     ? global<br>     : this);<br><br>// 方法二<br>var getGlobal = function () {<br>  if (typeof self !== 'undefined') { return self; }<br>  if (typeof window !== 'undefined') { return window; }<br>  if (typeof global !== 'undefined') { return global; }<br>  throw new Error('unable to locate global object');<br>};<br>```<br><br>现在有一个[提案](https://github.com/tc39/proposal-global)，在语言标准的层面，引入`global`作为顶层对象。也就是说，在所有环境下，`global`都是存在的，都可以从它拿到顶层对象。<br><br>垫片库[`system.global`](https://github.com/ljharb/System.global)模拟了这个提案，可以在所有环境拿到`global`。<br><br>```javascript<br>// CommonJS的写法<br>require('system.global/shim')();<br><br>// ES6模块的写法<br>import shim from 'system.global/shim'; shim();<br>```<br><br>上面代码可以保证各种环境里面，`global`对象都是存在的。<br><br>```javascript<br>// CommonJS的写法<br>var global = require('system.global')();<br><br>// ES6模块的写法<br>import getGlobal from 'system.global';<br>const global = getGlobal();<br>```<br><br>上面代码将顶层对象放入变量`global`。<br><br></div></div>
			<nav>
				<ul class="pager">
				<li class='previous'><a href='1.html'>&larr; ECMAScript 6简介</a></li>
			<li class='next'><a href='3.html'>变量的解构赋值&rarr;</a></li>
				</ul>
			</nav>
</div>
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
			<!-- /.row -->
			  <hr>
        <!-- Footer -->
        <footer>
            <div class="row">
                <div class="col-xs-12">
                    <p>Copyright &copy; 小龙软件工作室 2016 粤icp备16103410</p>
                </div>
            </div>
        </footer>

    </div>
    <!-- /.container -->

    <!-- jQuery -->
    <script src="../../js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="../../js/bootstrap.min.js"></script>

</body>

</html>
