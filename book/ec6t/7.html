<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="content-type" content="text/html;charset=utf-8">
    <meta charset="utf-8">
<meta name="360-site-verification" content="cabcfb5a0f4c0d28d604e8a69e6c0cdb" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="baidu-site-verification" content="HknqsD2zhn" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>ECMAScript 6入门-编码助手网</title>
      <meta content="为编码人员提供在线文档、模板等帮助，提升解决问题效率" name="description">
			<meta content="ECMAScript 6入门 Java, spring, tomcat, servlet, jsp, api doc, bootstrap" name="keywords">
<meta name="sogou_site_verification" content="42nApEZFKO"/>


    <!-- Bootstrap Core CSS -->
    <link href="../../css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="../../css/heroic-features.css" rel="stylesheet">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
		<script>
		var _hmt = _hmt || [];
		(function() {
		  var hm = document.createElement("script");
		  hm.src = "//hm.baidu.com/hm.js?dd1361ca20a10cc161e72d4bc4fef6df";
		  var s = document.getElementsByTagName("script")[0];
		  s.parentNode.insertBefore(hm, s);
		})();
		</script>

</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">编码助手网</a>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav">
                    <li>
                        <a href="/">首页</a>
                    </li>
										<li>
                        <a href="/template.html">模板</a>
                    </li>
										<li>
												<a href="/doc.html">文档</a>
										</li>
                    <li>
                        <a href="/contact.html">联系我们</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Content -->
    <div class="container">

			<div class="row">
					<div class="col-xs-4">
						<h4>ECMAScript 6入门</h4>
						<h6>感谢Ruan YiFeng提供内容</h6>
<ul><li><a href='./0.html'>前言</a></li><li><a href='./1.html'>ECMAScript 6简介</a></li><li><a href='./2.html'>let和const命令</a></li><li><a href='./3.html'>变量的解构赋值</a></li><li><a href='./4.html'>字符串的扩展</a></li><li><a href='./5.html'>正则的扩展</a></li><li><a href='./6.html'>数值的扩展</a></li><li><a href='./7.html'>数组的扩展</a></li><li><a href='./8.html'>函数的扩展</a></li><li><a href='./9.html'>对象的扩展</a></li><li><a href='./10.html'>Symbol</a></li><li><a href='./11.html'>Proxy和Reflect</a></li><li><a href='./12.html'>Set和Map数据结构</a></li><li><a href='./13.html'>Iterator和for...of循环</a></li><li><a href='./14.html'>Generator函数</a></li><li><a href='./15.html'>Promise对象</a></li><li><a href='./16.html'>异步操作和Async函数</a></li><li><a href='./17.html'>Class</a></li><li><a href='./18.html'>Decorator</a></li><li><a href='./19.html'>Module</a></li><li><a href='./20.html'>编程风格</a></li><li><a href='./21.html'>读懂规格</a></li><li><a href='./22.html'>二进制数组</a></li><li><a href='./23.html'>SIMD</a></li><li><a href='./24.html'>参考链接</a></li><li></li>
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
<div class="col-xs-8">
	<nav>
		<ul class="pager">
			<li class='previous'><a href='6.html'>&larr; 数值的扩展</a></li>
		<li class='next'><a href='8.html'>函数的扩展&rarr;</a></li>
		</ul>
	</nav>
			<div class="row"><div class="col-xs-12"># 数组的扩展<br><br>## Array.from()<br><br>`Array.from`方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。<br><br>下面是一个类似数组的对象，`Array.from`将它转为真正的数组。<br><br>```javascript<br>let arrayLike = {<br>    '0': 'a',<br>    '1': 'b',<br>    '2': 'c',<br>    length: 3<br>};<br><br>// ES5的写法<br>var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']<br><br>// ES6的写法<br>let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']<br>```<br><br>实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的`arguments`对象。`Array.from`都可以将它们转为真正的数组。<br><br>```javascript<br>// NodeList对象<br>let ps = document.querySelectorAll('p');<br>Array.from(ps).forEach(function (p) {<br>  console.log(p);<br>});<br><br>// arguments对象<br>function foo() {<br>  var args = Array.from(arguments);<br>  // ...<br>}<br>```<br><br>上面代码中，`querySelectorAll`方法返回的是一个类似数组的对象，只有将这个对象转为真正的数组，才能使用`forEach`方法。<br><br>只要是部署了Iterator接口的数据结构，`Array.from`都能将其转为数组。<br><br>```javascript<br>Array.from('hello')<br>// ['h', 'e', 'l', 'l', 'o']<br><br>let namesSet = new Set(['a', 'b'])<br>Array.from(namesSet) // ['a', 'b']<br>```<br><br>上面代码中，字符串和Set结构都具有Iterator接口，因此可以被`Array.from`转为真正的数组。<br><br>如果参数是一个真正的数组，`Array.from`会返回一个一模一样的新数组。<br><br>```javascript<br>Array.from([1, 2, 3])<br>// [1, 2, 3]<br>```<br><br>值得提醒的是，扩展运算符（`...`）也可以将某些数据结构转为数组。<br><br>```javascript<br>// arguments对象<br>function foo() {<br>  var args = [...arguments];<br>}<br><br>// NodeList对象<br>[...document.querySelectorAll('div')]<br>```<br><br>扩展运算符背后调用的是遍历器接口（`Symbol.iterator`），如果一个对象没有部署这个接口，就无法转换。`Array.from`方法则是还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有`length`属性。因此，任何有`length`属性的对象，都可以通过`Array.from`方法转为数组，而此时扩展运算符就无法转换。<br><br>```javascript<br>Array.from({ length: 3 });<br>// [ undefined, undefined, undefined ]<br>```<br><br>上面代码中，`Array.from`返回了一个具有三个成员的数组，每个位置的值都是`undefined`。扩展运算符转换不了这个对象。<br><br>对于还没有部署该方法的浏览器，可以用`Array.prototype.slice`方法替代。<br><br>```javascript<br>const toArray = (() =><br>  Array.from ? Array.from : obj => [].slice.call(obj)<br>)();<br>```<br><br>`Array.from`还可以接受第二个参数，作用类似于数组的`map`方法，用来对每个元素进行处理，将处理后的值放入返回的数组。<br><br>```javascript<br>Array.from(arrayLike, x => x * x);<br>// 等同于<br>Array.from(arrayLike).map(x => x * x);<br><br>Array.from([1, 2, 3], (x) => x * x)<br>// [1, 4, 9]<br>```<br><br>下面的例子是取出一组DOM节点的文本内容。<br><br>```javascript<br>let spans = document.querySelectorAll('span.name');<br><br>// map()<br>let names1 = Array.prototype.map.call(spans, s => s.textContent);<br><br>// Array.from()<br>let names2 = Array.from(spans, s => s.textContent)<br>```<br><br>下面的例子将数组中布尔值为`false`的成员转为`0`。<br><br>```javascript<br>Array.from([1, , 2, , 3], (n) => n || 0)<br>// [1, 0, 2, 0, 3]<br>```<br><br>另一个例子是返回各种数据的类型。<br><br>```javascript<br>function typesOf () {<br>  return Array.from(arguments, value => typeof value)<br>}<br>typesOf(null, [], NaN)<br>// ['object', 'object', 'number']<br>```<br><br>如果`map`函数里面用到了`this`关键字，还可以传入`Array.from`的第三个参数，用来绑定`this`。<br><br>`Array.from()`可以将各种值转为真正的数组，并且还提供`map`功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。<br><br>```javascript<br>Array.from({ length: 2 }, () => 'jack')<br>// ['jack', 'jack']<br>```<br><br>上面代码中，`Array.from`的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法变得非常灵活。<br><br>`Array.from()`的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种Unicode字符，可以避免JavaScript将大于`\uFFFF`的Unicode字符，算作两个字符的bug。<br><br>```javascript<br>function countSymbols(string) {<br>  return Array.from(string).length;<br>}<br>```<br><br>## Array.of()<br><br>`Array.of`方法用于将一组值，转换为数组。<br><br>```javascript<br>Array.of(3, 11, 8) // [3,11,8]<br>Array.of(3) // [3]<br>Array.of(3).length // 1<br>```<br><br>这个方法的主要目的，是弥补数组构造函数`Array()`的不足。因为参数个数的不同，会导致`Array()`的行为有差异。<br><br>```javascript<br>Array() // []<br>Array(3) // [, , ,]<br>Array(3, 11, 8) // [3, 11, 8]<br>```<br><br>上面代码中，`Array`方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于2个时，`Array()`才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。<br><br>`Array.of`基本上可以用来替代`Array()`或`new Array()`，并且不存在由于参数不同而导致的重载。它的行为非常统一。<br><br>```javascript<br>Array.of() // []<br>Array.of(undefined) // [undefined]<br>Array.of(1) // [1]<br>Array.of(1, 2) // [1, 2]<br>```<br><br>`Array.of`总是返回参数值组成的数组。如果没有参数，就返回一个空数组。<br><br>`Array.of`方法可以用下面的代码模拟实现。<br><br>```javascript<br>function ArrayOf(){<br>  return [].slice.call(arguments);<br>}<br>```<br><br>## 数组实例的copyWithin()<br><br>数组实例的`copyWithin`方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。<br><br>```javascript<br>Array.prototype.copyWithin(target, start = 0, end = this.length)<br>```<br><br>它接受三个参数。<br><br>- target（必需）：从该位置开始替换数据。<br>- start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。<br>- end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。<br><br>这三个参数都应该是数值，如果不是，会自动转为数值。<br><br>```javascript<br>[1, 2, 3, 4, 5].copyWithin(0, 3)<br>// [4, 5, 3, 4, 5]<br>```<br><br>上面代码表示将从3号位直到数组结束的成员（4和5），复制到从0号位开始的位置，结果覆盖了原来的1和2。<br><br>下面是更多例子。<br><br>```javascript<br>// 将3号位复制到0号位<br>[1, 2, 3, 4, 5].copyWithin(0, 3, 4)<br>// [4, 2, 3, 4, 5]<br><br>// -2相当于3号位，-1相当于4号位<br>[1, 2, 3, 4, 5].copyWithin(0, -2, -1)<br>// [4, 2, 3, 4, 5]<br><br>// 将3号位复制到0号位<br>[].copyWithin.call({length: 5, 3: 1}, 0, 3)<br>// {0: 1, 3: 1, length: 5}<br><br>// 将2号位到数组结束，复制到0号位<br>var i32a = new Int32Array([1, 2, 3, 4, 5]);<br>i32a.copyWithin(0, 2);<br>// Int32Array [3, 4, 5, 4, 5]<br><br>// 对于没有部署TypedArray的copyWithin方法的平台<br>// 需要采用下面的写法<br>[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);<br>// Int32Array [4, 2, 3, 4, 5]<br>```<br><br>## 数组实例的find()和findIndex()<br><br>数组实例的`find`方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为`true`的成员，然后返回该成员。如果没有符合条件的成员，则返回`undefined`。<br><br>```javascript<br>[1, 4, -5, 10].find((n) => n < 0)<br>// -5<br>```<br><br>上面代码找出数组中第一个小于0的成员。<br><br>```javascript<br>[1, 5, 10, 15].find(function(value, index, arr) {<br>  return value > 9;<br>}) // 10<br>```<br><br>上面代码中，`find`方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。<br><br>数组实例的`findIndex`方法的用法与`find`方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回`-1`。<br><br>```javascript<br>[1, 5, 10, 15].findIndex(function(value, index, arr) {<br>  return value > 9;<br>}) // 2<br>```<br><br>这两个方法都可以接受第二个参数，用来绑定回调函数的`this`对象。<br><br>另外，这两个方法都可以发现`NaN`，弥补了数组的`IndexOf`方法的不足。<br><br>```javascript<br>[NaN].indexOf(NaN)<br>// -1<br><br>[NaN].findIndex(y => Object.is(NaN, y))<br>// 0<br>```<br><br>上面代码中，`indexOf`方法无法识别数组的`NaN`成员，但是`findIndex`方法可以借助`Object.is`方法做到。<br><br>## 数组实例的fill()<br><br>`fill`方法使用给定值，填充一个数组。<br><br>```javascript<br>['a', 'b', 'c'].fill(7)<br>// [7, 7, 7]<br><br>new Array(3).fill(7)<br>// [7, 7, 7]<br>```<br><br>上面代码表明，`fill`方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。<br><br>`fill`方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。<br><br>```javascript<br>['a', 'b', 'c'].fill(7, 1, 2)<br>// ['a', 7, 'c']<br>```<br><br>上面代码表示，`fill`方法从1号位开始，向原数组填充7，到2号位之前结束。<br><br>## 数组实例的entries()，keys()和values()<br><br>ES6提供三个新的方法——`entries()`，`keys()`和`values()`——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用`for...of`循环进行遍历，唯一的区别是`keys()`是对键名的遍历、`values()`是对键值的遍历，`entries()`是对键值对的遍历。<br><br>```javascript<br>for (let index of ['a', 'b'].keys()) {<br>  console.log(index);<br>}<br>// 0<br>// 1<br><br>for (let elem of ['a', 'b'].values()) {<br>  console.log(elem);<br>}<br>// 'a'<br>// 'b'<br><br>for (let [index, elem] of ['a', 'b'].entries()) {<br>  console.log(index, elem);<br>}<br>// 0 "a"<br>// 1 "b"<br>```<br><br>如果不使用`for...of`循环，可以手动调用遍历器对象的`next`方法，进行遍历。<br><br>```javascript<br>let letter = ['a', 'b', 'c'];<br>let entries = letter.entries();<br>console.log(entries.next().value); // [0, 'a']<br>console.log(entries.next().value); // [1, 'b']<br>console.log(entries.next().value); // [2, 'c']<br>```<br><br>## 数组实例的includes()<br><br>`Array.prototype.includes`方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的`includes`方法类似。该方法属于ES7，但Babel转码器已经支持。<br><br>```javascript<br>[1, 2, 3].includes(2);     // true<br>[1, 2, 3].includes(4);     // false<br>[1, 2, NaN].includes(NaN); // true<br>```<br><br>该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。<br><br>```javascript<br>[1, 2, 3].includes(3, 3);  // false<br>[1, 2, 3].includes(3, -1); // true<br>```<br><br>没有该方法之前，我们通常使用数组的`indexOf`方法，检查是否包含某个值。<br><br>```javascript<br>if (arr.indexOf(el) !== -1) {<br>  // ...<br>}<br>```<br><br>`indexOf`方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相当运算符（===）进行判断，这会导致对`NaN`的误判。<br><br>```javascript<br>[NaN].indexOf(NaN)<br>// -1<br>```<br><br>`includes`使用的是不一样的判断算法，就没有这个问题。<br><br>```javascript<br>[NaN].includes(NaN)<br>// true<br>```<br><br>下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。<br><br>```javascript<br>const contains = (() =><br>  Array.prototype.includes<br>    ? (arr, value) => arr.includes(value)<br>    : (arr, value) => arr.some(el => el === value)<br>)();<br>contains(["foo", "bar"], "baz"); // => false<br>```<br><br>另外，Map和Set数据结构有一个`has`方法，需要注意与`includes`区分。<br><br>- Map结构的`has`方法，是用来查找键名的，比如`Map.prototype.has(key)`、`WeakMap.prototype.has(key)`、`Reflect.has(target, propertyKey)`。<br>- Set结构的`has`方法，是用来查找值的，比如`Set.prototype.has(value)`、`WeakSet.prototype.has(value)`。<br><br>## 数组的空位<br><br>数组的空位指，数组的某一个位置没有任何值。比如，`Array`构造函数返回的数组都是空位。<br><br>```javascript<br>Array(3) // [, , ,]<br>```<br><br>上面代码中，`Array(3)`返回一个具有3个空位的数组。<br><br>注意，空位不是`undefined`，一个位置的值等于`undefined`，依然是有值的。空位是没有任何值，`in`运算符可以说明这一点。<br><br>```javascript<br>0 in [undefined, undefined, undefined] // true<br>0 in [, , ,] // false<br>```<br><br>上面代码说明，第一个数组的0号位置是有值的，第二个数组的0号位置没有值。<br><br>ES5对空位的处理，已经很不一致了，大多数情况下会忽略空位。<br><br>- `forEach()`, `filter()`, `every()` 和`some()`都会跳过空位。<br>- `map()`会跳过空位，但会保留这个值<br>- `join()`和`toString()`会将空位视为`undefined`，而`undefined`和`null`会被处理成空字符串。<br><br>```javascript<br>// forEach方法<br>[,'a'].forEach((x,i) => console.log(i)); // 1<br><br>// filter方法<br>['a',,'b'].filter(x => true) // ['a','b']<br><br>// every方法<br>[,'a'].every(x => x==='a') // true<br><br>// some方法<br>[,'a'].some(x => x !== 'a') // false<br><br>// map方法<br>[,'a'].map(x => 1) // [,1]<br><br>// join方法<br>[,'a',undefined,null].join('#') // "#a##"<br><br>// toString方法<br>[,'a',undefined,null].toString() // ",a,,"<br>```<br><br>ES6则是明确将空位转为`undefined`。<br><br>`Array.from`方法会将数组的空位，转为`undefined`，也就是说，这个方法不会忽略空位。<br><br>```javascript<br>Array.from(['a',,'b'])<br>// [ "a", undefined, "b" ]<br>```<br><br>扩展运算符（`...`）也会将空位转为`undefined`。<br><br>```javascript<br>[...['a',,'b']]<br>// [ "a", undefined, "b" ]<br>```<br><br>`copyWithin()`会连空位一起拷贝。<br><br>```javascript<br>[,'a','b',,].copyWithin(2,0) // [,"a",,"a"]<br>```<br><br>`fill()`会将空位视为正常的数组位置。<br><br>```javascript<br>new Array(3).fill('a') // ["a","a","a"]<br>```<br><br>`for...of`循环也会遍历空位。<br><br>```javascript<br>let arr = [, ,];<br>for (let i of arr) {<br>  console.log(1);<br>}<br>// 1<br>// 1<br>```<br><br>上面代码中，数组`arr`有两个空位，`for...of`并没有忽略它们。如果改成`map`方法遍历，空位是会跳过的。<br><br>`entries()`、`keys()`、`values()`、`find()`和`findIndex()`会将空位处理成`undefined`。<br><br>```javascript<br>// entries()<br>[...[,'a'].entries()] // [[0,undefined], [1,"a"]]<br><br>// keys()<br>[...[,'a'].keys()] // [0,1]<br><br>// values()<br>[...[,'a'].values()] // [undefined,"a"]<br><br>// find()<br>[,'a'].find(x => true) // undefined<br><br>// findIndex()<br>[,'a'].findIndex(x => true) // 0<br>```<br><br>由于空位的处理规则非常不统一，所以建议避免出现空位。<br><br></div></div>
			<nav>
				<ul class="pager">
				<li class='previous'><a href='6.html'>&larr; 数值的扩展</a></li>
			<li class='next'><a href='8.html'>函数的扩展&rarr;</a></li>
				</ul>
			</nav>
</div>
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
			<!-- /.row -->
			  <hr>
        <!-- Footer -->
        <footer>
            <div class="row">
                <div class="col-xs-12">
                    <p>Copyright &copy; 小龙软件工作室 2016 粤icp备16103410</p>
                </div>
            </div>
        </footer>

    </div>
    <!-- /.container -->

    <!-- jQuery -->
    <script src="../../js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="../../js/bootstrap.min.js"></script>

</body>

</html>
