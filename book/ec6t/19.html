<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="content-type" content="text/html;charset=utf-8">
    <meta charset="utf-8">
<meta name="360-site-verification" content="cabcfb5a0f4c0d28d604e8a69e6c0cdb" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="baidu-site-verification" content="HknqsD2zhn" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>ECMAScript 6入门-编码助手网</title>
      <meta content="为编码人员提供在线文档、模板等帮助，提升解决问题效率" name="description">
			<meta content="ECMAScript 6入门 Java, spring, tomcat, servlet, jsp, api doc, bootstrap" name="keywords">
<meta name="sogou_site_verification" content="42nApEZFKO"/>


    <!-- Bootstrap Core CSS -->
    <link href="../../css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="../../css/heroic-features.css" rel="stylesheet">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
		<script>
		var _hmt = _hmt || [];
		(function() {
		  var hm = document.createElement("script");
		  hm.src = "//hm.baidu.com/hm.js?dd1361ca20a10cc161e72d4bc4fef6df";
		  var s = document.getElementsByTagName("script")[0];
		  s.parentNode.insertBefore(hm, s);
		})();
		</script>

</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">编码助手网</a>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav">
                    <li>
                        <a href="/">首页</a>
                    </li>
										<li>
                        <a href="/template.html">模板</a>
                    </li>
										<li>
												<a href="/doc.html">文档</a>
										</li>
                    <li>
                        <a href="/contact.html">联系我们</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Content -->
    <div class="container">

			<div class="row">
					<div class="col-xs-4">
						<h4>ECMAScript 6入门</h4>
						<h6>感谢Ruan YiFeng提供内容</h6>
<ul><li><a href='./0.html'>前言</a></li><li><a href='./1.html'>ECMAScript 6简介</a></li><li><a href='./2.html'>let和const命令</a></li><li><a href='./3.html'>变量的解构赋值</a></li><li><a href='./4.html'>字符串的扩展</a></li><li><a href='./5.html'>正则的扩展</a></li><li><a href='./6.html'>数值的扩展</a></li><li><a href='./7.html'>数组的扩展</a></li><li><a href='./8.html'>函数的扩展</a></li><li><a href='./9.html'>对象的扩展</a></li><li><a href='./10.html'>Symbol</a></li><li><a href='./11.html'>Proxy和Reflect</a></li><li><a href='./12.html'>Set和Map数据结构</a></li><li><a href='./13.html'>Iterator和for...of循环</a></li><li><a href='./14.html'>Generator函数</a></li><li><a href='./15.html'>Promise对象</a></li><li><a href='./16.html'>异步操作和Async函数</a></li><li><a href='./17.html'>Class</a></li><li><a href='./18.html'>Decorator</a></li><li><a href='./19.html'>Module</a></li><li><a href='./20.html'>编程风格</a></li><li><a href='./21.html'>读懂规格</a></li><li><a href='./22.html'>二进制数组</a></li><li><a href='./23.html'>SIMD</a></li><li><a href='./24.html'>参考链接</a></li><li></li>
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
<div class="col-xs-8">
	<nav>
		<ul class="pager">
			<li class='previous'><a href='18.html'>&larr; Decorator</a></li>
		<li class='next'><a href='20.html'>编程风格&rarr;</a></li>
		</ul>
	</nav>
			<div class="row"><div class="col-xs-12"># Module<br><br>ES6的Class只是面向对象编程的语法糖，升级了ES5的构造函数的原型链继承的写法，并没有解决模块化问题。Module功能就是为了解决这个问题而提出的。<br><br>历史上，JavaScript一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如Ruby的`require`、Python的`import`，甚至就连CSS都有`@import`，但是JavaScript任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。<br><br>在ES6之前，社区制定了一些模块加载方案，最主要的有CommonJS和AMD两种。前者用于服务器，后者用于浏览器。ES6在语言规格的层面上，实现了模块功能，而且实现得相当简单，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。<br><br>ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。比如，CommonJS模块就是对象，输入时必须查找对象属性。<br><br>```javascript<br>// CommonJS模块<br>let { stat, exists, readFile } = require('fs');<br><br>// 等同于<br>let _fs = require('fs');<br>let stat = _fs.stat, exists = _fs.exists, readfile = _fs.readfile;<br>```<br><br>上面代码的实质是整体加载`fs`模块（即加载`fs`的所有方法），生成一个对象（`_fs`），然后再从这个对象上面读取3个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。<br><br>ES6模块不是对象，而是通过`export`命令显式指定输出的代码，输入时也采用静态命令的形式。<br><br>```javascript<br>// ES6模块<br>import { stat, exists, readFile } from 'fs';<br>```<br><br>上面代码的实质是从`fs`模块加载3个方法，其他方法不加载。这种加载称为“编译时加载”，即ES6可以在编译时就完成模块加载，效率要比CommonJS模块的加载方式高。当然，这也导致了没法引用ES6模块本身，因为它不是对象。<br><br>由于ES6模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽JavaScript的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。<br><br>除了静态加载带来的各种好处，ES6模块还有以下好处。<br><br>- 不再需要UMD模块格式了，将来服务器和浏览器都会支持ES6模块格式。目前，通过各种工具库，其实已经做到了这一点。<br>- 将来浏览器的新API就能用模块格式提供，不再必要做成全局变量或者`navigator`对象的属性。<br>- 不再需要对象作为命名空间（比如`Math`对象），未来这些功能可以通过模块提供。<br><br>浏览器使用ES6模块的语法如下。<br><br>```html<br><script type="module" src="foo.js"></script><br>```<br><br>上面代码在网页中插入一个模块`foo.js`，由于`type`属性设为`module`，所以浏览器知道这是一个ES6模块。<br><br>Node的默认模块格式是CommonJS，目前还没决定怎么支持ES6模块。所以，只能通过Babel这样的转码器，在Node里面使用ES6模块。<br><br>## 严格模式<br><br>ES6的模块自动采用严格模式，不管你有没有在模块头部加上`"use strict";`。<br><br>严格模式主要有以下限制。<br><br>- 变量必须声明后再使用<br>- 函数的参数不能有同名属性，否则报错<br>- 不能使用`with`语句<br>- 不能对只读属性赋值，否则报错<br>- 不能使用前缀0表示八进制数，否则报错<br>- 不能删除不可删除的属性，否则报错<br>- 不能删除变量`delete prop`，会报错，只能删除属性`delete global[prop]`<br>- `eval`不会在它的外层作用域引入变量<br>- `eval`和`arguments`不能被重新赋值<br>- `arguments`不会自动反映函数参数的变化<br>- 不能使用`arguments.callee`<br>- 不能使用`arguments.caller`<br>- 禁止`this`指向全局对象<br>- 不能使用`fn.caller`和`fn.arguments`获取函数调用的堆栈<br>- 增加了保留字（比如`protected`、`static`和`interface`）<br><br>上面这些限制，模块都必须遵守。由于严格模式是ES5引入的，不属于ES6，所以请参阅相关ES5书籍，本书不再详细介绍了。<br><br>## export命令<br><br>模块功能主要由两个命令构成：`export`和`import`。`export`命令用于规定模块的对外接口，`import`命令用于输入其他模块提供的功能。<br><br>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用`export`关键字输出该变量。下面是一个JS文件，里面使用`export`命令输出变量。<br><br>```javascript<br>// profile.js<br>export var firstName = 'Michael';<br>export var lastName = 'Jackson';<br>export var year = 1958;<br>```<br><br>上面代码是`profile.js`文件，保存了用户信息。ES6将其视为一个模块，里面用`export`命令对外部输出了三个变量。<br><br>`export`的写法，除了像上面这样，还有另外一种。<br><br>```javascript<br>// profile.js<br>var firstName = 'Michael';<br>var lastName = 'Jackson';<br>var year = 1958;<br><br>export {firstName, lastName, year};<br>```<br><br>上面代码在`export`命令后面，使用大括号指定所要输出的一组变量。它与前一种写法（直接放置在`var`语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。<br><br>export命令除了输出变量，还可以输出函数或类（class）。<br><br>```javascript<br>export function multiply(x, y) {<br>  return x * y;<br>};<br>```<br><br>上面代码对外输出一个函数`multiply`。<br><br>通常情况下，`export`输出的变量就是本来的名字，但是可以使用`as`关键字重命名。<br><br>```javascript<br>function v1() { ... }<br>function v2() { ... }<br><br>export {<br>  v1 as streamV1,<br>  v2 as streamV2,<br>  v2 as streamLatestVersion<br>};<br>```<br><br>上面代码使用`as`关键字，重命名了函数`v1`和`v2`的对外接口。重命名后，`v2`可以用不同的名字输出两次。<br><br>需要特别注意的是，`export`命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。<br><br>```javascript<br>// 报错<br>export 1;<br><br>// 报错<br>var m = 1;<br>export m;<br>```<br><br>上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出1，第二种写法通过变量`m`，还是直接输出1。`1`只是一个值，不是接口。正确的写法是下面这样。<br><br>```javascript<br>// 写法一<br>export var m = 1;<br><br>// 写法二<br>var m = 1;<br>export {m};<br><br>// 写法三<br>var n = 1;<br>export {n as m};<br>```<br><br>上面三种写法都是正确的，规定了对外的接口`m`。其他脚本可以通过这个接口，取到值`1`。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。<br><br>同样的，`function`和`class`的输出，也必须遵守这样的写法。<br><br>```javascript<br>// 报错<br>function f() {}<br>export f;<br><br>// 正确<br>export function f() {};<br><br>// 正确<br>function f() {}<br>export {f};<br>```<br><br>另外，`export`语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。<br><br>```javascript<br>export var foo = 'bar';<br>setTimeout(() => foo = 'baz', 500);<br>```<br><br>上面代码输出变量`foo`，值为`bar`，500毫秒之后变成`baz`。<br><br>这一点与CommonJS规范完全不同。CommonJS模块输出的是值的缓存，不存在动态更新，详见下文《ES6模块加载的实质》一节。<br><br>最后，`export`命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的`import`命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了ES6模块的设计初衷。<br><br>```javascript<br>function foo() {<br>  export default 'bar' // SyntaxError<br>}<br>foo()<br>```<br><br>上面代码中，`export`语句放在函数之中，结果报错。<br><br>## import命令<br><br>使用`export`命令定义了模块的对外接口以后，其他JS文件就可以通过`import`命令加载这个模块（文件）。<br><br>```javascript<br>// main.js<br><br>import {firstName, lastName, year} from './profile';<br><br>function setName(element) {<br>  element.textContent = firstName + ' ' + lastName;<br>}<br>```<br><br>上面代码的`import`命令，就用于加载`profile.js`文件，并从中输入变量。`import`命令接受一个对象（用大括号表示），里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（`profile.js`）对外接口的名称相同。<br><br>如果想为输入的变量重新取一个名字，import命令要使用`as`关键字，将输入的变量重命名。<br><br>```javascript<br>import { lastName as surname } from './profile';<br>```<br><br>注意，`import`命令具有提升效果，会提升到整个模块的头部，首先执行。<br><br>```javascript<br>foo();<br><br>import { foo } from 'my_module';<br>```<br><br>上面的代码不会报错，因为`import`的执行早于`foo`的调用。<br><br>如果在一个模块之中，先输入后输出同一个模块，`import`语句可以与`export`语句写在一起。<br><br>```javascript<br>export { es6 as default } from './someModule';<br><br>// 等同于<br>import { es6 } from './someModule';<br>export default es6;<br>```<br><br>上面代码中，`export`和`import`语句可以结合在一起，写成一行。但是从可读性考虑，不建议采用这种写法，而应该采用标准写法。<br><br>另外，ES7有一个[提案](https://github.com/leebyron/ecmascript-more-export-from)，简化先输入后输出的写法，拿掉输出时的大括号。<br><br>```javascript<br>// 提案的写法<br>export v from 'mod';<br><br>// 现行的写法<br>export {v} from 'mod';<br>```<br><br>`import`语句会执行所加载的模块，因此可以有下面的写法。<br><br>```javascript<br>import 'lodash';<br>```<br><br>上面代码仅仅执行`lodash`模块，但是不输入任何值。<br><br>## 模块的整体加载<br><br>除了指定加载某个输出值，还可以使用整体加载，即用星号（`*`）指定一个对象，所有输出值都加载在这个对象上面。<br><br>下面是一个`circle.js`文件，它输出两个方法`area`和`circumference`。<br><br>```javascript<br>// circle.js<br><br>export function area(radius) {<br>  return Math.PI * radius * radius;<br>}<br><br>export function circumference(radius) {<br>  return 2 * Math.PI * radius;<br>}<br>```<br><br>现在，加载这个模块。<br><br>```javascript<br>// main.js<br><br>import { area, circumference } from './circle';<br><br>console.log('圆面积：' + area(4));<br>console.log('圆周长：' + circumference(14));<br>```<br><br>上面写法是逐一指定要加载的方法，整体加载的写法如下。<br><br>```javascript<br>import * as circle from './circle';<br><br>console.log('圆面积：' + circle.area(4));<br>console.log('圆周长：' + circle.circumference(14));<br>```<br><br>## export default命令<br><br>从前面的例子可以看出，使用`import`命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。<br><br>为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到`export default`命令，为模块指定默认输出。<br><br>```javascript<br>// export-default.js<br>export default function () {<br>  console.log('foo');<br>}<br>```<br><br>上面代码是一个模块文件`export-default.js`，它的默认输出是一个函数。<br><br>其他模块加载该模块时，`import`命令可以为该匿名函数指定任意名字。<br><br>```javascript<br>// import-default.js<br>import customName from './export-default';<br>customName(); // 'foo'<br>```<br><br>上面代码的`import`命令，可以用任意名称指向`export-default.js`输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时`import`命令后面，不使用大括号。<br><br>`export default`命令用在非匿名函数前，也是可以的。<br><br>```javascript<br>// export-default.js<br>export default function foo() {<br>  console.log('foo');<br>}<br><br>// 或者写成<br><br>function foo() {<br>  console.log('foo');<br>}<br><br>export default foo;<br>```<br><br>上面代码中，`foo`函数的函数名`foo`，在模块外部是无效的。加载的时候，视同匿名函数加载。<br><br>下面比较一下默认输出和正常输出。<br><br>```javascript<br>// 输出<br>export default function crc32() {<br>  // ...<br>}<br>// 输入<br>import crc32 from 'crc32';<br><br>// 输出<br>export function crc32() {<br>  // ...<br>};<br>// 输入<br>import {crc32} from 'crc32';<br>```<br><br>上面代码的两组写法，第一组是使用`export default`时，对应的`import`语句不需要使用大括号；第二组是不使用`export default`时，对应的`import`语句需要使用大括号。<br><br>`export default`命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此`export default`命令只能使用一次。所以，`import`命令后面才不用加大括号，因为只可能对应一个方法。<br><br>本质上，`export default`就是输出一个叫做`default`的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。<br><br>```javascript<br>// modules.js<br>function add(x, y) {<br>  return x * y;<br>}<br>export {add as default};<br>// 等同于<br>// export default add;<br><br>// app.js<br>import { default as xxx } from 'modules';<br>// 等同于<br>// import xxx from 'modules';<br>```<br><br>正是因为`export default`命令其实只是输出一个叫做`default`的变量，所以它后面不能跟变量声明语句。<br><br>```javascript<br>// 正确<br>export var a = 1;<br><br>// 正确<br>var a = 1;<br>export default a;<br><br>// 错误<br>export default var a = 1;<br>```<br><br>上面代码中，`export default a`的含义是将变量`a`的值赋给变量`default`。所以，最后一种写法会报错。<br><br>有了`export default`命令，输入模块时就非常直观了，以输入jQuery模块为例。<br><br>```javascript<br>import $ from 'jquery';<br>```<br><br>如果想在一条import语句中，同时输入默认方法和其他变量，可以写成下面这样。<br><br>```javascript<br>import customName, { otherMethod } from './export-default';<br>```<br><br>如果要输出默认的值，只需将值跟在`export default`之后即可。<br><br>```javascript<br>export default 42;<br>```<br><br>`export default`也可以用来输出类。<br><br>```javascript<br>// MyClass.js<br>export default class { ... }<br><br>// main.js<br>import MyClass from 'MyClass';<br>let o = new MyClass();<br>```<br><br>## 模块的继承<br><br>模块之间也可以继承。<br><br>假设有一个`circleplus`模块，继承了`circle`模块。<br><br>```javascript<br>// circleplus.js<br><br>export * from 'circle';<br>export var e = 2.71828182846;<br>export default function(x) {<br>  return Math.exp(x);<br>}<br>```<br><br>上面代码中的`export *`，表示再输出`circle`模块的所有属性和方法。注意，`export *`命令会忽略`circle`模块的`default`方法。然后，上面代码又输出了自定义的`e`变量和默认方法。<br><br>这时，也可以将`circle`的属性或方法，改名后再输出。<br><br>```javascript<br>// circleplus.js<br><br>export { area as circleArea } from 'circle';<br>```<br><br>上面代码表示，只输出`circle`模块的`area`方法，且将其改名为`circleArea`。<br><br>加载上面模块的写法如下。<br><br>```javascript<br>// main.js<br><br>import * as math from 'circleplus';<br>import exp from 'circleplus';<br>console.log(exp(math.e));<br>```<br><br>上面代码中的`import exp`表示，将`circleplus`模块的默认方法加载为`exp`方法。<br><br>## ES6模块加载的实质<br><br>ES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。<br><br>CommonJS模块输出的是被输出值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个模块文件`lib.js`的例子。<br><br>```javascript<br>// lib.js<br>var counter = 3;<br>function incCounter() {<br>  counter++;<br>}<br>module.exports = {<br>  counter: counter,<br>  incCounter: incCounter,<br>};<br>```<br><br>上面代码输出内部变量`counter`和改写这个变量的内部方法`incCounter`。然后，在`main.js`里面加载这个模块。<br><br>```javascript<br>// main.js<br>var mod = require('./lib');<br><br>console.log(mod.counter);  // 3<br>mod.incCounter();<br>console.log(mod.counter); // 3<br>```<br><br>上面代码说明，`lib.js`模块加载以后，它的内部变化就影响不到输出的`mod.counter`了。这是因为`mod.counter`是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。<br><br>```javascript<br>// lib.js<br>var counter = 3;<br>function incCounter() {<br>  counter++;<br>}<br>module.exports = {<br>  get counter() {<br>    return counter<br>  },<br>  incCounter: incCounter,<br>};<br>```<br><br>上面代码中，输出的`counter`属性实际上是一个取值器函数。现在再执行`main.js`，就可以正确读取内部变量`counter`的变动了。<br><br>```bash<br>$ node main.js<br>3<br>4<br>```<br><br>ES6模块的运行机制与CommonJS不一样，它遇到模块加载命令`import`时，不会去执行模块，而是只生成一个动态的只读引用。等到真的需要用到时，再到模块里面去取值，换句话说，ES6的输入有点像Unix系统的“符号连接”，原始值变了，`import`输入的值也会跟着变。因此，ES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。<br><br>还是举上面的例子。<br><br>```javascript<br>// lib.js<br>export let counter = 3;<br>export function incCounter() {<br>  counter++;<br>}<br><br>// main.js<br>import { counter, incCounter } from './lib';<br>console.log(counter); // 3<br>incCounter();<br>console.log(counter); // 4<br>```<br><br>上面代码说明，ES6模块输入的变量`counter`是活的，完全反应其所在模块`lib.js`内部的变化。<br><br>再举一个出现在`export`一节中的例子。<br><br>```javascript<br>// m1.js<br>export var foo = 'bar';<br>setTimeout(() => foo = 'baz', 500);<br><br>// m2.js<br>import {foo} from './m1.js';<br>console.log(foo);<br>setTimeout(() => console.log(foo), 500);<br>```<br><br>上面代码中，`m1.js`的变量`foo`，在刚加载时等于`bar`，过了500毫秒，又变为等于`baz`。<br><br>让我们看看，`m2.js`能否正确读取这个变化。<br><br>```bash<br>$ babel-node m2.js<br><br>bar<br>baz<br>```<br><br>上面代码表明，ES6模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。<br><br>由于ES6输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。<br><br>```javascript<br>// lib.js<br>export let obj = {};<br><br>// main.js<br>import { obj } from './lib';<br><br>obj.prop = 123; // OK<br>obj = {}; // TypeError<br>```<br><br>上面代码中，`main.js`从`lib.js`输入变量`obj`，可以对`obj`添加属性，但是重新赋值就会报错。因为变量`obj`指向的地址是只读的，不能重新赋值，这就好比`main.js`创造了一个名为`obj`的const变量。<br><br>最后，`export`通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。<br><br>```javascript<br>// mod.js<br>function C() {<br>  this.sum = 0;<br>  this.add = function () {<br>    this.sum += 1;<br>  };<br>  this.show = function () {<br>    console.log(this.sum);<br>  };<br>}<br><br>export let c = new C();<br>```<br><br>上面的脚本`mod.js`，输出的是一个`C`的实例。不同的脚本加载这个模块，得到的都是同一个实例。<br><br>```javascript<br>// x.js<br>import {c} from './mod';<br>c.add();<br><br>// y.js<br>import {c} from './mod';<br>c.show();<br><br>// main.js<br>import './x';<br>import './y';<br>```<br><br>现在执行`main.js`，输出的是1。<br><br>```bash<br>$ babel-node main.js<br>1<br>```<br><br>这就证明了`x.js`和`y.js`加载的都是`C`的同一个实例。<br><br>## 循环加载<br><br>“循环加载”（circular dependency）指的是，`a`脚本的执行依赖`b`脚本，而`b`脚本的执行又依赖`a`脚本。<br><br>```javascript<br>// a.js<br>var b = require('b');<br><br>// b.js<br>var a = require('a');<br>```<br><br>通常，“循环加载”表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。<br><br>但是实际上，这是很难避免的，尤其是依赖关系复杂的大项目，很容易出现`a`依赖`b`，`b`依赖`c`，`c`又依赖`a`这样的情况。这意味着，模块加载机制必须考虑“循环加载”的情况。<br><br>对于JavaScript语言来说，目前最常见的两种模块格式CommonJS和ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。<br><br>### CommonJS模块的加载原理<br><br>介绍ES6如何处理"循环加载"之前，先介绍目前最流行的CommonJS模块格式的加载原理。<br><br>CommonJS的一个模块，就是一个脚本文件。`require`命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。<br><br>```javascript<br>{<br>  id: '...',<br>  exports: { ... },<br>  loaded: true,<br>  ...<br>}<br>```<br><br>上面代码就是Node内部加载模块后生成的一个对象。该对象的`id`属性是模块名，`exports`属性是模块输出的各个接口，`loaded`属性是一个布尔值，表示该模块的脚本是否执行完毕。其他还有很多属性，这里都省略了。<br><br>以后需要用到这个模块的时候，就会到`exports`属性上面取值。即使再次执行`require`命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。<br><br>### CommonJS模块的循环加载<br><br>CommonJS模块的重要特性是加载时执行，即脚本代码在`require`的时候，就会全部执行。一旦出现某个模块被"循环加载"，就只输出已经执行的部分，还未执行的部分不会输出。<br><br>让我们来看，Node[官方文档](https://nodejs.org/api/modules.html#modules_cycles)里面的例子。脚本文件`a.js`代码如下。<br><br>```javascript<br>exports.done = false;<br>var b = require('./b.js');<br>console.log('在 a.js 之中，b.done = %j', b.done);<br>exports.done = true;<br>console.log('a.js 执行完毕');<br>```<br><br>上面代码之中，`a.js`脚本先输出一个`done`变量，然后加载另一个脚本文件`b.js`。注意，此时`a.js`代码就停在这里，等待`b.js`执行完毕，再往下执行。<br><br>再看`b.js`的代码。<br><br>```javascript<br>exports.done = false;<br>var a = require('./a.js');<br>console.log('在 b.js 之中，a.done = %j', a.done);<br>exports.done = true;<br>console.log('b.js 执行完毕');<br>```<br><br>上面代码之中，`b.js`执行到第二行，就会去加载`a.js`，这时，就发生了“循环加载”。系统会去`a.js`模块对应对象的`exports`属性取值，可是因为`a.js`还没有执行完，从`exports`属性只能取回已经执行的部分，而不是最后的值。<br><br>`a.js`已经执行的部分，只有一行。<br><br>```javascript<br>exports.done = false;<br>```<br><br>因此，对于`b.js`来说，它从`a.js`只输入一个变量`done`，值为`false`。<br><br>然后，`b.js`接着往下执行，等到全部执行完毕，再把执行权交还给`a.js`。于是，`a.js`接着往下执行，直到执行完毕。我们写一个脚本`main.js`，验证这个过程。<br><br>```javascript<br>var a = require('./a.js');<br>var b = require('./b.js');<br>console.log('在 main.js 之中, a.done=%j, b.done=%j', a.done, b.done);<br>```<br><br>执行`main.js`，运行结果如下。<br><br>```bash<br>$ node main.js<br><br>在 b.js 之中，a.done = false<br>b.js 执行完毕<br>在 a.js 之中，b.done = true<br>a.js 执行完毕<br>在 main.js 之中, a.done=true, b.done=true<br>```<br><br>上面的代码证明了两件事。一是，在`b.js`之中，`a.js`没有执行完毕，只执行了第一行。二是，`main.js`执行到第二行时，不会再次执行`b.js`，而是输出缓存的`b.js`的执行结果，即它的第四行。<br><br>```javascript<br>exports.done = true;<br>```<br><br>总之，CommonJS输入的是被输出值的拷贝，不是引用。<br><br>另外，由于CommonJS模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。<br><br>```javascript<br>var a = require('a'); // 安全的写法<br>var foo = require('a').foo; // 危险的写法<br><br>exports.good = function (arg) {<br>  return a.foo('good', arg); // 使用的是 a.foo 的最新值<br>};<br><br>exports.bad = function (arg) {<br>  return foo('bad', arg); // 使用的是一个部分加载时的值<br>};<br>```<br><br>上面代码中，如果发生循环加载，`require('a').foo`的值很可能后面会被改写，改用`require('a')`会更保险一点。<br><br>### ES6模块的循环加载<br><br>ES6处理“循环加载”与CommonJS有本质的不同。ES6模块是动态引用，如果使用`import`从一个模块加载变量（即`import foo from 'foo'`），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。<br><br>请看下面这个例子。<br><br>```javascript<br>// a.js如下<br>import {bar} from './b.js';<br>console.log('a.js');<br>console.log(bar);<br>export let foo = 'foo';<br><br>// b.js<br>import {foo} from './a.js';<br>console.log('b.js');<br>console.log(foo);<br>export let bar = 'bar';<br>```<br><br>上面代码中，`a.js`加载`b.js`，`b.js`又加载`a.js`，构成循环加载。执行`a.js`，结果如下。<br><br>```bash<br>$ babel-node a.js<br>b.js<br>undefined<br>a.js<br>bar<br>```<br><br>上面代码中，由于`a.js`的第一行是加载`b.js`，所以先执行的是`b.js`。而`b.js`的第一行又是加载`a.js`，这时由于`a.js`已经开始执行了，所以不会重复执行，而是继续往下执行`b.js`，所以第一行输出的是`b.js`。<br><br>接着，`b.js`要打印变量`foo`，这时`a.js`还没执行完，取不到`foo`的值，导致打印出来是`undefined`。`b.js`执行完，开始执行`a.js`，这时就一切正常了。<br><br>再看一个稍微复杂的例子（摘自 Dr. Axel Rauschmayer 的[《Exploring ES6》](http://exploringjs.com/es6/ch_modules.html)）。<br><br>```javascript<br>// a.js<br>import {bar} from './b.js';<br>export function foo() {<br>  console.log('foo');<br>  bar();<br>  console.log('执行完毕');<br>}<br>foo();<br><br>// b.js<br>import {foo} from './a.js';<br>export function bar() {<br>  console.log('bar');<br>  if (Math.random() > 0.5) {<br>    foo();<br>  }<br>}<br>```<br><br>按照CommonJS规范，上面的代码是没法执行的。`a`先加载`b`，然后`b`又加载`a`，这时`a`还没有任何执行结果，所以输出结果为`null`，即对于`b.js`来说，变量`foo`的值等于`null`，后面的`foo()`就会报错。<br><br>但是，ES6可以执行上面的代码。<br><br>```bash<br>$ babel-node a.js<br>foo<br>bar<br>执行完毕<br><br>// 执行结果也有可能是<br>foo<br>bar<br>foo<br>bar<br>执行完毕<br>执行完毕<br>```<br><br>上面代码中，`a.js`之所以能够执行，原因就在于ES6加载的变量，都是动态引用其所在的模块。只要引用存在，代码就能执行。<br><br>下面，我们详细分析这段代码的运行过程。<br><br>```javascript<br>// a.js<br><br>// 这一行建立一个引用，<br>// 从`b.js`引用`bar`<br>import {bar} from './b.js';<br><br>export function foo() {<br>  // 执行时第一行输出 foo<br>  console.log('foo');<br>  // 到 b.js 执行 bar<br>  bar();<br>  console.log('执行完毕');<br>}<br>foo();<br><br>// b.js<br><br>// 建立`a.js`的`foo`引用<br>import {foo} from './a.js';<br><br>export function bar() {<br>  // 执行时，第二行输出 bar<br>  console.log('bar');<br>  // 递归执行 foo，一旦随机数<br>  // 小于等于0.5，就停止执行<br>  if (Math.random() > 0.5) {<br>    foo();<br>  }<br>}<br>```<br><br>我们再来看ES6模块加载器[SystemJS](https://github.com/ModuleLoader/es6-module-loader/blob/master/docs/circular-references-bindings.md)给出的一个例子。<br><br>```javascript<br>// even.js<br>import { odd } from './odd'<br>export var counter = 0;<br>export function even(n) {<br>  counter++;<br>  return n == 0 || odd(n - 1);<br>}<br><br>// odd.js<br>import { even } from './even';<br>export function odd(n) {<br>  return n != 0 && even(n - 1);<br>}<br>```<br><br>上面代码中，`even.js`里面的函数`even`有一个参数`n`，只要不等于0，就会减去1，传入加载的`odd()`。`odd.js`也会做类似操作。<br><br>运行上面这段代码，结果如下。<br><br>```javascript<br>$ babel-node<br>> import * as m from './even.js';<br>> m.even(10);<br>true<br>> m.counter<br>6<br>> m.even(20)<br>true<br>> m.counter<br>17<br>```<br><br>上面代码中，参数`n`从10变为0的过程中，`even()`一共会执行6次，所以变量`counter`等于6。第二次调用`even()`时，参数`n`从20变为0，`even()`一共会执行11次，加上前面的6次，所以变量`counter`等于17。<br><br>这个例子要是改写成CommonJS，就根本无法执行，会报错。<br><br>```javascript<br>// even.js<br>var odd = require('./odd');<br>var counter = 0;<br>exports.counter = counter;<br>exports.even = function(n) {<br>  counter++;<br>  return n == 0 || odd(n - 1);<br>}<br><br>// odd.js<br>var even = require('./even').even;<br>module.exports = function(n) {<br>  return n != 0 && even(n - 1);<br>}<br>```<br><br>上面代码中，`even.js`加载`odd.js`，而`odd.js`又去加载`even.js`，形成“循环加载”。这时，执行引擎就会输出`even.js`已经执行的部分（不存在任何结果），所以在`odd.js`之中，变量`even`等于`null`，等到后面调用`even(n-1)`就会报错。<br><br>```bash<br>$ node<br>> var m = require('./even');<br>> m.even(10)<br>TypeError: even is not a function<br>```<br><br>## 跨模块常量<br><br>上面说过，`const`声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），可以采用下面的写法。<br><br>```javascript<br>// constants.js 模块<br>export const A = 1;<br>export const B = 3;<br>export const C = 4;<br><br>// test1.js 模块<br>import * as constants from './constants';<br>console.log(constants.A); // 1<br>console.log(constants.B); // 3<br><br>// test2.js 模块<br>import {A, B} from './constants';<br>console.log(A); // 1<br>console.log(B); // 3<br>```<br><br>## ES6模块的转码<br><br>浏览器目前还不支持ES6模块，为了现在就能使用，可以将转为ES5的写法。除了Babel可以用来转码之外，还有以下两个方法，也可以用来转码。<br><br>### ES6 module transpiler<br><br>[ES6 module transpiler](https://github.com/esnext/es6-module-transpiler)是square公司开源的一个转码器，可以将ES6模块转为CommonJS模块或AMD模块的写法，从而在浏览器中使用。<br><br>首先，安装这个转玛器。<br><br>```bash<br>$ npm install -g es6-module-transpiler<br>```<br><br>然后，使用`compile-modules convert`命令，将ES6模块文件转码。<br><br>```bash<br>$ compile-modules convert file1.js file2.js<br>```<br><br>`-o`参数可以指定转码后的文件名。<br><br>```bash<br>$ compile-modules convert -o out.js file1.js<br>```<br><br>### SystemJS<br><br>另一种解决方法是使用[SystemJS](https://github.com/systemjs/systemjs)。它是一个垫片库（polyfill），可以在浏览器内加载ES6模块、AMD模块和CommonJS模块，将其转为ES5格式。它在后台调用的是Google的Traceur转码器。<br><br>使用时，先在网页内载入system.js文件。<br><br>```html<br><script src="system.js"></script><br>```<br><br>然后，使用`System.import`方法加载模块文件。<br><br>```html<br><script><br>  System.import('./app.js');<br></script><br>```<br><br>上面代码中的`./app`，指的是当前目录下的app.js文件。它可以是ES6模块文件，`System.import`会自动将其转码。<br><br>需要注意的是，`System.import`使用异步加载，返回一个Promise对象，可以针对这个对象编程。下面是一个模块文件。<br><br>```javascript<br>// app/es6-file.js:<br><br>export class q {<br>  constructor() {<br>    this.es6 = 'hello';<br>  }<br>}<br>```<br><br>然后，在网页内加载这个模块文件。<br><br>```html<br><script><br><br>System.import('app/es6-file').then(function(m) {<br>  console.log(new m.q().es6); // hello<br>});<br><br></script><br>```<br><br>上面代码中，`System.import`方法返回的是一个Promise对象，所以可以用then方法指定回调函数。<br></div></div>
			<nav>
				<ul class="pager">
				<li class='previous'><a href='18.html'>&larr; Decorator</a></li>
			<li class='next'><a href='20.html'>编程风格&rarr;</a></li>
				</ul>
			</nav>
</div>
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
			<!-- /.row -->
			  <hr>
        <!-- Footer -->
        <footer>
            <div class="row">
                <div class="col-xs-12">
                    <p>Copyright &copy; 小龙软件工作室 2016 粤icp备16103410</p>
                </div>
            </div>
        </footer>

    </div>
    <!-- /.container -->

    <!-- jQuery -->
    <script src="../../js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="../../js/bootstrap.min.js"></script>

</body>

</html>
