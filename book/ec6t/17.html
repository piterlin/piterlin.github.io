<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="content-type" content="text/html;charset=utf-8">
    <meta charset="utf-8">
<meta name="360-site-verification" content="cabcfb5a0f4c0d28d604e8a69e6c0cdb" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="baidu-site-verification" content="HknqsD2zhn" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>ECMAScript 6入门-编码助手网</title>
      <meta content="为编码人员提供在线文档、模板等帮助，提升解决问题效率" name="description">
			<meta content="ECMAScript 6入门 Java, spring, tomcat, servlet, jsp, api doc, bootstrap" name="keywords">
<meta name="sogou_site_verification" content="42nApEZFKO"/>


    <!-- Bootstrap Core CSS -->
    <link href="../../css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="../../css/heroic-features.css" rel="stylesheet">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
		<script>
		var _hmt = _hmt || [];
		(function() {
		  var hm = document.createElement("script");
		  hm.src = "//hm.baidu.com/hm.js?dd1361ca20a10cc161e72d4bc4fef6df";
		  var s = document.getElementsByTagName("script")[0];
		  s.parentNode.insertBefore(hm, s);
		})();
		</script>

</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">编码助手网</a>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav">
                    <li>
                        <a href="/">首页</a>
                    </li>
										<li>
                        <a href="/template.html">模板</a>
                    </li>
										<li>
												<a href="/doc.html">文档</a>
										</li>
                    <li>
                        <a href="/contact.html">联系我们</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Content -->
    <div class="container">

			<div class="row">
					<div class="col-xs-4">
						<h4>ECMAScript 6入门</h4>
						<h6>感谢Ruan YiFeng提供内容</h6>
<ul><li><a href='./0.html'>前言</a></li><li><a href='./1.html'>ECMAScript 6简介</a></li><li><a href='./2.html'>let和const命令</a></li><li><a href='./3.html'>变量的解构赋值</a></li><li><a href='./4.html'>字符串的扩展</a></li><li><a href='./5.html'>正则的扩展</a></li><li><a href='./6.html'>数值的扩展</a></li><li><a href='./7.html'>数组的扩展</a></li><li><a href='./8.html'>函数的扩展</a></li><li><a href='./9.html'>对象的扩展</a></li><li><a href='./10.html'>Symbol</a></li><li><a href='./11.html'>Proxy和Reflect</a></li><li><a href='./12.html'>Set和Map数据结构</a></li><li><a href='./13.html'>Iterator和for...of循环</a></li><li><a href='./14.html'>Generator函数</a></li><li><a href='./15.html'>Promise对象</a></li><li><a href='./16.html'>异步操作和Async函数</a></li><li><a href='./17.html'>Class</a></li><li><a href='./18.html'>Decorator</a></li><li><a href='./19.html'>Module</a></li><li><a href='./20.html'>编程风格</a></li><li><a href='./21.html'>读懂规格</a></li><li><a href='./22.html'>二进制数组</a></li><li><a href='./23.html'>SIMD</a></li><li><a href='./24.html'>参考链接</a></li><li></li>
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
<div class="col-xs-8">
	<nav>
		<ul class="pager">
			<li class='previous'><a href='16.html'>&larr; 异步操作和Async函数</a></li>
		<li class='next'><a href='18.html'>Decorator&rarr;</a></li>
		</ul>
	</nav>
			<div class="row"><div class="col-xs-12"># Class<br><br>## Class基本语法<br><br>### 概述<br><br>JavaScript语言的传统方法是通过构造函数，定义并生成新对象。下面是一个例子。<br><br>```javascript<br>function Point(x, y) {<br>  this.x = x;<br>  this.y = y;<br>}<br><br>Point.prototype.toString = function () {<br>  return '(' + this.x + ', ' + this.y + ')';<br>};<br><br>var p = new Point(1, 2);<br>```<br><br>上面这种写法跟传统的面向对象语言（比如C++和Java）差异很大，很容易让新学习这门语言的程序员感到困惑。<br><br>ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过`class`关键字，可以定义类。基本上，ES6的`class`可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的`class`写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用ES6的“类”改写，就是下面这样。<br><br>```javascript<br>//定义类<br>class Point {<br>  constructor(x, y) {<br>    this.x = x;<br>    this.y = y;<br>  }<br><br>  toString() {<br>    return '(' + this.x + ', ' + this.y + ')';<br>  }<br>}<br>```<br><br>上面代码定义了一个“类”，可以看到里面有一个`constructor`方法，这就是构造方法，而`this`关键字则代表实例对象。也就是说，ES5的构造函数`Point`，对应ES6的`Point`类的构造方法。<br><br>`Point`类除了构造方法，还定义了一个`toString`方法。注意，定义“类”的方法的时候，前面不需要加上`function`这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。<br><br>ES6的类，完全可以看作构造函数的另一种写法。<br><br>```javascript<br>class Point {<br>  // ...<br>}<br><br>typeof Point // "function"<br>Point === Point.prototype.constructor // true<br>```<br><br>上面代码表明，类的数据类型就是函数，类本身就指向构造函数。<br><br>使用的时候，也是直接对类使用`new`命令，跟构造函数的用法完全一致。<br><br>```javascript<br>class Bar {<br>  doStuff() {<br>    console.log('stuff');<br>  }<br>}<br><br>var b = new Bar();<br>b.doStuff() // "stuff"<br>```<br><br>构造函数的`prototype`属性，在ES6的“类”上面继续存在。事实上，类的所有方法都定义在类的`prototype`属性上面。<br><br>```javascript<br>class Point {<br>  constructor(){<br>    // ...<br>  }<br><br>  toString(){<br>    // ...<br>  }<br><br>  toValue(){<br>    // ...<br>  }<br>}<br><br>// 等同于<br><br>Point.prototype = {<br>  toString(){},<br>  toValue(){}<br>};<br>```<br><br>在类的实例上面调用方法，其实就是调用原型上的方法。<br><br>```javascript<br>class B {}<br>let b = new B();<br><br>b.constructor === B.prototype.constructor // true<br>```<br><br>上面代码中，`b`是B类的实例，它的`constructor`方法就是B类原型的`constructor`方法。<br><br>由于类的方法都定义在`prototype`对象上面，所以类的新方法可以添加在`prototype`对象上面。`Object.assign`方法可以很方便地一次向类添加多个方法。<br><br>```javascript<br>class Point {<br>  constructor(){<br>    // ...<br>  }<br>}<br><br>Object.assign(Point.prototype, {<br>  toString(){},<br>  toValue(){}<br>});<br>```<br><br>`prototype`对象的`constructor`属性，直接指向“类”的本身，这与ES5的行为是一致的。<br><br>```javascript<br>Point.prototype.constructor === Point // true<br>```<br><br>另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。<br><br>```javascript<br>class Point {<br>  constructor(x, y) {<br>    // ...<br>  }<br><br>  toString() {<br>    // ...<br>  }<br>}<br><br>Object.keys(Point.prototype)<br>// []<br>Object.getOwnPropertyNames(Point.prototype)<br>// ["constructor","toString"]<br>```<br><br>上面代码中，`toString`方法是`Point`类内部定义的方法，它是不可枚举的。这一点与ES5的行为不一致。<br><br>```javascript<br>var Point = function (x, y) {<br>  // ...<br>};<br><br>Point.prototype.toString = function() {<br>  // ...<br>};<br><br>Object.keys(Point.prototype)<br>// ["toString"]<br>Object.getOwnPropertyNames(Point.prototype)<br>// ["constructor","toString"]<br>```<br><br>上面代码采用ES5的写法，`toString`方法就是可枚举的。<br><br>类的属性名，可以采用表达式。<br><br>```javascript<br>let methodName = "getArea";<br>class Square{<br>  constructor(length) {<br>    // ...<br>  }<br><br>  [methodName]() {<br>    // ...<br>  }<br>}<br>```<br><br>上面代码中，`Square`类的方法名`getArea`，是从表达式得到的。<br><br>### constructor方法<br><br>`constructor`方法是类的默认方法，通过`new`命令生成对象实例时，自动调用该方法。一个类必须有`constructor`方法，如果没有显式定义，一个空的`constructor`方法会被默认添加。<br><br>```javascript<br>constructor() {}<br>```<br><br>`constructor`方法默认返回实例对象（即`this`），完全可以指定返回另外一个对象。<br><br>```javascript<br>class Foo {<br>  constructor() {<br>    return Object.create(null);<br>  }<br>}<br><br>new Foo() instanceof Foo<br>// false<br>```<br><br>上面代码中，`constructor`函数返回一个全新的对象，结果导致实例对象不是`Foo`类的实例。<br><br>类的构造函数，不使用`new`是没法调用的，会报错。这是它跟普通构造函数的一个主要区别，后者不用`new`也可以执行。<br><br>```javascript<br>class Foo {<br>  constructor() {<br>    return Object.create(null);<br>  }<br>}<br><br>Foo()<br>// TypeError: Class constructor Foo cannot be invoked without 'new'<br>```<br><br>### 类的实例对象<br><br>生成类的实例对象的写法，与ES5完全一样，也是使用`new`命令。如果忘记加上`new`，像函数那样调用`Class`，将会报错。<br><br>```javascript<br>// 报错<br>var point = Point(2, 3);<br><br>// 正确<br>var point = new Point(2, 3);<br>```<br><br>与ES5一样，实例的属性除非显式定义在其本身（即定义在`this`对象上），否则都是定义在原型上（即定义在`class`上）。<br><br>```javascript<br>//定义类<br>class Point {<br><br>  constructor(x, y) {<br>    this.x = x;<br>    this.y = y;<br>  }<br><br>  toString() {<br>    return '(' + this.x + ', ' + this.y + ')';<br>  }<br><br>}<br><br>var point = new Point(2, 3);<br><br>point.toString() // (2, 3)<br><br>point.hasOwnProperty('x') // true<br>point.hasOwnProperty('y') // true<br>point.hasOwnProperty('toString') // false<br>point.__proto__.hasOwnProperty('toString') // true<br>```<br><br>上面代码中，`x`和`y`都是实例对象`point`自身的属性（因为定义在`this`变量上），所以`hasOwnProperty`方法返回`true`，而`toString`是原型对象的属性（因为定义在`Point`类上），所以`hasOwnProperty`方法返回`false`。这些都与ES5的行为保持一致。<br><br>与ES5一样，类的所有实例共享一个原型对象。<br><br>```javascript<br>var p1 = new Point(2,3);<br>var p2 = new Point(3,2);<br><br>p1.__proto__ === p2.__proto__<br>//true<br>```<br><br>上面代码中，`p1`和`p2`都是Point的实例，它们的原型都是Point，所以`__proto__`属性是相等的。<br><br>这也意味着，可以通过实例的`__proto__`属性为Class添加方法。<br><br>```javascript<br>var p1 = new Point(2,3);<br>var p2 = new Point(3,2);<br><br>p1.__proto__.printName = function () { return 'Oops' };<br><br>p1.printName() // "Oops"<br>p2.printName() // "Oops"<br><br>var p3 = new Point(4,2);<br>p3.printName() // "Oops"<br>```<br><br>上面代码在`p1`的原型上添加了一个`printName`方法，由于`p1`的原型就是`p2`的原型，因此`p2`也可以调用这个方法。而且，此后新建的实例`p3`也可以调用这个方法。这意味着，使用实例的`__proto__`属性改写原型，必须相当谨慎，不推荐使用，因为这会改变Class的原始定义，影响到所有实例。<br><br>### 不存在变量提升<br><br>Class不存在变量提升（hoist），这一点与ES5完全不同。<br><br>```javascript<br>new Foo(); // ReferenceError<br>class Foo {}<br>```<br><br>上面代码中，`Foo`类使用在前，定义在后，这样会报错，因为ES6不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。<br><br>```javascript<br>{<br>  let Foo = class {};<br>  class Bar extends Foo {<br>  }<br>}<br>```<br><br>上面的代码不会报错，因为`class`继承`Foo`的时候，`Foo`已经有定义了。但是，如果存在`class`的提升，上面代码就会报错，因为`class`会被提升到代码头部，而`let`命令是不提升的，所以导致`class`继承`Foo`的时候，`Foo`还没有定义。<br><br>### Class表达式<br><br>与函数一样，类也可以使用表达式的形式定义。<br><br>```javascript<br>const MyClass = class Me {<br>  getClassName() {<br>    return Me.name;<br>  }<br>};<br>```<br><br>上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是`MyClass`而不是`Me`，`Me`只在Class的内部代码可用，指代当前类。<br><br>```javascript<br>let inst = new MyClass();<br>inst.getClassName() // Me<br>Me.name // ReferenceError: Me is not defined<br>```<br><br>上面代码表示，`Me`只在Class内部有定义。<br><br>如果类的内部没用到的话，可以省略`Me`，也就是可以写成下面的形式。<br><br>```javascript<br>const MyClass = class { /* ... */ };<br>```<br><br>采用Class表达式，可以写出立即执行的Class。<br><br>```javascript<br>let person = new class {<br>  constructor(name) {<br>    this.name = name;<br>  }<br><br>  sayName() {<br>    console.log(this.name);<br>  }<br>}('张三');<br><br>person.sayName(); // "张三"<br>```<br><br>上面代码中，`person`是一个立即执行的类的实例。<br><br>### 私有方法<br><br>私有方法是常见需求，但ES6不提供，只能通过变通方法模拟实现。<br><br>一种做法是在命名上加以区别。<br><br>```javascript<br>class Widget {<br><br>  // 公有方法<br>  foo (baz) {<br>    this._bar(baz);<br>  }<br><br>  // 私有方法<br>  _bar(baz) {<br>    return this.snaf = baz;<br>  }<br><br>  // ...<br>}<br>```<br><br>上面代码中，`_bar`方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。<br><br>另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。<br><br>```javascript<br>class Widget {<br>  foo (baz) {<br>    bar.call(this, baz);<br>  }<br><br>  // ...<br>}<br><br>function bar(baz) {<br>  return this.snaf = baz;<br>}<br>```<br><br>上面代码中，`foo`是公有方法，内部调用了`bar.call(this, baz)`。这使得`bar`实际上成为了当前模块的私有方法。<br><br>还有一种方法是利用`Symbol`值的唯一性，将私有方法的名字命名为一个`Symbol`值。<br><br>```javascript<br>const bar = Symbol('bar');<br>const snaf = Symbol('snaf');<br><br>export default class myClass{<br><br>  // 公有方法<br>  foo(baz) {<br>    this[bar](baz);<br>  }<br><br>  // 私有方法<br>  [bar](baz) {<br>    return this[snaf] = baz;<br>  }<br><br>  // ...<br>};<br>```<br><br>上面代码中，`bar`和`snaf`都是`Symbol`值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。<br><br>### this的指向<br><br>类的方法内部如果含有`this`，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。<br><br>```javascript<br>class Logger {<br>  printName(name = 'there') {<br>    this.print(`Hello ${name}`);<br>  }<br><br>  print(text) {<br>    console.log(text);<br>  }<br>}<br><br>const logger = new Logger();<br>const { printName } = logger;<br>printName(); // TypeError: Cannot read property 'print' of undefined<br>```<br><br>上面代码中，`printName`方法中的`this`，默认指向`Logger`类的实例。但是，如果将这个方法提取出来单独使用，`this`会指向该方法运行时所在的环境，因为找不到`print`方法而导致报错。<br><br>一个比较简单的解决方法是，在构造方法中绑定`this`，这样就不会找不到`print`方法了。<br><br>```javascript<br>class Logger {<br>  constructor() {<br>    this.printName = this.printName.bind(this);<br>  }<br><br>  // ...<br>}<br>```<br><br>另一种解决方法是使用箭头函数。<br><br>```javascript<br>class Logger {<br>  constructor() {<br>    this.printName = (name = 'there') => {<br>      this.print(`Hello ${name}`);<br>    };<br>  }<br><br>  // ...<br>}<br>```<br><br>还有一种解决方法是使用`Proxy`，获取方法的时候，自动绑定`this`。<br><br>```javascript<br>function selfish (target) {<br>  const cache = new WeakMap();<br>  const handler = {<br>    get (target, key) {<br>      const value = Reflect.get(target, key);<br>      if (typeof value !== 'function') {<br>        return value;<br>      }<br>      if (!cache.has(value)) {<br>        cache.set(value, value.bind(target));<br>      }<br>      return cache.get(value);<br>    }<br>  };<br>  const proxy = new Proxy(target, handler);<br>  return proxy;<br>}<br><br>const logger = selfish(new Logger());<br>```<br><br>### 严格模式<br><br>类和模块的内部，默认就是严格模式，所以不需要使用`use strict`指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。<br><br>考虑到未来所有的代码，其实都是运行在模块之中，所以ES6实际上把整个语言升级到了严格模式。<br><br>### name属性<br><br>由于本质上，ES6的类只是ES5的构造函数的一层包装，所以函数的许多特性都被`Class`继承，包括`name`属性。<br><br>```javascript<br>class Point {}<br>Point.name // "Point"<br>```<br><br>`name`属性总是返回紧跟在`class`关键字后面的类名。<br><br>## Class的继承<br><br>### 基本用法<br><br>Class之间可以通过`extends`关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。<br><br>```javascript<br>class ColorPoint extends Point {}<br>```<br><br>上面代码定义了一个`ColorPoint`类，该类通过`extends`关键字，继承了`Point`类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个`Point`类。下面，我们在`ColorPoint`内部加上代码。<br><br>```javascript<br>class ColorPoint extends Point {<br>  constructor(x, y, color) {<br>    super(x, y); // 调用父类的constructor(x, y)<br>    this.color = color;<br>  }<br><br>  toString() {<br>    return this.color + ' ' + super.toString(); // 调用父类的toString()<br>  }<br>}<br>```<br><br>上面代码中，`constructor`方法和`toString`方法之中，都出现了`super`关键字，它在这里表示父类的构造函数，用来新建父类的`this`对象。<br><br>子类必须在`constructor`方法中调用`super`方法，否则新建实例时会报错。这是因为子类没有自己的`this`对象，而是继承父类的`this`对象，然后对其进行加工。如果不调用`super`方法，子类就得不到`this`对象。<br><br>```javascript<br>class Point { /* ... */ }<br><br>class ColorPoint extends Point {<br>  constructor() {<br>  }<br>}<br><br>let cp = new ColorPoint(); // ReferenceError<br>```<br><br>上面代码中，`ColorPoint`继承了父类`Point`，但是它的构造函数没有调用`super`方法，导致新建实例时报错。<br><br>ES5的继承，实质是先创造子类的实例对象`this`，然后再将父类的方法添加到`this`上面（`Parent.apply(this)`）。ES6的继承机制完全不同，实质是先创造父类的实例对象`this`（所以必须先调用`super`方法），然后再用子类的构造函数修改`this`。<br><br>如果子类没有定义`constructor`方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有`constructor`方法。<br><br>```javascript<br>constructor(...args) {<br>  super(...args);<br>}<br>```<br><br>另一个需要注意的地方是，在子类的构造函数中，只有调用`super`之后，才可以使用`this`关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有`super`方法才能返回父类实例。<br><br>```javascript<br>class Point {<br>  constructor(x, y) {<br>    this.x = x;<br>    this.y = y;<br>  }<br>}<br><br>class ColorPoint extends Point {<br>  constructor(x, y, color) {<br>    this.color = color; // ReferenceError<br>    super(x, y);<br>    this.color = color; // 正确<br>  }<br>}<br>```<br><br>上面代码中，子类的`constructor`方法没有调用`super`之前，就使用`this`关键字，结果报错，而放在`super`方法之后就是正确的。<br><br>下面是生成子类实例的代码。<br><br>```javascript<br>let cp = new ColorPoint(25, 8, 'green');<br><br>cp instanceof ColorPoint // true<br>cp instanceof Point // true<br>```<br><br>上面代码中，实例对象`cp`同时是`ColorPoint`和`Point`两个类的实例，这与ES5的行为完全一致。<br><br>### 类的prototype属性和\_\_proto\_\_属性<br><br>大多数浏览器的ES5实现之中，每一个对象都有`__proto__`属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和`__proto__`属性，因此同时存在两条继承链。<br><br>（1）子类的`__proto__`属性，表示构造函数的继承，总是指向父类。<br><br>（2）子类`prototype`属性的`__proto__`属性，表示方法的继承，总是指向父类的`prototype`属性。<br><br>```javascript<br>class A {<br>}<br><br>class B extends A {<br>}<br><br>B.__proto__ === A // true<br>B.prototype.__proto__ === A.prototype // true<br>```<br><br>上面代码中，子类`B`的`__proto__`属性指向父类`A`，子类`B`的`prototype`属性的`__proto__`属性指向父类`A`的`prototype`属性。<br><br>这样的结果是因为，类的继承是按照下面的模式实现的。<br><br>```javascript<br>class A {<br>}<br><br>class B {<br>}<br><br>// B的实例继承A的实例<br>Object.setPrototypeOf(B.prototype, A.prototype);<br><br>// B继承A的静态属性<br>Object.setPrototypeOf(B, A);<br>```<br><br>《对象的扩展》一章给出过`Object.setPrototypeOf`方法的实现。<br><br>```javascript<br>Object.setPrototypeOf = function (obj, proto) {<br>  obj.__proto__ = proto;<br>  return obj;<br>}<br>```<br><br>因此，就得到了上面的结果。<br><br>```javascript<br>Object.setPrototypeOf(B.prototype, A.prototype);<br>// 等同于<br>B.prototype.__proto__ = A.prototype;<br><br>Object.setPrototypeOf(B, A);<br>// 等同于<br>B.__proto__ = A;<br>```<br><br>这两条继承链，可以这样理解：作为一个对象，子类（`B`）的原型（`__proto__`属性）是父类（`A`）；作为一个构造函数，子类（`B`）的原型（`prototype`属性）是父类的实例。<br><br>```javascript<br>Object.create(A.prototype);<br>// 等同于<br>B.prototype.__proto__ = A.prototype;<br>```<br><br>### Extends 的继承目标<br><br>`extends`关键字后面可以跟多种类型的值。<br><br>```javascript<br>class B extends A {<br>}<br>```<br><br>上面代码的`A`，只要是一个有`prototype`属性的函数，就能被`B`继承。由于函数都有`prototype`属性（除了`Function.prototype`函数），因此`A`可以是任意函数。<br><br>下面，讨论三种特殊情况。<br><br>第一种特殊情况，子类继承Object类。<br><br>```javascript<br>class A extends Object {<br>}<br><br>A.__proto__ === Object // true<br>A.prototype.__proto__ === Object.prototype // true<br>```<br><br>这种情况下，`A`其实就是构造函数`Object`的复制，`A`的实例就是`Object`的实例。<br><br>第二种特殊情况，不存在任何继承。<br><br>```javascript<br>class A {<br>}<br><br>A.__proto__ === Function.prototype // true<br>A.prototype.__proto__ === Object.prototype // true<br>```<br><br>这种情况下，A作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承`Funciton.prototype`。但是，`A`调用后返回一个空对象（即`Object`实例），所以`A.prototype.__proto__`指向构造函数（`Object`）的`prototype`属性。<br><br>第三种特殊情况，子类继承`null`。<br><br>```javascript<br>class A extends null {<br>}<br><br>A.__proto__ === Function.prototype // true<br>A.prototype.__proto__ === undefined // true<br>```<br><br>这种情况与第二种情况非常像。`A`也是一个普通函数，所以直接继承`Funciton.prototype`。但是，A调用后返回的对象不继承任何方法，所以它的`__proto__`指向`Function.prototype`，即实质上执行了下面的代码。<br><br>```javascript<br>class C extends null {<br>  constructor() { return Object.create(null); }<br>}<br>```<br><br>### Object.getPrototypeOf()<br><br>`Object.getPrototypeOf`方法可以用来从子类上获取父类。<br><br>```javascript<br>Object.getPrototypeOf(ColorPoint) === Point<br>// true<br>```<br><br>因此，可以使用这个方法判断，一个类是否继承了另一个类。<br><br>### super 关键字<br><br>`super`这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。<br><br>第一种情况，`super`作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次`super`函数。<br><br>```javascript<br>class A {}<br><br>class B extends A {<br>  constructor() {<br>    super();<br>  }<br>}<br>```<br><br>上面代码中，子类`B`的构造函数之中的`super()`，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。`super`虽然代表了父类`A`的构造函数，但是返回的是子类`B`的实例，即`super`内部的`this`指的是`B`，因此`super()`在这里相当于`A.prototype.constructor.call(this)`。<br><br>注意，作为函数时，`super()`只能用在子类的构造函数之中，用在其他地方就会报错。<br><br>```javascript<br>class A {}<br><br>class B extends A {<br>  m() {<br>    super(); // 报错<br>  }<br>}<br>```<br><br>第二种情况，`super`作为对象时，指向父类的原型对象。<br><br>```javascript<br>class A {<br>  p() {<br>    return 2;<br>  }<br>}<br><br>class B extends A {<br>  constructor() {<br>    super();<br>    console.log(super.p()); // 2<br>  }<br>}<br><br>let b = new B();<br>```<br><br>上面代码中，子类`B`当中的`super.p()`，就是将`super`当作一个对象使用。这时，`super`指向`A.prototype`，所以`super.p()`就相当于`A.prototype.p()`。<br><br>这里需要注意，由于`super`指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过`super`调用的。<br><br>```javascript<br>class A {<br>  constructor() {<br>    this.p = 2;<br>  }<br>}<br><br>class B extends A {<br>  get m() {<br>    return super.p;<br>  }<br>}<br><br>let b = new B();<br>b.m // undefined<br>```<br><br>上面代码中，`p`是父类`A`实例的属性，`super.p`就引用不到它。<br><br>如果属性定义在父类的原型对象上，`super`就可以取到。<br><br>```javascript<br>class A {}<br>A.prototype.x = 2;<br><br>class B extends A {<br>  constructor() {<br>    super();<br>    console.log(super.x) // 2<br>  }<br>}<br><br>let b = new B();<br>```<br><br>上面代码中，属性`x`是定义在`A.prototype`上面的，所以`super.x`可以取到它的值。<br><br>ES6 有一个特别规定，就是通过`super`调用父类的方法时，`super`会绑定子类的`this`。<br><br>```javascript<br>class A {<br>  constructor() {<br>    this.x = 1;<br>  }<br>  print() {<br>    console.log(this.x);<br>  }<br>}<br><br>class B extends A {<br>  constructor() {<br>    super();<br>    this.x = 2;<br>  }<br>  m() {<br>    super.print();<br>  }<br>}<br><br>let b = new B();<br>b.m() // 2<br>```<br><br>上面代码中，`super.print()`虽然调用的是`A.prototype.print()`，但是`A.prototype.print()`会绑定子类`B`的`this`，导致输出的是`2`，而不是`1`。也就是说，实际上执行的是`super.print.call(this)`。<br><br>由于绑定子类的`this`，所以如果通过`super`对某个属性赋值，这时`super`就是`this`，赋值的属性会变成子类实例的属性。<br><br>```javascript<br>class A {<br>  constructor() {<br>    this.x = 1;<br>  }<br>}<br><br>class B extends A {<br>  constructor() {<br>    super();<br>    this.x = 2;<br>    super.x = 3;<br>    console.log(super.x); // undefined<br>    console.log(this.x); // 3<br>  }<br>}<br><br>let b = new B();<br>```<br><br>上面代码中，`super.x`赋值为`3`，这时等同于对`this.x`赋值为`3`。而当读取`super.x`的时候，读的是`A.prototype.x`，所以返回`undefined`。<br><br>注意，使用`super`的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。<br><br>```javascript<br>class A {}<br><br>class B extends A {<br>  constructor() {<br>    super();<br>    console.log(super); // 报错<br>  }<br>}<br>```<br><br>上面代码中，`console.log(super)`当中的`super`，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明`super`的数据类型，就不会报错。<br><br>```javascript<br>class A {}<br><br>class B extends A {<br>  constructor() {<br>    super();<br>    console.log(super.valueOf() instanceof B); // true<br>  }<br>}<br><br>let b = new B();<br>```<br><br>上面代码中，`super.valueOf()`表明`super`是一个对象，因此就不会报错。同时，由于`super`绑定`B`的`this`，所以`super.valueOf()`返回的是一个`B`的实例。<br><br>最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用`super`关键字。<br><br>```javascript<br>var obj = {<br>  toString() {<br>    return "MyObject: " + super.toString();<br>  }<br>};<br><br>obj.toString(); // MyObject: [object Object]<br>```<br><br>### 实例的\_\_proto\_\_属性<br><br>子类实例的\_\_proto\_\_属性的\_\_proto\_\_属性，指向父类实例的\_\_proto\_\_属性。也就是说，子类的原型的原型，是父类的原型。<br><br>```javascript<br>var p1 = new Point(2, 3);<br>var p2 = new ColorPoint(2, 3, 'red');<br><br>p2.__proto__ === p1.__proto__ // false<br>p2.__proto__.__proto__ === p1.__proto__ // true<br>```<br><br>上面代码中，`ColorPoint`继承了`Point`，导致前者原型的原型是后者的原型。<br><br>因此，通过子类实例的`__proto__.__proto__`属性，可以修改父类实例的行为。<br><br>```javascript<br>p2.__proto__.__proto__.printName = function () {<br>  console.log('Ha');<br>};<br><br>p1.printName() // "Ha"<br>```<br><br>上面代码在`ColorPoint`的实例`p2`上向`Point`类添加方法，结果影响到了`Point`的实例`p1`。<br><br>## 原生构造函数的继承<br><br>原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript的原生构造函数大致有下面这些。<br><br>- Boolean()<br>- Number()<br>- String()<br>- Array()<br>- Date()<br>- Function()<br>- RegExp()<br>- Error()<br>- Object()<br><br>以前，这些原生构造函数是无法继承的，比如，不能自己定义一个`Array`的子类。<br><br>```javascript<br>function MyArray() {<br>  Array.apply(this, arguments);<br>}<br><br>MyArray.prototype = Object.create(Array.prototype, {<br>  constructor: {<br>    value: MyArray,<br>    writable: true,<br>    configurable: true,<br>    enumerable: true<br>  }<br>});<br>```<br><br>上面代码定义了一个继承Array的`MyArray`类。但是，这个类的行为与`Array`完全不一致。<br><br>```javascript<br>var colors = new MyArray();<br>colors[0] = "red";<br>colors.length  // 0<br><br>colors.length = 0;<br>colors[0]  // "red"<br>```<br><br>之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过`Array.apply()`或者分配给原型对象都不行。原生构造函数会忽略`apply`方法传入的`this`，也就是说，原生构造函数的`this`无法绑定，导致拿不到内部属性。<br><br>ES5是先新建子类的实例对象`this`，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，Array构造函数有一个内部属性`[[DefineOwnProperty]]`，用来定义新属性时，更新`length`属性，这个内部属性无法在子类获取，导致子类的`length`属性行为不正常。<br><br>下面的例子中，我们想让一个普通对象继承`Error`对象。<br><br>```javascript<br>var e = {};<br><br>Object.getOwnPropertyNames(Error.call(e))<br>// [ 'stack' ]<br><br>Object.getOwnPropertyNames(e)<br>// []<br>```<br><br>上面代码中，我们想通过`Error.call(e)`这种写法，让普通对象`e`具有`Error`对象的实例属性。但是，`Error.call()`完全忽略传入的第一个参数，而是返回一个新对象，`e`本身没有任何变化。这证明了`Error.call(e)`这种写法，无法继承原生构造函数。<br><br>ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象`this`，然后再用子类的构造函数修饰`this`，使得父类的所有行为都可以继承。下面是一个继承`Array`的例子。<br><br>```javascript<br>class MyArray extends Array {<br>  constructor(...args) {<br>    super(...args);<br>  }<br>}<br><br>var arr = new MyArray();<br>arr[0] = 12;<br>arr.length // 1<br><br>arr.length = 0;<br>arr[0] // undefined<br>```<br><br>上面代码定义了一个`MyArray`类，继承了`Array`构造函数，因此就可以从`MyArray`生成数组的实例。这意味着，ES6可以自定义原生数据结构（比如Array、String等）的子类，这是ES5无法做到的。<br><br>上面这个例子也说明，`extends`关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。<br><br>```javascript<br>class VersionedArray extends Array {<br>  constructor() {<br>    super();<br>    this.history = [[]];<br>  }<br>  commit() {<br>    this.history.push(this.slice());<br>  }<br>  revert() {<br>    this.splice(0, this.length, ...this.history[this.history.length - 1]);<br>  }<br>}<br><br>var x = new VersionedArray();<br><br>x.push(1);<br>x.push(2);<br>x // [1, 2]<br>x.history // [[]]<br><br>x.commit();<br>x.history // [[], [1, 2]]<br>x.push(3);<br>x // [1, 2, 3]<br><br>x.revert();<br>x // [1, 2]<br>```<br><br>上面代码中，`VersionedArray`结构会通过`commit`方法，将自己的当前状态存入`history`属性，然后通过`revert`方法，可以撤销当前版本，回到上一个版本。除此之外，`VersionedArray`依然是一个数组，所有原生的数组方法都可以在它上面调用。<br><br>下面是一个自定义`Error`子类的例子。<br><br>```javascript<br>class ExtendableError extends Error {<br>  constructor(message) {<br>    super();<br>    this.message = message;<br>    this.stack = (new Error()).stack;<br>    this.name = this.constructor.name;<br>  }<br>}<br><br>class MyError extends ExtendableError {<br>  constructor(m) {<br>    super(m);<br>  }<br>}<br><br>var myerror = new MyError('ll');<br>myerror.message // "ll"<br>myerror instanceof Error // true<br>myerror.name // "MyError"<br>myerror.stack<br>// Error<br>//     at MyError.ExtendableError<br>//     ...<br>```<br><br>注意，继承`Object`的子类，有一个[行为差异](http://stackoverflow.com/questions/36203614/super-does-not-pass-arguments-when-instantiating-a-class-extended-from-object)。<br><br>```javascript<br>class NewObj extends Object{<br>  constructor(){<br>    super(...arguments);<br>  }<br>}<br>var o = new NewObj({attr: true});<br>console.log(o.attr === true);  // false<br>```<br><br>上面代码中，`NewObj`继承了`Object`，但是无法通过`super`方法向父类`Object`传参。这是因为ES6改变了`Object`构造函数的行为，一旦发现`Object`方法不是通过`new Object()`这种形式调用，ES6规定`Object`构造函数会忽略参数。<br><br>## Class的取值函数（getter）和存值函数（setter）<br><br>与ES5一样，在Class内部可以使用`get`和`set`关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。<br><br>```javascript<br>class MyClass {<br>  constructor() {<br>    // ...<br>  }<br>  get prop() {<br>    return 'getter';<br>  }<br>  set prop(value) {<br>    console.log('setter: '+value);<br>  }<br>}<br><br>let inst = new MyClass();<br><br>inst.prop = 123;<br>// setter: 123<br><br>inst.prop<br>// 'getter'<br>```<br><br>上面代码中，`prop`属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。<br><br>存值函数和取值函数是设置在属性的descriptor对象上的。<br><br>```javascript<br>class CustomHTMLElement {<br>  constructor(element) {<br>    this.element = element;<br>  }<br><br>  get html() {<br>    return this.element.innerHTML;<br>  }<br><br>  set html(value) {<br>    this.element.innerHTML = value;<br>  }<br>}<br><br>var descriptor = Object.getOwnPropertyDescriptor(<br>  CustomHTMLElement.prototype, "html");<br>"get" in descriptor  // true<br>"set" in descriptor  // true<br>```<br><br>上面代码中，存值函数和取值函数是定义在`html`属性的描述对象上面，这与ES5完全一致。<br><br>## Class的Generator方法<br><br>如果某个方法之前加上星号（`*`），就表示该方法是一个Generator函数。<br><br>```javascript<br>class Foo {<br>  constructor(...args) {<br>    this.args = args;<br>  }<br>  * [Symbol.iterator]() {<br>    for (let arg of this.args) {<br>      yield arg;<br>    }<br>  }<br>}<br><br>for (let x of new Foo('hello', 'world')) {<br>  console.log(x);<br>}<br>// hello<br>// world<br>```<br><br>上面代码中，Foo类的Symbol.iterator方法前有一个星号，表示该方法是一个Generator函数。Symbol.iterator方法返回一个Foo类的默认遍历器，for...of循环会自动调用这个遍历器。<br><br>## Class的静态方法<br><br>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上`static`关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。<br><br>```javascript<br>class Foo {<br>  static classMethod() {<br>    return 'hello';<br>  }<br>}<br><br>Foo.classMethod() // 'hello'<br><br>var foo = new Foo();<br>foo.classMethod()<br>// TypeError: foo.classMethod is not a function<br>```<br><br>上面代码中，`Foo`类的`classMethod`方法前有`static`关键字，表明该方法是一个静态方法，可以直接在`Foo`类上调用（`Foo.classMethod()`），而不是在`Foo`类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。<br><br>父类的静态方法，可以被子类继承。<br><br>```javascript<br>class Foo {<br>  static classMethod() {<br>    return 'hello';<br>  }<br>}<br><br>class Bar extends Foo {<br>}<br><br>Bar.classMethod(); // 'hello'<br>```<br><br>上面代码中，父类`Foo`有一个静态方法，子类`Bar`可以调用这个方法。<br><br>静态方法也是可以从`super`对象上调用的。<br><br>```javascript<br>class Foo {<br>  static classMethod() {<br>    return 'hello';<br>  }<br>}<br><br>class Bar extends Foo {<br>  static classMethod() {<br>    return super.classMethod() + ', too';<br>  }<br>}<br><br>Bar.classMethod();<br>```<br><br>## Class的静态属性和实例属性<br><br>静态属性指的是Class本身的属性，即`Class.propname`，而不是定义在实例对象（`this`）上的属性。<br><br>```javascript<br>class Foo {<br>}<br><br>Foo.prop = 1;<br>Foo.prop // 1<br>```<br><br>上面的写法为`Foo`类定义了一个静态属性`prop`。<br><br>目前，只有这种写法可行，因为ES6明确规定，Class内部只有静态方法，没有静态属性。<br><br>```javascript<br>// 以下两种写法都无效<br>class Foo {<br>  // 写法一<br>  prop: 2<br><br>  // 写法二<br>  static prop: 2<br>}<br><br>Foo.prop // undefined<br>```<br><br>ES7有一个静态属性的[提案](https://github.com/jeffmo/es-class-properties)，目前Babel转码器支持。<br><br>这个提案对实例属性和静态属性，都规定了新的写法。<br><br>（1）类的实例属性<br><br>类的实例属性可以用等式，写入类的定义之中。<br><br>```javascript<br>class MyClass {<br>  myProp = 42;<br><br>  constructor() {<br>    console.log(this.myProp); // 42<br>  }<br>}<br>```<br><br>上面代码中，`myProp`就是`MyClass`的实例属性。在`MyClass`的实例上，可以读取这个属性。<br><br>以前，我们定义实例属性，只能写在类的`constructor`方法里面。<br><br>```javascript<br>class ReactCounter extends React.Component {<br>  constructor(props) {<br>    super(props);<br>    this.state = {<br>      count: 0<br>    };<br>  }<br>}<br>```<br><br>上面代码中，构造方法`constructor`里面，定义了`this.state`属性。<br><br>有了新的写法以后，可以不在`constructor`方法里面定义。<br><br>```javascript<br>class ReactCounter extends React.Component {<br>  state = {<br>    count: 0<br>  };<br>}<br>```<br><br>这种写法比以前更清晰。<br><br>为了可读性的目的，对于那些在`constructor`里面已经定义的实例属性，新写法允许直接列出。<br><br>```javascript<br>class ReactCounter extends React.Component {<br>  constructor(props) {<br>    super(props);<br>    this.state = {<br>      count: 0<br>    };<br>  }<br>  state;<br>}<br>```<br><br>（2）类的静态属性<br><br>类的静态属性只要在上面的实例属性写法前面，加上`static`关键字就可以了。<br><br>```javascript<br>class MyClass {<br>  static myStaticProp = 42;<br><br>  constructor() {<br>    console.log(MyClass.myProp); // 42<br>  }<br>}<br>```<br><br>同样的，这个新写法大大方便了静态属性的表达。<br><br>```javascript<br>// 老写法<br>class Foo {<br>}<br>Foo.prop = 1;<br><br>// 新写法<br>class Foo {<br>  static prop = 1;<br>}<br>```<br><br>上面代码中，老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative），而不是赋值处理，语义更好。<br><br>## new.target属性<br><br>`new`是从构造函数生成实例的命令。ES6为`new`命令引入了一个`new.target`属性，（在构造函数中）返回`new`命令作用于的那个构造函数。如果构造函数不是通过`new`命令调用的，`new.target`会返回`undefined`，因此这个属性可以用来确定构造函数是怎么调用的。<br><br>```javascript<br>function Person(name) {<br>  if (new.target !== undefined) {<br>    this.name = name;<br>  } else {<br>    throw new Error('必须使用new生成实例');<br>  }<br>}<br><br>// 另一种写法<br>function Person(name) {<br>  if (new.target === Person) {<br>    this.name = name;<br>  } else {<br>    throw new Error('必须使用new生成实例');<br>  }<br>}<br><br>var person = new Person('张三'); // 正确<br>var notAPerson = Person.call(person, '张三');  // 报错<br>```<br><br>上面代码确保构造函数只能通过`new`命令调用。<br><br>Class内部调用`new.target`，返回当前Class。<br><br>```javascript<br>class Rectangle {<br>  constructor(length, width) {<br>    console.log(new.target === Rectangle);<br>    this.length = length;<br>    this.width = width;<br>  }<br>}<br><br>var obj = new Rectangle(3, 4); // 输出 true<br>```<br><br>需要注意的是，子类继承父类时，`new.target`会返回子类。<br><br>```javascript<br>class Rectangle {<br>  constructor(length, width) {<br>    console.log(new.target === Rectangle);<br>    // ...<br>  }<br>}<br><br>class Square extends Rectangle {<br>  constructor(length) {<br>    super(length, length);<br>  }<br>}<br><br>var obj = new Square(3); // 输出 false<br>```<br><br>上面代码中，`new.target`会返回子类。<br><br>利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。<br><br>```javascript<br>class Shape {<br>  constructor() {<br>    if (new.target === Shape) {<br>      throw new Error('本类不能实例化');<br>    }<br>  }<br>}<br><br>class Rectangle extends Shape {<br>  constructor(length, width) {<br>    super();<br>    // ...<br>  }<br>}<br><br>var x = new Shape();  // 报错<br>var y = new Rectangle(3, 4);  // 正确<br>```<br><br>上面代码中，`Shape`类不能被实例化，只能用于继承。<br><br>注意，在函数外部，使用`new.target`会报错。<br><br>## Mixin模式的实现<br><br>Mixin模式指的是，将多个类的接口“混入”（mix in）另一个类。它在ES6的实现如下。<br><br>```javascript<br>function mix(...mixins) {<br>  class Mix {}<br><br>  for (let mixin of mixins) {<br>    copyProperties(Mix, mixin);<br>    copyProperties(Mix.prototype, mixin.prototype);<br>  }<br><br>  return Mix;<br>}<br><br>function copyProperties(target, source) {<br>  for (let key of Reflect.ownKeys(source)) {<br>    if ( key !== "constructor"<br>      && key !== "prototype"<br>      && key !== "name"<br>    ) {<br>      let desc = Object.getOwnPropertyDescriptor(source, key);<br>      Object.defineProperty(target, key, desc);<br>    }<br>  }<br>}<br>```<br><br>上面代码的`mix`函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。<br><br>```javascript<br>class DistributedEdit extends mix(Loggable, Serializable) {<br>  // ...<br>}<br>```<br></div></div>
			<nav>
				<ul class="pager">
				<li class='previous'><a href='16.html'>&larr; 异步操作和Async函数</a></li>
			<li class='next'><a href='18.html'>Decorator&rarr;</a></li>
				</ul>
			</nav>
</div>
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
			<!-- /.row -->
			  <hr>
        <!-- Footer -->
        <footer>
            <div class="row">
                <div class="col-xs-12">
                    <p>Copyright &copy; 小龙软件工作室 2016 粤icp备16103410</p>
                </div>
            </div>
        </footer>

    </div>
    <!-- /.container -->

    <!-- jQuery -->
    <script src="../../js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="../../js/bootstrap.min.js"></script>

</body>

</html>
