<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="content-type" content="text/html;charset=utf-8">
    <meta charset="utf-8">
<meta name="360-site-verification" content="cabcfb5a0f4c0d28d604e8a69e6c0cdb" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="baidu-site-verification" content="HknqsD2zhn" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>ECMAScript 6入门-编码助手网</title>
      <meta content="为编码人员提供在线文档、模板等帮助，提升解决问题效率" name="description">
			<meta content="ECMAScript 6入门 Java, spring, tomcat, servlet, jsp, api doc, bootstrap" name="keywords">
<meta name="sogou_site_verification" content="42nApEZFKO"/>


    <!-- Bootstrap Core CSS -->
    <link href="../../css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="../../css/heroic-features.css" rel="stylesheet">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
		<script>
		var _hmt = _hmt || [];
		(function() {
		  var hm = document.createElement("script");
		  hm.src = "//hm.baidu.com/hm.js?dd1361ca20a10cc161e72d4bc4fef6df";
		  var s = document.getElementsByTagName("script")[0];
		  s.parentNode.insertBefore(hm, s);
		})();
		</script>

</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">编码助手网</a>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav">
                    <li>
                        <a href="/">首页</a>
                    </li>
										<li>
                        <a href="/template.html">模板</a>
                    </li>
										<li>
												<a href="/doc.html">文档</a>
										</li>
                    <li>
                        <a href="/contact.html">联系我们</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Content -->
    <div class="container">

			<div class="row">
					<div class="col-xs-4">
						<h4>ECMAScript 6入门</h4>
						<h6>感谢Ruan YiFeng提供内容</h6>
<ul><li><a href='./0.html'>前言</a></li><li><a href='./1.html'>ECMAScript 6简介</a></li><li><a href='./2.html'>let和const命令</a></li><li><a href='./3.html'>变量的解构赋值</a></li><li><a href='./4.html'>字符串的扩展</a></li><li><a href='./5.html'>正则的扩展</a></li><li><a href='./6.html'>数值的扩展</a></li><li><a href='./7.html'>数组的扩展</a></li><li><a href='./8.html'>函数的扩展</a></li><li><a href='./9.html'>对象的扩展</a></li><li><a href='./10.html'>Symbol</a></li><li><a href='./11.html'>Proxy和Reflect</a></li><li><a href='./12.html'>Set和Map数据结构</a></li><li><a href='./13.html'>Iterator和for...of循环</a></li><li><a href='./14.html'>Generator函数</a></li><li><a href='./15.html'>Promise对象</a></li><li><a href='./16.html'>异步操作和Async函数</a></li><li><a href='./17.html'>Class</a></li><li><a href='./18.html'>Decorator</a></li><li><a href='./19.html'>Module</a></li><li><a href='./20.html'>编程风格</a></li><li><a href='./21.html'>读懂规格</a></li><li><a href='./22.html'>二进制数组</a></li><li><a href='./23.html'>SIMD</a></li><li><a href='./24.html'>参考链接</a></li><li></li>
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
<div class="col-xs-8">
	<nav>
		<ul class="pager">
			<li class='previous'><a href='4.html'>&larr; 字符串的扩展</a></li>
		<li class='next'><a href='6.html'>数值的扩展&rarr;</a></li>
		</ul>
	</nav>
			<div class="row"><div class="col-xs-12"># 正则的扩展<br><br>## RegExp构造函数<br><br>在ES5中，RegExp构造函数的参数有两种情况。<br><br>第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。<br><br>```javascript<br>var regex = new RegExp('xyz', 'i');<br>// 等价于<br>var regex = /xyz/i;<br>```<br><br>第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。<br><br>```javascript<br>var regex = new RegExp(/xyz/i);<br>// 等价于<br>var regex = /xyz/i;<br>```<br><br>但是，ES5不允许此时使用第二个参数，添加修饰符，否则会报错。<br><br>```javascript<br>var regex = new RegExp(/xyz/, 'i');<br>// Uncaught TypeError: Cannot supply flags when constructing one RegExp from another<br>```<br><br>ES6改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。<br><br>```javascript<br>new RegExp(/abc/ig, 'i').flags<br>// "i"<br>```<br><br>上面代码中，原有正则对象的修饰符是`ig`，它会被第二个参数`i`覆盖。<br><br>## 字符串的正则方法<br><br>字符串对象共有4个方法，可以使用正则表达式：`match()`、`replace()`、`search()`和`split()`。<br><br>ES6将这4个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。<br><br>- `String.prototype.match` 调用 `RegExp.prototype[Symbol.match]`<br>- `String.prototype.replace` 调用 `RegExp.prototype[Symbol.replace]`<br>- `String.prototype.search` 调用 `RegExp.prototype[Symbol.search]`<br>- `String.prototype.split` 调用 `RegExp.prototype[Symbol.split]`<br><br>## u修饰符<br><br>ES6对正则表达式添加了`u`修饰符，含义为“Unicode模式”，用来正确处理大于`\uFFFF`的Unicode字符。也就是说，会正确处理四个字节的UTF-16编码。<br><br>```javascript<br>/^\uD83D/u.test('\uD83D\uDC2A')<br>// false<br>/^\uD83D/.test('\uD83D\uDC2A')<br>// true<br>```<br><br>上面代码中，`\uD83D\uDC2A`是一个四个字节的UTF-16编码，代表一个字符。但是，ES5不支持四个字节的UTF-16编码，会将其识别为两个字符，导致第二行代码结果为`true`。加了`u`修饰符以后，ES6就会识别其为一个字符，所以第一行代码结果为`false`。<br><br>一旦加上`u`修饰符号，就会修改下面这些正则表达式的行为。<br><br>**（1）点字符**<br><br>点（`.`）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于`0xFFFF`的Unicode字符，点字符不能识别，必须加上`u`修饰符。<br><br>```javascript<br>var s = '𠮷';<br><br>/^.$/.test(s) // false<br>/^.$/u.test(s) // true<br>```<br><br>上面代码表示，如果不添加`u`修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。<br><br>**（2）Unicode字符表示法**<br><br>ES6新增了使用大括号表示Unicode字符，这种表示法在正则表达式中必须加上`u`修饰符，才能识别。<br><br>```javascript<br>/\u{61}/.test('a') // false<br>/\u{61}/u.test('a') // true<br>/\u{20BB7}/u.test('𠮷') // true<br>```<br><br>上面代码表示，如果不加`u`修饰符，正则表达式无法识别`\u{61}`这种表示法，只会认为这匹配61个连续的`u`。<br><br>**（3）量词**<br><br>使用`u`修饰符后，所有量词都会正确识别码点大于`0xFFFF`的Unicode字符。<br><br>```javascript<br>/a{2}/.test('aa') // true<br>/a{2}/u.test('aa') // true<br>/𠮷{2}/.test('𠮷𠮷') // false<br>/𠮷{2}/u.test('𠮷𠮷') // true<br>```<br><br>另外，只有在使用`u`修饰符的情况下，Unicode表达式当中的大括号才会被正确解读，否则会被解读为量词。<br><br>```javascript<br>/^\u{3}$/.test('uuu') // true<br>```<br><br>上面代码中，由于正则表达式没有`u`修饰符，所以大括号被解读为量词。加上`u`修饰符，就会被解读为Unicode表达式。<br><br>**（4）预定义模式**<br><br>`u`修饰符也影响到预定义模式，能否正确识别码点大于`0xFFFF`的Unicode字符。<br><br>```javascript<br>/^\S$/.test('𠮷') // false<br>/^\S$/u.test('𠮷') // true<br>```<br><br>上面代码的`\S`是预定义模式，匹配所有不是空格的字符。只有加了`u`修饰符，它才能正确匹配码点大于`0xFFFF`的Unicode字符。<br><br>利用这一点，可以写出一个正确返回字符串长度的函数。<br><br>```javascript<br>function codePointLength(text) {<br>  var result = text.match(/[\s\S]/gu);<br>  return result ? result.length : 0;<br>}<br><br>var s = '𠮷𠮷';<br><br>s.length // 4<br>codePointLength(s) // 2<br>```<br><br>**（5）i修饰符**<br><br>有些Unicode字符的编码不同，但是字型很相近，比如，`\u004B`与`\u212A`都是大写的K。<br><br>```javascript<br>/[a-z]/i.test('\u212A') // false<br>/[a-z]/iu.test('\u212A') // true<br>```<br><br>上面代码中，不加`u`修饰符，就无法识别非规范的K字符。<br><br>## y修饰符<br><br>除了`u`修饰符，ES6还为正则表达式添加了`y`修饰符，叫做“粘连”（sticky）修饰符。<br><br>`y`修饰符的作用与`g`修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，`g`修饰符只要剩余位置中存在匹配就可，而`y`修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。<br><br>```javascript<br>var s = 'aaa_aa_a';<br>var r1 = /a+/g;<br>var r2 = /a+/y;<br><br>r1.exec(s) // ["aaa"]<br>r2.exec(s) // ["aaa"]<br><br>r1.exec(s) // ["aa"]<br>r2.exec(s) // null<br>```<br><br>上面代码有两个正则表达式，一个使用`g`修饰符，另一个使用`y`修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是`_aa_a`。由于`g`修饰没有位置要求，所以第二次执行会返回结果，而`y`修饰符要求匹配必须从头部开始，所以返回`null`。<br><br>如果改一下正则表达式，保证每次都能头部匹配，`y`修饰符就会返回结果了。<br><br>```javascript<br>var s = 'aaa_aa_a';<br>var r = /a+_/y;<br><br>r.exec(s) // ["aaa_"]<br>r.exec(s) // ["aa_"]<br>```<br><br>上面代码每次匹配，都是从剩余字符串的头部开始。<br><br>使用`lastIndex`属性，可以更好地说明`y`修饰符。<br><br>```javascript<br>const REGEX = /a/g;<br><br>// 指定从2号位置（y）开始匹配<br>REGEX.lastIndex = 2;<br><br>// 匹配成功<br>const match = REGEX.exec('xaya');<br><br>// 在3号位置匹配成功<br>match.index // 3<br><br>// 下一次匹配从4号位开始<br>REGEX.lastIndex // 4<br><br>// 4号位开始匹配失败<br>REGEX.exec('xaxa') // null<br>```<br><br>上面代码中，`lastIndex`属性指定每次搜索的开始位置，`g`修饰符从这个位置开始向后搜索，直到发现匹配为止。<br><br>`y`修饰符同样遵守`lastIndex`属性，但是要求必须在`lastIndex`指定的位置发现匹配。<br><br>```javascript<br>const REGEX = /a/y;<br><br>// 指定从2号位置开始匹配<br>REGEX.lastIndex = 2;<br><br>// 不是粘连，匹配失败<br>REGEX.exec('xaya') // null<br><br>// 指定从3号位置开始匹配<br>REGEX.lastIndex = 3;<br><br>// 3号位置是粘连，匹配成功<br>const match = REGEX.exec('xaxa');<br>match.index // 3<br>REGEX.lastIndex // 4<br>```<br><br>进一步说，`y`修饰符号隐含了头部匹配的标志`^`。<br><br>```javascript<br>/b/y.exec('aba')<br>// null<br>```<br><br>上面代码由于不能保证头部匹配，所以返回`null`。`y`修饰符的设计本意，就是让头部匹配的标志`^`在全局匹配中都有效。<br><br>在`split`方法中使用`y`修饰符，原字符串必须以分隔符开头。这也意味着，只要匹配成功，数组的第一个成员肯定是空字符串。<br><br>```javascript<br>// 没有找到匹配<br>'x##'.split(/#/y)<br>// [ 'x##' ]<br><br>// 找到两个匹配<br>'##x'.split(/#/y)<br>// [ '', '', 'x' ]<br>```<br><br>后续的分隔符只有紧跟前面的分隔符，才会被识别。<br><br>```javascript<br>'#x#'.split(/#/y)<br>// [ '', 'x#' ]<br><br>'##'.split(/#/y)<br>// [ '', '', '' ]<br>```<br><br>下面是字符串对象的`replace`方法的例子。<br><br>```javascript<br>const REGEX = /a/gy;<br>'aaxa'.replace(REGEX, '-') // '--xa'<br>```<br><br>上面代码中，最后一个`a`因为不是出现下一次匹配的头部，所以不会被替换。<br><br>单单一个`y`修饰符对`match`方法，只能返回第一个匹配，必须与`g`修饰符联用，才能返回所有匹配。<br><br>```javascript<br>'a1a2a3'.match(/a\d/y) // ["a1"]<br>'a1a2a3'.match(/a\d/gy) // ["a1", "a2", "a3"]<br>```<br><br>`y`修饰符的一个应用，是从字符串提取token（词元），`y`修饰符确保了匹配之间不会有漏掉的字符。<br><br>```javascript<br>const TOKEN_Y = /\s*(\+|[0-9]+)\s*/y;<br>const TOKEN_G  = /\s*(\+|[0-9]+)\s*/g;<br><br>tokenize(TOKEN_Y, '3 + 4')<br>// [ '3', '+', '4' ]<br>tokenize(TOKEN_G, '3 + 4')<br>// [ '3', '+', '4' ]<br><br>function tokenize(TOKEN_REGEX, str) {<br>  let result = [];<br>  let match;<br>  while (match = TOKEN_REGEX.exec(str)) {<br>    result.push(match[1]);<br>  }<br>  return result;<br>}<br>```<br><br>上面代码中，如果字符串里面没有非法字符，`y`修饰符与`g`修饰符的提取结果是一样的。但是，一旦出现非法字符，两者的行为就不一样了。<br><br>```javascript<br>tokenize(TOKEN_Y, '3x + 4')<br>// [ '3' ]<br>tokenize(TOKEN_G, '3x + 4')<br>// [ '3', '+', '4' ]<br>```<br><br>上面代码中，`g`修饰符会忽略非法字符，而`y`修饰符不会，这样就很容易发现错误。<br><br>## sticky属性<br><br>与`y`修饰符相匹配，ES6的正则对象多了`sticky`属性，表示是否设置了`y`修饰符。<br><br>```javascript<br>var r = /hello\d/y;<br>r.sticky // true<br>```<br><br>## flags属性<br><br>ES6为正则表达式新增了`flags`属性，会返回正则表达式的修饰符。<br><br>```javascript<br>// ES5的source属性<br>// 返回正则表达式的正文<br>/abc/ig.source<br>// "abc"<br><br>// ES6的flags属性<br>// 返回正则表达式的修饰符<br>/abc/ig.flags<br>// 'gi'<br>```<br><br>## RegExp.escape()<br><br>字符串必须转义，才能作为正则模式。<br><br>```javascript<br>function escapeRegExp(str) {<br>  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');<br>}<br><br>let str = '/path/to/resource.html?search=query';<br>escapeRegExp(str)<br>// "\/path\/to\/resource\.html\?search=query"<br>```<br><br>上面代码中，`str`是一个正常字符串，必须使用反斜杠对其中的特殊字符转义，才能用来作为一个正则匹配的模式。<br><br>已经有[提议](https://esdiscuss.org/topic/regexp-escape)将这个需求标准化，作为RegExp对象的静态方法[RegExp.escape()](https://github.com/benjamingr/RexExp.escape)，放入ES7。2015年7月31日，TC39认为，这个方法有安全风险，又不愿这个方法变得过于复杂，没有同意将其列入ES7，但这不失为一个真实的需求。<br><br>```javascript<br>RegExp.escape('The Quick Brown Fox');<br>// "The Quick Brown Fox"<br><br>RegExp.escape('Buy it. use it. break it. fix it.');<br>// "Buy it\. use it\. break it\. fix it\."<br><br>RegExp.escape('(*.*)');<br>// "\(\*\.\*\)"<br>```<br><br>字符串转义以后，可以使用RegExp构造函数生成正则模式。<br><br>```javascript<br>var str = 'hello. how are you?';<br>var regex = new RegExp(RegExp.escape(str), 'g');<br>assert.equal(String(regex), '/hello\. how are you\?/g');<br>```<br><br>目前，该方法可以用上文的`escapeRegExp`函数或者垫片模块[regexp.escape](https://github.com/ljharb/regexp.escape)实现。<br><br>```javascript<br>var escape = require('regexp.escape');<br>escape('hi. how are you?');<br>// "hi\\. how are you\\?"<br>```<br><br>## 后行断言<br><br>JavaScript语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative lookahead），不支持后行断言（lookbehind）和后行否定断言（negative lookbehind）。<br><br>目前，有一个[提案](https://github.com/goyakin/es-regexp-lookbehind)，在ES7加入后行断言。V8引擎4.9版已经支持，Chrome浏览器49版打开”experimental JavaScript features“开关（地址栏键入`about:flags`），就可以使用这项功能。<br><br>”先行断言“指的是，`x`只有在`y`前面才匹配，必须写成`/x(?=y)/`。比如，只匹配百分号之前的数字，要写成`/\d+(?=%)/`。”先行否定断言“指的是，`x`只有不在`y`前面才匹配，必须写成`/x(?!y)/`。比如，只匹配不在百分号之前的数字，要写成`/\d+(?!%)/`。<br><br>```javascript<br>/\d+(?=%)/.exec('100% of US presidents have been male')  // ["100"]<br>/\d+(?!%)/.exec('that’s all 44 of them')                 // ["44"]<br>```<br><br>上面两个字符串，如果互换正则表达式，就会匹配失败。另外，还可以看到，”先行断言“括号之中的部分（`(?=%)`），是不计入返回结果的。<br><br>"后行断言"正好与"先行断言"相反，`x`只有在`y`后面才匹配，必须写成`/(?<=y)x/`。比如，只匹配美元符号之后的数字，要写成`/(?<=\$)\d+/`。”后行否定断言“则与”先行否定断言“相反，`x`只有不在`y`后面才匹配，必须写成`/(?<!y)x/`。比如，只匹配不在美元符号后面的数字，要写成`/(?<!\$)\d+/`。<br><br>```javascript<br>/(?<=\$)\d+/.exec('Benjamin Franklin is on the $100 bill')  // ["100"]<br>/(?<!\$)\d+/.exec('it’s is worth about €90')                // ["90"]<br>```<br><br>上面的例子中，"后行断言"的括号之中的部分（`(?<=\$)`），也是不计入返回结果。<br><br>"后行断言"的实现，需要先匹配`/(?<=y)x/`的`x`，然后再回到左边，匹配`y`的部分。这种"先右后左"的执行顺序，与所有其他正则操作相反，导致了一些不符合预期的行为。<br><br>首先，”后行断言“的组匹配，与正常情况下结果是不一样的。<br><br>```javascript<br>/(?<=(\d+)(\d+))$/.exec('1053') // ["", "1", "053"]<br>/^(\d+)(\d+)$/.exec('1053') // ["1053", "105", "3"]<br>```<br><br>上面代码中，需要捕捉两个组匹配。没有"后行断言"时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是`105`和`3`。而"后行断言"时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是`1`和`053`。<br><br>其次，"后行断言"的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。<br><br>```javascript<br>/(?<=(o)d\1)r/.exec('hodor')  // null<br>/(?<=\1d(o))r/.exec('hodor')  // ["r", "o"]<br>```<br><br>上面代码中，如果后行断言的反斜杠引用（`\1`）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。<br><br>## Unicode属性类<br><br>目前，有一个[提案](https://github.com/mathiasbynens/es-regexp-unicode-property-escapes)，引入了一种新的类的写法`\p{...}`和`\P{...}`，允许正则表达式匹配符合Unicode某种属性的所有字符。<br><br>```javascript<br>const regexGreekSymbol = /\p{Script=Greek}/u;<br>regexGreekSymbol.test('π') // u<br>```<br><br>上面代码中，`\p{Script=Greek}`指定匹配一个希腊文字母，所以匹配`π`成功。<br><br>Unicode属性类要指定属性名和属性值。<br><br>```javascript<br>\p{UnicodePropertyName=UnicodePropertyValue}<br>```<br><br>对于某些属性，可以只写属性名。<br><br>```javascript<br>\p{UnicodePropertyName}<br>```<br><br>`\P{…}`是`\p{…}`的反向匹配，即匹配不满足条件的字符。<br><br>注意，这两种类只对Unicode有效，所以使用的时候一定要加上`u`修饰符。如果不加`u`修饰符，正则表达式使用`\p`和`\P`会报错，ECMAScript预留了这两个类。<br><br>由于Unicode的各种属性非常多，所以这种新的类的表达能力非常强。<br><br>```javascript<br>const regex = /^\p{Decimal_Number}+$/u;<br>regex.test('𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼') // true<br>```<br><br>上面代码中，属性类指定匹配所有十进制字符，可以看到各种字型的十进制字符都会匹配成功。<br><br>`\p{Number}`甚至能匹配罗马数字。<br><br>```javascript<br>// 匹配所有数字<br>const regex = /^\p{Number}+$/u;<br>regex.test('²³¹¼½¾') // true<br>regex.test('㉛㉜㉝') // true<br>regex.test('ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ') // true<br>```<br><br>下面是其他一些例子。<br><br>```javascript<br>// 匹配各种文字的所有字母，等同于Unicode版的\w<br>[\p{Alphabetic}\p{Mark}\p{Decimal_Number}\p{Connector_Punctuation}\p{Join_Control}]<br><br>// 匹配各种文字的所有非字母的字符，等同于Unicode版的\W<br>[\p{Alphabetic}\p{Mark}\p{Decimal_Number}\p{Connector_Punctuation}\p{Join_Control}]<br><br>// 匹配所有的箭头字符<br>const regexArrows = /^\p{Block=Arrows}+$/u;<br>regexArrows.test('←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩') // true<br>```<br><br></div></div>
			<nav>
				<ul class="pager">
				<li class='previous'><a href='4.html'>&larr; 字符串的扩展</a></li>
			<li class='next'><a href='6.html'>数值的扩展&rarr;</a></li>
				</ul>
			</nav>
</div>
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
			<!-- /.row -->
			  <hr>
        <!-- Footer -->
        <footer>
            <div class="row">
                <div class="col-xs-12">
                    <p>Copyright &copy; 小龙软件工作室 2016 粤icp备16103410</p>
                </div>
            </div>
        </footer>

    </div>
    <!-- /.container -->

    <!-- jQuery -->
    <script src="../../js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="../../js/bootstrap.min.js"></script>

</body>

</html>
