<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="content-type" content="text/html;charset=utf-8">
    <meta charset="utf-8">
<meta name="360-site-verification" content="cabcfb5a0f4c0d28d604e8a69e6c0cdb" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="baidu-site-verification" content="HknqsD2zhn" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>ECMAScript 6入门-编码助手网</title>
      <meta content="为编码人员提供在线文档、模板等帮助，提升解决问题效率" name="description">
			<meta content="ECMAScript 6入门 Java, spring, tomcat, servlet, jsp, api doc, bootstrap" name="keywords">
<meta name="sogou_site_verification" content="42nApEZFKO"/>


    <!-- Bootstrap Core CSS -->
    <link href="../../css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="../../css/heroic-features.css" rel="stylesheet">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
		<script>
		var _hmt = _hmt || [];
		(function() {
		  var hm = document.createElement("script");
		  hm.src = "//hm.baidu.com/hm.js?dd1361ca20a10cc161e72d4bc4fef6df";
		  var s = document.getElementsByTagName("script")[0];
		  s.parentNode.insertBefore(hm, s);
		})();
		</script>

</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">编码助手网</a>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav">
                    <li>
                        <a href="/">首页</a>
                    </li>
										<li>
                        <a href="/template.html">模板</a>
                    </li>
										<li>
												<a href="/doc.html">文档</a>
										</li>
                    <li>
                        <a href="/contact.html">联系我们</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Content -->
    <div class="container">

			<div class="row">
					<div class="col-xs-4">
						<h4>ECMAScript 6入门</h4>
						<h6>感谢Ruan YiFeng提供内容</h6>
<ul><li><a href='./0.html'>前言</a></li><li><a href='./1.html'>ECMAScript 6简介</a></li><li><a href='./2.html'>let和const命令</a></li><li><a href='./3.html'>变量的解构赋值</a></li><li><a href='./4.html'>字符串的扩展</a></li><li><a href='./5.html'>正则的扩展</a></li><li><a href='./6.html'>数值的扩展</a></li><li><a href='./7.html'>数组的扩展</a></li><li><a href='./8.html'>函数的扩展</a></li><li><a href='./9.html'>对象的扩展</a></li><li><a href='./10.html'>Symbol</a></li><li><a href='./11.html'>Proxy和Reflect</a></li><li><a href='./12.html'>Set和Map数据结构</a></li><li><a href='./13.html'>Iterator和for...of循环</a></li><li><a href='./14.html'>Generator函数</a></li><li><a href='./15.html'>Promise对象</a></li><li><a href='./16.html'>异步操作和Async函数</a></li><li><a href='./17.html'>Class</a></li><li><a href='./18.html'>Decorator</a></li><li><a href='./19.html'>Module</a></li><li><a href='./20.html'>编程风格</a></li><li><a href='./21.html'>读懂规格</a></li><li><a href='./22.html'>二进制数组</a></li><li><a href='./23.html'>SIMD</a></li><li><a href='./24.html'>参考链接</a></li><li></li>
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
<div class="col-xs-8">
	<nav>
		<ul class="pager">
			<li class='previous'><a href='10.html'>&larr; Symbol</a></li>
		<li class='next'><a href='12.html'>Set和Map数据结构&rarr;</a></li>
		</ul>
	</nav>
			<div class="row"><div class="col-xs-12"># Proxy和Reflect<br><br>## Proxy概述<br><br>Proxy用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。<br><br>Proxy可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。<br><br>```javascript<br>var obj = new Proxy({}, {<br>  get: function (target, key, receiver) {<br>    console.log(`getting ${key}!`);<br>    return Reflect.get(target, key, receiver);<br>  },<br>  set: function (target, key, value, receiver) {<br>    console.log(`setting ${key}!`);<br>    return Reflect.set(target, key, value, receiver);<br>  }<br>});<br>```<br><br>上面代码对一个空对象架设了一层拦截，重定义了属性的读取（`get`）和设置（`set`）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象`obj`，去读写它的属性，就会得到下面的结果。<br><br>```javascript<br>obj.count = 1<br>//  setting count!<br>++obj.count<br>//  getting count!<br>//  setting count!<br>//  2<br>```<br><br>上面代码说明，Proxy实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。<br><br>ES6原生提供Proxy构造函数，用来生成Proxy实例。<br><br>```javascript<br>var proxy = new Proxy(target, handler);<br>```<br><br>Proxy对象的所有用法，都是上面这种形式，不同的只是`handler`参数的写法。其中，`new Proxy()`表示生成一个Proxy实例，target参数表示所要拦截的目标对象，`handler`参数也是一个对象，用来定制拦截行为。<br><br>下面是另一个拦截读取属性行为的例子。<br><br>```javascript<br>var proxy = new Proxy({}, {<br>  get: function(target, property) {<br>    return 35;<br>  }<br>});<br><br>proxy.time // 35<br>proxy.name // 35<br>proxy.title // 35<br>```<br><br>上面代码中，作为构造函数，Proxy接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有Proxy的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个`get`方法，用来拦截对目标对象属性的访问请求。`get`方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回`35`，所以访问任何属性都得到`35`。<br><br>注意，要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。<br><br>如果`handler`没有设置任何拦截，那就等同于直接通向原对象。<br><br>```javascript<br>var target = {};<br>var handler = {};<br>var proxy = new Proxy(target, handler);<br>proxy.a = 'b';<br>target.a // "b"<br>```<br><br>上面代码中，`handler`是一个空对象，没有任何拦截效果，访问`handeler`就等同于访问`target`。<br><br>一个技巧是将Proxy对象，设置到`object.proxy`属性，从而可以在`object`对象上调用。<br><br>```javascript<br>var object = { proxy: new Proxy(target, handler) };<br>```<br><br>Proxy实例也可以作为其他对象的原型对象。<br><br>```javascript<br>var proxy = new Proxy({}, {<br>  get: function(target, property) {<br>    return 35;<br>  }<br>});<br><br>let obj = Object.create(proxy);<br>obj.time // 35<br>```<br><br>上面代码中，`proxy`对象是`obj`对象的原型，`obj`对象本身并没有`time`属性，所以根据原型链，会在`proxy`对象上读取该属性，导致被拦截。<br><br>同一个拦截器函数，可以设置拦截多个操作。<br><br>```javascript<br>var handler = {<br>  get: function(target, name) {<br>    if (name === 'prototype') {<br>      return Object.prototype;<br>    }<br>    return 'Hello, ' + name;<br>  },<br><br>  apply: function(target, thisBinding, args) {<br>    return args[0];<br>  },<br><br>  construct: function(target, args) {<br>    return {value: args[1]};<br>  }<br>};<br><br>var fproxy = new Proxy(function(x, y) {<br>  return x + y;<br>}, handler);<br><br>fproxy(1, 2) // 1<br>new fproxy(1,2) // {value: 2}<br>fproxy.prototype === Object.prototype // true<br>fproxy.foo // "Hello, foo"<br>```<br><br>下面是Proxy支持的拦截操作一览。<br><br>对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。<br><br>**（1）get(target, propKey, receiver)**<br><br>拦截对象属性的读取，比如`proxy.foo`和`proxy['foo']`。<br><br>最后一个参数`receiver`是一个对象，可选，参见下面`Reflect.get`的部分。<br><br>**（2）set(target, propKey, value, receiver)**<br><br>拦截对象属性的设置，比如`proxy.foo = v`或`proxy['foo'] = v`，返回一个布尔值。<br><br>**（3）has(target, propKey)**<br><br>拦截`propKey in proxy`的操作，以及对象的`hasOwnProperty`方法，返回一个布尔值。<br><br>**（4）deleteProperty(target, propKey)**<br><br>拦截`delete proxy[propKey]`的操作，返回一个布尔值。<br><br>**（5）ownKeys(target)**<br><br>拦截`Object.getOwnPropertyNames(proxy)`、`Object.getOwnPropertySymbols(proxy)`、`Object.keys(proxy)`，返回一个数组。该方法返回对象所有自身的属性，而`Object.keys()`仅返回对象可遍历的属性。<br><br>**（6）getOwnPropertyDescriptor(target, propKey)**<br><br>拦截`Object.getOwnPropertyDescriptor(proxy, propKey)`，返回属性的描述对象。<br><br>**（7）defineProperty(target, propKey, propDesc)**<br><br>拦截`Object.defineProperty(proxy, propKey, propDesc）`、`Object.defineProperties(proxy, propDescs)`，返回一个布尔值。<br><br>**（8）preventExtensions(target)**<br><br>拦截`Object.preventExtensions(proxy)`，返回一个布尔值。<br><br>**（9）getPrototypeOf(target)**<br><br>拦截`Object.getPrototypeOf(proxy)`，返回一个对象。<br><br>**（10）isExtensible(target)**<br><br>拦截`Object.isExtensible(proxy)`，返回一个布尔值。<br><br>**（11）setPrototypeOf(target, proto)**<br><br>拦截`Object.setPrototypeOf(proxy, proto)`，返回一个布尔值。<br><br>如果目标对象是函数，那么还有两种额外操作可以拦截。<br><br>**（12）apply(target, object, args)**<br><br>拦截Proxy实例作为函数调用的操作，比如`proxy(...args)`、`proxy.call(object, ...args)`、`proxy.apply(...)`。<br><br>**（13）construct(target, args)**<br><br>拦截Proxy实例作为构造函数调用的操作，比如`new proxy(...args)`。<br><br>## Proxy实例的方法<br><br>下面是上面这些拦截方法的详细介绍。<br><br>### get()<br><br>`get`方法用于拦截某个属性的读取操作。上文已经有一个例子，下面是另一个拦截读取操作的例子。<br><br>```javascript<br>var person = {<br>  name: "张三"<br>};<br><br>var proxy = new Proxy(person, {<br>  get: function(target, property) {<br>    if (property in target) {<br>      return target[property];<br>    } else {<br>      throw new ReferenceError("Property \"" + property + "\" does not exist.");<br>    }<br>  }<br>});<br><br>proxy.name // "张三"<br>proxy.age // 抛出一个错误<br>```<br><br>上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回`undefined`。<br><br>`get`方法可以继承。<br><br>```javascript<br>let proto = new Proxy({}, {<br>  get(target, propertyKey, receiver) {<br>    console.log('GET '+propertyKey);<br>    return target[propertyKey];<br>  }<br>});<br><br>let obj = Object.create(proto);<br>obj.xxx // "GET xxx"<br>```<br><br>上面代码中，拦截操作定义在Prototype对象上面，所以如果读取`obj`对象继承的属性时，拦截会生效。<br><br>下面的例子使用`get`拦截，实现数组读取负数的索引。<br><br>```javascript<br>function createArray(...elements) {<br>  let handler = {<br>    get(target, propKey, receiver) {<br>      let index = Number(propKey);<br>      if (index < 0) {<br>        propKey = String(target.length + index);<br>      }<br>      return Reflect.get(target, propKey, receiver);<br>    }<br>  };<br><br>  let target = [];<br>  target.push(...elements);<br>  return new Proxy(target, handler);<br>}<br><br>let arr = createArray('a', 'b', 'c');<br>arr[-1] // c<br>```<br><br>上面代码中，数组的位置参数是`-1`，就会输出数组的倒数最后一个成员。<br><br>利用Proxy，可以将读取属性的操作（`get`），转变为执行某个函数，从而实现属性的链式操作。<br><br>```javascript<br>var pipe = (function () {<br>  return function (value) {<br>    var funcStack = [];<br>    var oproxy = new Proxy({} , {<br>      get : function (pipeObject, fnName) {<br>        if (fnName === 'get') {<br>          return funcStack.reduce(function (val, fn) {<br>            return fn(val);<br>          },value);<br>        }<br>        funcStack.push(window[fnName]);<br>        return oproxy;<br>      }<br>    });<br><br>    return oproxy;<br>  }<br>}());<br><br>var double = n => n * 2;<br>var pow    = n => n * n;<br>var reverseInt = n => n.toString().split("").reverse().join("") | 0;<br><br>pipe(3).double.pow.reverseInt.get; // 63<br>```<br><br>上面代码设置Proxy以后，达到了将函数名链式使用的效果。<br><br>下面的例子则是利用`get`拦截，实现一个生成各种DOM节点的通用函数`dom`。<br><br>```javascript<br>const dom = new Proxy({}, {<br>  get(target, property) {<br>    return function(attrs = {}, ...children) {<br>      const el = document.createElement(property);<br>      for (let prop of Object.keys(attrs)) {<br>        el.setAttribute(prop, attrs[prop]);<br>      }<br>      for (let child of children) {<br>        if (typeof child === 'string') {<br>          child = document.createTextNode(child);<br>        }<br>        el.appendChild(child);<br>      }<br>      return el;<br>    }<br>  }<br>});<br><br>const el = dom.div({},<br>  'Hello, my name is ',<br>  dom.a({href: '//example.com'}, 'Mark'),<br>  '. I like:',<br>  dom.ul({},<br>    dom.li({}, 'The web'),<br>    dom.li({}, 'Food'),<br>    dom.li({}, '…actually that\'s it')<br>  )<br>);<br><br>document.body.appendChild(el);<br>```<br><br>### set()<br><br>`set`方法用来拦截某个属性的赋值操作。<br><br>假定`Person`对象有一个`age`属性，该属性应该是一个不大于200的整数，那么可以使用`Proxy`保证`age`的属性值符合要求。<br><br>```javascript<br>let validator = {<br>  set: function(obj, prop, value) {<br>    if (prop === 'age') {<br>      if (!Number.isInteger(value)) {<br>        throw new TypeError('The age is not an integer');<br>      }<br>      if (value > 200) {<br>        throw new RangeError('The age seems invalid');<br>      }<br>    }<br><br>    // 对于age以外的属性，直接保存<br>    obj[prop] = value;<br>  }<br>};<br><br>let person = new Proxy({}, validator);<br><br>person.age = 100;<br><br>person.age // 100<br>person.age = 'young' // 报错<br>person.age = 300 // 报错<br>```<br><br>上面代码中，由于设置了存值函数`set`，任何不符合要求的`age`属性赋值，都会抛出一个错误。利用`set`方法，还可以数据绑定，即每当对象发生变化时，会自动更新DOM。<br><br>有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合`get`和`set`方法，就可以做到防止这些内部属性被外部读写。<br><br>```javascript<br>var handler = {<br>  get (target, key) {<br>    invariant(key, 'get');<br>    return target[key];<br>  },<br>  set (target, key, value) {<br>    invariant(key, 'set');<br>    return true;<br>  }<br>};<br>function invariant (key, action) {<br>  if (key[0] === '_') {<br>    throw new Error(`Invalid attempt to ${action} private "${key}" property`);<br>  }<br>}<br>var target = {};<br>var proxy = new Proxy(target, handler);<br>proxy._prop<br>// Error: Invalid attempt to get private "_prop" property<br>proxy._prop = 'c'<br>// Error: Invalid attempt to set private "_prop" property<br>```<br><br>上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。<br><br>### apply()<br><br>`apply`方法拦截函数的调用、call和apply操作。<br><br>```javascript<br>var handler = {<br>  apply (target, ctx, args) {<br>    return Reflect.apply(...arguments);<br>  }<br>};<br>```<br><br>`apply`方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（`this`）和目标对象的参数数组。<br><br>下面是一个例子。<br><br>```javascript<br>var target = function () { return 'I am the target'; };<br>var handler = {<br>  apply: function () {<br>    return 'I am the proxy';<br>  }<br>};<br><br>var p = new Proxy(target, handler);<br><br>p()<br>// "I am the proxy"<br>```<br><br>上面代码中，变量`p`是Proxy的实例，当它作为函数调用时（`p()`），就会被`apply`方法拦截，返回一个字符串。<br><br>下面是另外一个例子。<br><br>```javascript<br>var twice = {<br>  apply (target, ctx, args) {<br>    return Reflect.apply(...arguments) * 2;<br>  }<br>};<br>function sum (left, right) {<br>  return left + right;<br>};<br>var proxy = new Proxy(sum, twice);<br>proxy(1, 2) // 6<br>proxy.call(null, 5, 6) // 22<br>proxy.apply(null, [7, 8]) // 30<br>```<br><br>上面代码中，每当执行`proxy`函数（直接调用或`call`和`apply`调用），就会被`apply`方法拦截。<br><br>另外，直接调用`Reflect.apply`方法，也会被拦截。<br><br>```javascript<br>Reflect.apply(proxy, null, [9, 10]) // 38<br>```<br><br>### has()<br><br>`has`方法用来拦截`HasProperty`操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是`in`运算符。<br><br>下面的例子使用`has`方法隐藏某些属性，不被`in`运算符发现。<br><br>```javascript<br>var handler = {<br>  has (target, key) {<br>    if (key[0] === '_') {<br>      return false;<br>    }<br>    return key in target;<br>  }<br>};<br>var target = { _prop: 'foo', prop: 'foo' };<br>var proxy = new Proxy(target, handler);<br>'_prop' in proxy // false<br>```<br><br>上面代码中，如果原对象的属性名的第一个字符是下划线，`proxy.has`就会返回`false`，从而不会被`in`运算符发现。<br><br>如果原对象不可配置或者禁止扩展，这时`has`拦截会报错。<br><br>```javascript<br>var obj = { a: 10 };<br>Object.preventExtensions(obj);<br>var p = new Proxy(obj, {<br>  has: function(target, prop) {<br>    return false;<br>  }<br>});<br><br>'a' in p // TypeError is thrown<br>```<br><br>上面代码中，`obj`对象禁止扩展，结果使用`has`拦截就会报错。<br><br>值得注意的是，`has`方法拦截的是`HasProperty`操作，而不是`HasOwnProperty`操作，即`has`方法不判断一个属性是对象自身的属性，还是继承的属性。<br><br>另外，虽然`for...in`循环也用到了`in`运算符，但是`has`拦截对`for...in`循环不生效。<br><br>```javascript<br>let stu1 = {name: '张三', score: 59};<br>let stu2 = {name: '李四', score: 99};<br><br>let handler = {<br>  has(target, prop) {<br>    if (prop === 'score' && target[prop] < 60) {<br>      console.log(`${target.name} 不及格`);<br>      return false;<br>    }<br>    return prop in target;<br>  }<br>}<br><br>let oproxy1 = new Proxy(stu1, handler);<br>let oproxy2 = new Proxy(stu2, handler);<br><br>'score' in oproxy1<br>// 张三 不及格<br>// false<br><br>'score' in oproxy2<br>// true<br><br>for (let a in oproxy1) {<br>  console.log(oproxy1[a]);<br>}<br>// 张三<br>// 59<br><br>for (let b in oproxy2) {<br>  console.log(oproxy2[b]);<br>}<br>// 李四<br>// 99<br>```<br><br>上面代码中，`has`拦截只对`in`循环生效，对`for...in`循环不生效，导致不符合要求的属性没有被排除在`for...in`循环之外。<br><br>### construct()<br><br>`construct`方法用于拦截`new`命令，下面是拦截对象的写法。<br><br>```javascript<br>var handler = {<br>  construct (target, args, newTarget) {<br>    return new target(...args);<br>  }<br>};<br>```<br><br>`construct`方法可以接受两个参数。<br><br>- `target`: 目标对象<br>- `args`：构建函数的参数对象<br><br>下面是一个例子。<br><br>```javascript<br>var p = new Proxy(function() {}, {<br>  construct: function(target, args) {<br>    console.log('called: ' + args.join(', '));<br>    return { value: args[0] * 10 };<br>  }<br>});<br><br>new p(1).value<br>// "called: 1"<br>// 10<br>```<br><br>`construct`方法返回的必须是一个对象，否则会报错。<br><br>```javascript<br>var p = new Proxy(function() {}, {<br>  construct: function(target, argumentsList) {<br>    return 1;<br>  }<br>});<br><br>new p() // 报错<br>```<br><br>### deleteProperty()<br><br>`deleteProperty`方法用于拦截`delete`操作，如果这个方法抛出错误或者返回`false`，当前属性就无法被`delete`命令删除。<br><br>```javascript<br>var handler = {<br>  deleteProperty (target, key) {<br>    invariant(key, 'delete');<br>    return true;<br>  }<br>};<br>function invariant (key, action) {<br>  if (key[0] === '_') {<br>    throw new Error(`Invalid attempt to ${action} private "${key}" property`);<br>  }<br>}<br><br>var target = { _prop: 'foo' };<br>var proxy = new Proxy(target, handler);<br>delete proxy._prop<br>// Error: Invalid attempt to delete private "_prop" property<br>```<br><br>上面代码中，`deleteProperty`方法拦截了`delete`操作符，删除第一个字符为下划线的属性会报错。<br><br>### defineProperty()<br><br>`defineProperty`方法拦截了`Object.defineProperty`操作。<br><br>```javascript<br>var handler = {<br>  defineProperty (target, key, descriptor) {<br>    return false;<br>  }<br>};<br>var target = {};<br>var proxy = new Proxy(target, handler);<br>proxy.foo = 'bar'<br>// TypeError: proxy defineProperty handler returned false for property '"foo"'<br>```<br><br>上面代码中，`defineProperty`方法返回`false`，导致添加新属性会抛出错误。<br><br>### getOwnPropertyDescriptor()<br><br>`getOwnPropertyDescriptor`方法拦截`Object.getOwnPropertyDescriptor`，返回一个属性描述对象或者`undefined`。<br><br>```javascript<br>var handler = {<br>  getOwnPropertyDescriptor (target, key) {<br>    if (key[0] === '_') {<br>      return;<br>    }<br>    return Object.getOwnPropertyDescriptor(target, key);<br>  }<br>};<br>var target = { _foo: 'bar', baz: 'tar' };<br>var proxy = new Proxy(target, handler);<br>Object.getOwnPropertyDescriptor(proxy, 'wat')<br>// undefined<br>Object.getOwnPropertyDescriptor(proxy, '_foo')<br>// undefined<br>Object.getOwnPropertyDescriptor(proxy, 'baz')<br>// { value: 'tar', writable: true, enumerable: true, configurable: true }<br>```<br><br>上面代码中，`handler.getOwnPropertyDescriptor`方法对于第一个字符为下划线的属性名会返回`undefined`。<br><br>### getPrototypeOf()<br><br>`getPrototypeOf`方法主要用来拦截`Object.getPrototypeOf()`运算符，以及其他一些操作。<br><br>- `Object.prototype.__proto__`<br>- `Object.prototype.isPrototypeOf()`<br>- `Object.getPrototypeOf()`<br>- `Reflect.getPrototypeOf()`<br>- `instanceof`运算符<br><br>下面是一个例子。<br><br>```javascript<br>var proto = {};<br>var p = new Proxy({}, {<br>  getPrototypeOf(target) {<br>    return proto;<br>  }<br>});<br>Object.getPrototypeOf(p) === proto // true<br>```<br><br>上面代码中，`getPrototypeOf`方法拦截`Object.getPrototypeOf()`，返回`proto`对象。<br><br>### isExtensible()<br><br>`isExtensible`方法拦截`Object.isExtensible`操作。<br><br>```javascript<br>var p = new Proxy({}, {<br>  isExtensible: function(target) {<br>    console.log("called");<br>    return true;<br>  }<br>});<br><br>Object.isExtensible(p)<br>// "called"<br>// true<br>```<br><br>上面代码设置了`isExtensible`方法，在调用`Object.isExtensible`时会输出`called`。<br><br>这个方法有一个强限制，如果不能满足下面的条件，就会抛出错误。<br><br>```javascript<br>Object.isExtensible(proxy) === Object.isExtensible(target)<br>```<br><br>下面是一个例子。<br><br>```javascript<br>var p = new Proxy({}, {<br>  isExtensible: function(target) {<br>    return false;<br>  }<br>});<br><br>Object.isExtensible(p) // 报错<br>```<br><br>### ownKeys()<br><br>`ownKeys`方法用来拦截`Object.keys()`操作。<br><br>```javascript<br>let target = {};<br><br>let handler = {<br>  ownKeys(target) {<br>    return ['hello', 'world'];<br>  }<br>};<br><br>let proxy = new Proxy(target, handler);<br><br>Object.keys(proxy)<br>// [ 'hello', 'world' ]<br>```<br><br>上面代码拦截了对于`target`对象的`Object.keys()`操作，返回预先设定的数组。<br><br>下面的例子是拦截第一个字符为下划线的属性名。<br><br>```javascript<br>let target = {<br>  _bar: 'foo',<br>  _prop: 'bar',<br>  prop: 'baz'<br>};<br><br>let handler = {<br>  ownKeys (target) {<br>    return Reflect.ownKeys(target).filter(key => key[0] !== '_');<br>  }<br>};<br><br>let proxy = new Proxy(target, handler);<br>for (let key of Object.keys(proxy)) {<br>  console.log(target[key]);<br>}<br>// "baz"<br>```<br><br>### preventExtensions()<br><br>`preventExtensions`方法拦截`Object.preventExtensions()`。该方法必须返回一个布尔值。<br><br>这个方法有一个限制，只有当`Object.isExtensible(proxy)`为`false`（即不可扩展）时，`proxy.preventExtensions`才能返回`true`，否则会报错。<br><br>```javascript<br>var p = new Proxy({}, {<br>  preventExtensions: function(target) {<br>    return true;<br>  }<br>});<br><br>Object.preventExtensions(p) // 报错<br>```<br><br>上面代码中，`proxy.preventExtensions`方法返回`true`，但这时`Object.isExtensible(proxy)`会返回`true`，因此报错。<br><br>为了防止出现这个问题，通常要在`proxy.preventExtensions`方法里面，调用一次`Object.preventExtensions`。<br><br>```javascript<br>var p = new Proxy({}, {<br>  preventExtensions: function(target) {<br>    console.log("called");<br>    Object.preventExtensions(target);<br>    return true;<br>  }<br>});<br><br>Object.preventExtensions(p)<br>// "called"<br>// true<br>```<br><br>### setPrototypeOf()<br><br>`setPrototypeOf`方法主要用来拦截`Object.setPrototypeOf`方法。<br><br>下面是一个例子。<br><br>```javascript<br>var handler = {<br>  setPrototypeOf (target, proto) {<br>    throw new Error('Changing the prototype is forbidden');<br>  }<br>};<br>var proto = {};<br>var target = function () {};<br>var proxy = new Proxy(target, handler);<br>proxy.setPrototypeOf(proxy, proto);<br>// Error: Changing the prototype is forbidden<br>```<br><br>上面代码中，只要修改`target`的原型对象，就会报错。<br><br>## Proxy.revocable()<br><br>Proxy.revocable方法返回一个可取消的Proxy实例。<br><br>```javascript<br>let target = {};<br>let handler = {};<br><br>let {proxy, revoke} = Proxy.revocable(target, handler);<br><br>proxy.foo = 123;<br>proxy.foo // 123<br><br>revoke();<br>proxy.foo // TypeError: Revoked<br>```<br><br>`Proxy.revocable`方法返回一个对象，该对象的`proxy`属性是`Proxy`实例，`revoke`属性是一个函数，可以取消`Proxy`实例。上面代码中，当执行`revoke`函数之后，再访问`Proxy`实例，就会抛出一个错误。<br><br>## Reflect概述<br><br>`Reflect`对象与`Proxy`对象一样，也是ES6为了操作对象而提供的新API。`Reflect`对象的设计目的有这样几个。<br><br>（1） 将`Object`对象的一些明显属于语言内部的方法（比如`Object.defineProperty`），放到`Reflect`对象上。现阶段，某些方法同时在`Object`和`Reflect`对象上部署，未来的新方法将只部署在`Reflect`对象上。<br><br>（2） 修改某些Object方法的返回结果，让其变得更合理。比如，`Object.defineProperty(obj, name, desc)`在无法定义属性时，会抛出一个错误，而`Reflect.defineProperty(obj, name, desc)`则会返回`false`。<br><br>```javascript<br>// 老写法<br>try {<br>  Object.defineProperty(target, property, attributes);<br>  // success<br>} catch (e) {<br>  // failure<br>}<br><br>// 新写法<br>if (Reflect.defineProperty(target, property, attributes)) {<br>  // success<br>} else {<br>  // failure<br>}<br>```<br><br>（3） 让`Object`操作都变成函数行为。某些`Object`操作是命令式，比如`name in obj`和`delete obj[name]`，而`Reflect.has(obj, name)`和`Reflect.deleteProperty(obj, name)`让它们变成了函数行为。<br><br>```javascript<br>// 老写法<br>'assign' in Object // true<br><br>// 新写法<br>Reflect.has(Object, 'assign') // true<br>```<br><br>（4）`Reflect`对象的方法与`Proxy`对象的方法一一对应，只要是`Proxy`对象的方法，就能在`Reflect`对象上找到对应的方法。这就让`Proxy`对象可以方便地调用对应的`Reflect`方法，完成默认行为，作为修改行为的基础。也就是说，不管`Proxy`怎么修改默认行为，你总可以在`Reflect`上获取默认行为。<br><br>```javascript<br>Proxy(target, {<br>  set: function(target, name, value, receiver) {<br>    var success = Reflect.set(target,name, value, receiver);<br>    if (success) {<br>      log('property ' + name + ' on ' + target + ' set to ' + value);<br>    }<br>    return success;<br>  }<br>});<br>```<br><br>上面代码中，`Proxy`方法拦截`target`对象的属性赋值行为。它采用`Reflect.set`方法将值赋值给对象的属性，然后再部署额外的功能。<br><br>下面是另一个例子。<br><br>```javascript<br>var loggedObj = new Proxy(obj, {<br>  get(target, name) {<br>    console.log('get', target, name);<br>    return Reflect.get(target, name);<br>  },<br>  deleteProperty(target, name) {<br>    console.log('delete' + name);<br>    return Reflect.deleteProperty(target, name);<br>  },<br>  has(target, name) {<br>    console.log('has' + name);<br>    return Reflect.has(target, name);<br>  }<br>});<br>```<br><br>上面代码中，每一个`Proxy`对象的拦截操作（`get`、`delete`、`has`），内部都调用对应的Reflect方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。<br><br>有了`Reflect`对象以后，很多操作会更易读。<br><br>```javascript<br>// 老写法<br>Function.prototype.apply.call(Math.floor, undefined, [1.75]) // 1<br><br>// 新写法<br>Reflect.apply(Math.floor, undefined, [1.75]) // 1<br>```<br><br>## Reflect对象的方法<br><br>`Reflect`对象的方法清单如下，共13个。<br><br>- Reflect.apply(target,thisArg,args)<br>- Reflect.construct(target,args)<br>- Reflect.get(target,name,receiver)<br>- Reflect.set(target,name,value,receiver)<br>- Reflect.defineProperty(target,name,desc)<br>- Reflect.deleteProperty(target,name)<br>- Reflect.has(target,name)<br>- Reflect.ownKeys(target)<br>- Reflect.isExtensible(target)<br>- Reflect.preventExtensions(target)<br>- Reflect.getOwnPropertyDescriptor(target, name)<br>- Reflect.getPrototypeOf(target)<br>- Reflect.setPrototypeOf(target, prototype)<br><br>上面这些方法的作用，大部分与`Object`对象的同名方法的作用都是相同的，而且它与`Proxy`对象的方法是一一对应的。下面是对其中几个方法的解释。<br><br>**（1）Reflect.get(target, name, receiver)**<br><br>查找并返回`target`对象的`name`属性，如果没有该属性，则返回`undefined`。<br><br>如果`name`属性部署了读取函数，则读取函数的this绑定`receiver`。<br><br>```javascript<br>var obj = {<br>  get foo() { return this.bar(); },<br>  bar: function() { ... }<br>};<br><br>// 下面语句会让 this.bar()<br>// 变成调用 wrapper.bar()<br>Reflect.get(obj, "foo", wrapper);<br>```<br><br>**（2）Reflect.set(target, name, value, receiver)**<br><br>设置`target`对象的`name`属性等于`value`。如果`name`属性设置了赋值函数，则赋值函数的`this`绑定`receiver`。<br><br>**（3）Reflect.has(obj, name)**<br><br>等同于`name in obj`。<br><br>**（4）Reflect.deleteProperty(obj, name)**<br><br>等同于`delete obj[name]`。<br><br>**（5）Reflect.construct(target, args)**<br><br>等同于`new target(...args)`，这提供了一种不使用`new`，来调用构造函数的方法。<br><br>**（6）Reflect.getPrototypeOf(obj)**<br><br>读取对象的`__proto__`属性，对应`Object.getPrototypeOf(obj)`。<br><br>**（7）Reflect.setPrototypeOf(obj, newProto)**<br><br>设置对象的`__proto__`属性，对应`Object.setPrototypeOf(obj, newProto)`。<br><br>**（8）Reflect.apply(fun,thisArg,args)**<br><br>等同于`Function.prototype.apply.call(fun,thisArg,args)`。一般来说，如果要绑定一个函数的this对象，可以这样写`fn.apply(obj, args)`，但是如果函数定义了自己的`apply`方法，就只能写成`Function.prototype.apply.call(fn, obj, args)`，采用Reflect对象可以简化这种操作。<br><br>另外，需要注意的是，`Reflect.set()`、`Reflect.defineProperty()`、`Reflect.freeze()`、`Reflect.seal()`和`Reflect.preventExtensions()`返回一个布尔值，表示操作是否成功。它们对应的Object方法，失败时都会抛出错误。<br><br>```javascript<br>// 失败时抛出错误<br>Object.defineProperty(obj, name, desc);<br>// 失败时返回false<br>Reflect.defineProperty(obj, name, desc);<br>```<br><br>上面代码中，`Reflect.defineProperty`方法的作用与`Object.defineProperty`是一样的，都是为对象定义一个属性。但是，`Reflect.defineProperty`方法失败时，不会抛出错误，只会返回`false`。<br></div></div>
			<nav>
				<ul class="pager">
				<li class='previous'><a href='10.html'>&larr; Symbol</a></li>
			<li class='next'><a href='12.html'>Set和Map数据结构&rarr;</a></li>
				</ul>
			</nav>
</div>
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
			<!-- /.row -->
			  <hr>
        <!-- Footer -->
        <footer>
            <div class="row">
                <div class="col-xs-12">
                    <p>Copyright &copy; 小龙软件工作室 2016 粤icp备16103410</p>
                </div>
            </div>
        </footer>

    </div>
    <!-- /.container -->

    <!-- jQuery -->
    <script src="../../js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="../../js/bootstrap.min.js"></script>

</body>

</html>
