<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="content-type" content="text/html;charset=utf-8">
    <meta charset="utf-8">
<meta name="360-site-verification" content="cabcfb5a0f4c0d28d604e8a69e6c0cdb" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="baidu-site-verification" content="HknqsD2zhn" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>ECMAScript 6入门-编码助手网</title>
      <meta content="为编码人员提供在线文档、模板等帮助，提升解决问题效率" name="description">
			<meta content="ECMAScript 6入门 Java, spring, tomcat, servlet, jsp, api doc, bootstrap" name="keywords">
<meta name="sogou_site_verification" content="42nApEZFKO"/>


    <!-- Bootstrap Core CSS -->
    <link href="../../css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="../../css/heroic-features.css" rel="stylesheet">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
		<script>
		var _hmt = _hmt || [];
		(function() {
		  var hm = document.createElement("script");
		  hm.src = "//hm.baidu.com/hm.js?dd1361ca20a10cc161e72d4bc4fef6df";
		  var s = document.getElementsByTagName("script")[0];
		  s.parentNode.insertBefore(hm, s);
		})();
		</script>

</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">编码助手网</a>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav">
                    <li>
                        <a href="/">首页</a>
                    </li>
										<li>
                        <a href="/template.html">模板</a>
                    </li>
										<li>
												<a href="/doc.html">文档</a>
										</li>
                    <li>
                        <a href="/contact.html">联系我们</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Content -->
    <div class="container">

			<div class="row">
					<div class="col-xs-4">
						<h4>ECMAScript 6入门</h4>
						<h6>感谢Ruan YiFeng提供内容</h6>
<ul><li><a href='./0.html'>前言</a></li><li><a href='./1.html'>ECMAScript 6简介</a></li><li><a href='./2.html'>let和const命令</a></li><li><a href='./3.html'>变量的解构赋值</a></li><li><a href='./4.html'>字符串的扩展</a></li><li><a href='./5.html'>正则的扩展</a></li><li><a href='./6.html'>数值的扩展</a></li><li><a href='./7.html'>数组的扩展</a></li><li><a href='./8.html'>函数的扩展</a></li><li><a href='./9.html'>对象的扩展</a></li><li><a href='./10.html'>Symbol</a></li><li><a href='./11.html'>Proxy和Reflect</a></li><li><a href='./12.html'>Set和Map数据结构</a></li><li><a href='./13.html'>Iterator和for...of循环</a></li><li><a href='./14.html'>Generator函数</a></li><li><a href='./15.html'>Promise对象</a></li><li><a href='./16.html'>异步操作和Async函数</a></li><li><a href='./17.html'>Class</a></li><li><a href='./18.html'>Decorator</a></li><li><a href='./19.html'>Module</a></li><li><a href='./20.html'>编程风格</a></li><li><a href='./21.html'>读懂规格</a></li><li><a href='./22.html'>二进制数组</a></li><li><a href='./23.html'>SIMD</a></li><li><a href='./24.html'>参考链接</a></li><li></li>
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
<div class="col-xs-8">
	<nav>
		<ul class="pager">
			<li class='previous'><a href='3.html'>&larr; 变量的解构赋值</a></li>
		<li class='next'><a href='5.html'>正则的扩展&rarr;</a></li>
		</ul>
	</nav>
			<div class="row"><div class="col-xs-12"># 字符串的扩展<br><br>ES6加强了对Unicode的支持，并且扩展了字符串对象。<br><br>## 字符的Unicode表示法<br><br>JavaScript允许采用`\uxxxx`形式表示一个字符，其中“xxxx”表示字符的码点。<br><br>```javascript<br>"\u0061"<br>// "a"<br>```<br><br>但是，这种表示法只限于`\u0000`——`\uFFFF`之间的字符。超出这个范围的字符，必须用两个双字节的形式表达。<br><br>```javascript<br>"\uD842\uDFB7"<br>// "𠮷"<br><br>"\u20BB7"<br>// " 7"<br>```<br><br>上面代码表示，如果直接在“\u”后面跟上超过`0xFFFF`的数值（比如`\u20BB7`），JavaScript会理解成“\u20BB+7”。由于`\u20BB`是一个不可打印字符，所以只会显示一个空格，后面跟着一个7。<br><br>ES6对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。<br><br>```javascript<br>"\u{20BB7}"<br>// "𠮷"<br><br>"\u{41}\u{42}\u{43}"<br>// "ABC"<br><br>let hello = 123;<br>hell\u{6F} // 123<br><br>'\u{1F680}' === '\uD83D\uDE80'<br>// true<br>```<br><br>上面代码中，最后一个例子表明，大括号表示法与四字节的UTF-16编码是等价的。<br><br>有了这种表示法之后，JavaScript共有6种方法可以表示一个字符。<br><br>```javascript<br>'\z' === 'z'  // true<br>'\172' === 'z' // true<br>'\x7A' === 'z' // true<br>'\u007A' === 'z' // true<br>'\u{7A}' === 'z' // true<br>```<br><br>## codePointAt()<br><br>JavaScript内部，字符以UTF-16的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode码点大于0xFFFF的字符），JavaScript会认为它们是两个字符。<br><br>```javascript<br>var s = "𠮷";<br><br>s.length // 2<br>s.charAt(0) // ''<br>s.charAt(1) // ''<br>s.charCodeAt(0) // 55362<br>s.charCodeAt(1) // 57271<br>```<br><br>上面代码中，汉字“𠮷”的码点是`0x20BB7`，UTF-16编码为`0xD842 0xDFB7`（十进制为55362 57271），需要4个字节储存。对于这种4个字节的字符，JavaScript不能正确处理，字符串长度会误判为2，而且`charAt`方法无法读取整个字符，`charCodeAt`方法只能分别返回前两个字节和后两个字节的值。<br><br>ES6提供了`codePointAt`方法，能够正确处理4个字节储存的字符，返回一个字符的码点。<br><br>```javascript<br>var s = '𠮷a';<br><br>s.codePointAt(0) // 134071<br>s.codePointAt(1) // 57271<br><br>s.charCodeAt(2) // 97<br>```<br><br>`codePointAt`方法的参数，是字符在字符串中的位置（从0开始）。上面代码中，JavaScript将“𠮷a”视为三个字符，codePointAt方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点134071（即十六进制的`20BB7`）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，`codePointAt`方法的结果与`charCodeAt`方法相同。<br><br>总之，`codePointAt`方法会正确返回32位的UTF-16字符的码点。对于那些两个字节储存的常规字符，它的返回结果与`charCodeAt`方法相同。<br><br>`codePointAt`方法返回的是码点的十进制值，如果想要十六进制的值，可以使用`toString`方法转换一下。<br><br>```javascript<br>var s = '𠮷a';<br><br>s.codePointAt(0).toString(16) // "20bb7"<br>s.charCodeAt(2).toString(16) // "61"<br>```<br><br>你可能注意到了，`codePointAt`方法的参数，仍然是不正确的。比如，上面代码中，字符`a`在字符串`s`的正确位置序号应该是1，但是必须向`charCodeAt`方法传入2。解决这个问题的一个办法是使用`for...of`循环，因为它会正确识别32位的UTF-16字符。<br><br>```javascript<br>var s = '𠮷a';<br>for (let ch of s) {<br>  console.log(ch.codePointAt(0).toString(16));<br>}<br>// 20bb7<br>// 61<br>```<br><br>`codePointAt`方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。<br><br>```javascript<br>function is32Bit(c) {<br>  return c.codePointAt(0) > 0xFFFF;<br>}<br><br>is32Bit("𠮷") // true<br>is32Bit("a") // false<br>```<br><br>## String.fromCodePoint()<br><br>ES5提供`String.fromCharCode`方法，用于从码点返回对应字符，但是这个方法不能识别32位的UTF-16字符（Unicode编号大于`0xFFFF`）。<br><br>```javascript<br>String.fromCharCode(0x20BB7)<br>// "ஷ"<br>```<br><br>上面代码中，`String.fromCharCode`不能识别大于`0xFFFF`的码点，所以`0x20BB7`就发生了溢出，最高位`2`被舍弃了，最后返回码点`U+0BB7`对应的字符，而不是码点`U+20BB7`对应的字符。<br><br>ES6提供了`String.fromCodePoint`方法，可以识别`0xFFFF`的字符，弥补了`String.fromCharCode`方法的不足。在作用上，正好与`codePointAt`方法相反。<br><br>```javascript<br>String.fromCodePoint(0x20BB7)<br>// "𠮷"<br>String.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\uD83D\uDE80y'<br>// true<br>```<br><br>上面代码中，如果`String.fromCodePoint`方法有多个参数，则它们会被合并成一个字符串返回。<br><br>注意，`fromCodePoint`方法定义在`String`对象上，而`codePointAt`方法定义在字符串的实例对象上。<br><br>## 字符串的遍历器接口<br><br>ES6为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被`for...of`循环遍历。<br><br>```javascript<br>for (let codePoint of 'foo') {<br>  console.log(codePoint)<br>}<br>// "f"<br>// "o"<br>// "o"<br>```<br><br>除了遍历字符串，这个遍历器最大的优点是可以识别大于`0xFFFF`的码点，传统的`for`循环无法识别这样的码点。<br><br>```javascript<br>var text = String.fromCodePoint(0x20BB7);<br><br>for (let i = 0; i < text.length; i++) {<br>  console.log(text[i]);<br>}<br>// " "<br>// " "<br><br>for (let i of text) {<br>  console.log(i);<br>}<br>// "𠮷"<br>```<br><br>上面代码中，字符串`text`只有一个字符，但是`for`循环会认为它包含两个字符（都不可打印），而`for...of`循环会正确识别出这一个字符。<br><br>## at()<br><br>ES5对字符串对象提供`charAt`方法，返回字符串给定位置的字符。该方法不能识别码点大于`0xFFFF`的字符。<br><br>```javascript<br>'abc'.charAt(0) // "a"<br>'𠮷'.charAt(0) // "\uD842"<br>```<br><br>上面代码中，`charAt`方法返回的是UTF-16编码的第一个字节，实际上是无法显示的。<br><br>目前，有一个提案，提出字符串实例的`at`方法，可以识别Unicode编号大于`0xFFFF`的字符，返回正确的字符。<br><br>```javascript<br>'abc'.at(0) // "a"<br>'𠮷'.at(0) // "𠮷"<br>```<br><br>这个方法可以通过[垫片库](https://github.com/es-shims/String.prototype.at)实现。<br><br>## normalize()<br><br>许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode提供了两种方法。一种是直接提供带重音符号的字符，比如`Ǒ`（\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如`O`（\u004F）和`ˇ`（\u030C）合成`Ǒ`（\u004F\u030C）。<br><br>这两种表示方法，在视觉和语义上都等价，但是JavaScript不能识别。<br><br>```javascript<br>'\u01D1'==='\u004F\u030C' //false<br><br>'\u01D1'.length // 1<br>'\u004F\u030C'.length // 2<br>```<br><br>上面代码表示，JavaScript将合成字符视为两个字符，导致两种表示方法不相等。<br><br>ES6提供字符串实例的`normalize()`方法，用来将字符的不同表示方法统一为同样的形式，这称为Unicode正规化。<br><br>```javascript<br>'\u01D1'.normalize() === '\u004F\u030C'.normalize()<br>// true<br>```<br><br>`normalize`方法可以接受一个参数来指定`normalize`的方式，参数的四个可选值如下。<br><br>- `NFC`，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。<br>- `NFD`，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。<br>- `NFKC`，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，`normalize`方法不能识别中文。）<br>- `NFKD`，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。<br><br>```javascript<br>'\u004F\u030C'.normalize('NFC').length // 1<br>'\u004F\u030C'.normalize('NFD').length // 2<br>```<br><br>上面代码表示，`NFC`参数返回字符的合成形式，`NFD`参数返回字符的分解形式。<br><br>不过，`normalize`方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过Unicode编号区间判断。<br><br>## includes(), startsWith(), endsWith()<br><br>传统上，JavaScript只有`indexOf`方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。<br><br>- **includes()**：返回布尔值，表示是否找到了参数字符串。<br>- **startsWith()**：返回布尔值，表示参数字符串是否在源字符串的头部。<br>- **endsWith()**：返回布尔值，表示参数字符串是否在源字符串的尾部。<br><br>```javascript<br>var s = 'Hello world!';<br><br>s.startsWith('Hello') // true<br>s.endsWith('!') // true<br>s.includes('o') // true<br>```<br><br>这三个方法都支持第二个参数，表示开始搜索的位置。<br><br>```javascript<br>var s = 'Hello world!';<br><br>s.startsWith('world', 6) // true<br>s.endsWith('Hello', 5) // true<br>s.includes('Hello', 6) // false<br>```<br><br>上面代码表示，使用第二个参数`n`时，`endsWith`的行为与其他两个方法有所不同。它针对前`n`个字符，而其他两个方法针对从第`n`个位置直到字符串结束。<br><br>## repeat()<br><br>`repeat`方法返回一个新字符串，表示将原字符串重复`n`次。<br><br>```javascript<br>'x'.repeat(3) // "xxx"<br>'hello'.repeat(2) // "hellohello"<br>'na'.repeat(0) // ""<br>```<br><br>参数如果是小数，会被取整。<br><br>```javascript<br>'na'.repeat(2.9) // "nana"<br>```<br><br>如果`repeat`的参数是负数或者`Infinity`，会报错。<br><br>```javascript<br>'na'.repeat(Infinity)<br>// RangeError<br>'na'.repeat(-1)<br>// RangeError<br>```<br><br>但是，如果参数是0到-1之间的小数，则等同于0，这是因为会先进行取整运算。0到-1之间的小数，取整以后等于`-0`，`repeat`视同为0。<br><br>```javascript<br>'na'.repeat(-0.9) // ""<br>```<br><br>参数`NaN`等同于0。<br><br>```javascript<br>'na'.repeat(NaN) // ""<br>```<br><br>如果`repeat`的参数是字符串，则会先转换成数字。<br><br>```javascript<br>'na'.repeat('na') // ""<br>'na'.repeat('3') // "nanana"<br>```<br><br>## padStart()，padEnd()<br><br>ES7推出了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。`padStart`用于头部补全，`padEnd`用于尾部补全。<br><br>```javascript<br>'x'.padStart(5, 'ab') // 'ababx'<br>'x'.padStart(4, 'ab') // 'abax'<br><br>'x'.padEnd(5, 'ab') // 'xabab'<br>'x'.padEnd(4, 'ab') // 'xaba'<br>```<br><br>上面代码中，`padStart`和`padEnd`一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。<br><br>如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。<br><br>```javascript<br>'xxx'.padStart(2, 'ab') // 'xxx'<br>'xxx'.padEnd(2, 'ab') // 'xxx'<br>```<br><br>如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。<br><br>```javascript<br>'abc'.padStart(10, '0123456789')<br>// '0123456abc'<br>```<br><br>如果省略第二个参数，则会用空格补全长度。<br><br>```javascript<br>'x'.padStart(4) // '   x'<br>'x'.padEnd(4) // 'x   '<br>```<br><br>`padStart`的常见用途是为数值补全指定位数。下面代码生成10位的数值字符串。<br><br>```javascript<br>'1'.padStart(10, '0') // "0000000001"<br>'12'.padStart(10, '0') // "0000000012"<br>'123456'.padStart(10, '0') // "0000123456"<br>```<br><br>另一个用途是提示字符串格式。<br><br>```javascript<br>'12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12"<br>'09-12'.padStart(10, 'YYYY-MM-DD') // "YYYY-09-12"<br>```<br><br>## 模板字符串<br><br>传统的JavaScript语言，输出模板通常是这样写的。<br><br>```javascript<br>$('#result').append(<br>  'There are <b>' + basket.count + '</b> ' +<br>  'items in your basket, ' +<br>  '<em>' + basket.onSale +<br>  '</em> are on sale!'<br>);<br>```<br><br>上面这种写法相当繁琐不方便，ES6引入了模板字符串解决这个问题。<br><br>```javascript<br>$('#result').append(`<br>  There are <b>${basket.count}</b> items<br>   in your basket, <em>${basket.onSale}</em><br>  are on sale!<br>`);<br>```<br><br>模板字符串（template string）是增强版的字符串，用反引号（&#96;）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。<br><br>```javascript<br>// 普通字符串<br>`In JavaScript '\n' is a line-feed.`<br><br>// 多行字符串<br>`In JavaScript this is<br> not legal.`<br><br>console.log(`string text line 1<br>string text line 2`);<br><br>// 字符串中嵌入变量<br>var name = "Bob", time = "today";<br>`Hello ${name}, how are you ${time}?`<br>```<br><br>上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。<br><br>```javascript<br>var greeting = `\`Yo\` World!`;<br>```<br><br>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。<br><br>```javascript<br>$('#list').html(`<br><ul><br>  <li>first</li><br>  <li>second</li><br></ul><br>`);<br>```<br><br>上面代码中，所有模板字符串的空格和换行，都是被保留的，比如`<ul>`标签前面会有一个换行。如果你不想要这个换行，可以使用`trim`方法消除它。<br><br><br>```javascript<br>$('#list').html(`<br><ul><br>  <li>first</li><br>  <li>second</li><br></ul><br>`.trim());<br>```<br><br>模板字符串中嵌入变量，需要将变量名写在`${}`之中。<br><br>```javascript<br>function authorize(user, action) {<br>  if (!user.hasPrivilege(action)) {<br>    throw new Error(<br>      // 传统写法为<br>      // 'User '<br>      // + user.name<br>      // + ' is not authorized to do '<br>      // + action<br>      // + '.'<br>      `User ${user.name} is not authorized to do ${action}.`);<br>  }<br>}<br>```<br><br>大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。<br><br>```javascript<br>var x = 1;<br>var y = 2;<br><br>`${x} + ${y} = ${x + y}`<br>// "1 + 2 = 3"<br><br>`${x} + ${y * 2} = ${x + y * 2}`<br>// "1 + 4 = 5"<br><br>var obj = {x: 1, y: 2};<br>`${obj.x + obj.y}`<br>// 3<br>```<br><br>模板字符串之中还能调用函数。<br><br>```javascript<br>function fn() {<br>  return "Hello World";<br>}<br><br>`foo ${fn()} bar`<br>// foo Hello World bar<br>```<br><br>如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的`toString`方法。<br><br>如果模板字符串中的变量没有声明，将报错。<br><br>```javascript<br>// 变量place没有声明<br>var msg = `Hello, ${place}`;<br>// 报错<br>```<br><br>由于模板字符串的大括号内部，就是执行JavaScript代码，因此如果大括号内部是一个字符串，将会原样输出。<br><br>```javascript<br>`Hello ${'World'}`<br>// "Hello World"<br>```<br><br>模板字符串甚至还能嵌套。<br><br>```javascript<br>const tmpl = addrs => `<br>  <table><br>  ${addrs.map(addr => `<br>    <tr><td>${addr.first}</td></tr><br>    <tr><td>${addr.last}</td></tr><br>  `).join('')}<br>  </table><br>`;<br>```<br><br>上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。<br><br>```javascript<br>const data = [<br>    { first: '<Jane>', last: 'Bond' },<br>    { first: 'Lars', last: '<Croft>' },<br>];<br><br>console.log(tmpl(data));<br>// <table><br>//<br>//   <tr><td><Jane></td></tr><br>//   <tr><td>Bond</td></tr><br>//<br>//   <tr><td>Lars</td></tr><br>//   <tr><td><Croft></td></tr><br>//<br>// </table><br>```<br><br>如果需要引用模板字符串本身，在需要时执行，可以像下面这样写。<br><br>```javascript<br>// 写法一<br>let str = 'return ' + '`Hello ${name}!`';<br>let func = new Function('name', str);<br>func('Jack') // "Hello Jack!"<br><br>// 写法二<br>let str = '(name) => `Hello ${name}!`';<br>let func = eval.call(null, str);<br>func('Jack') // "Hello Jack!"<br>```<br><br>## 实例：模板编译<br><br>下面，我们来看一个通过模板字符串，生成正式模板的实例。<br><br>```javascript<br>var template = `<br><ul><br>  <% for(var i=0; i < data.supplies.length; i++) { %><br>    <li><%= data.supplies[i] %></li><br>  <% } %><br></ul><br>`;<br>```<br><br>上面代码在模板字符串之中，放置了一个常规模板。该模板使用`<%...%>`放置JavaScript代码，使用`<%= ... %>`输出JavaScript表达式。<br><br>怎么编译这个模板字符串呢？<br><br>一种思路是将其转换为JavaScript表达式字符串。<br><br>```javascript<br>echo('<ul>');<br>for(var i=0; i < data.supplies.length; i++) {<br>  echo('<li>');<br>  echo(data.supplies[i]);<br>  echo('</li>');<br>};<br>echo('</ul>');<br>```<br><br>这个转换使用正则表达式就行了。<br><br>```javascript<br>var evalExpr = /<%=(.+?)%>/g;<br>var expr = /<%([\s\S]+?)%>/g;<br><br>template = template<br>  .replace(evalExpr, '`); \n  echo( $1 ); \n  echo(`')<br>  .replace(expr, '`); \n $1 \n  echo(`');<br><br>template = 'echo(`' + template + '`);';<br>```<br><br>然后，将`template`封装在一个函数里面返回，就可以了。<br><br>```javascript<br>var script =<br>`(function parse(data){<br>  var output = "";<br><br>  function echo(html){<br>    output += html;<br>  }<br><br>  ${ template }<br><br>  return output;<br>})`;<br><br>return script;<br>```<br><br>将上面的内容拼装成一个模板编译函数`compile`。<br><br>```javascript<br>function compile(template){<br>  var evalExpr = /<%=(.+?)%>/g;<br>  var expr = /<%([\s\S]+?)%>/g;<br><br>  template = template<br>    .replace(evalExpr, '`); \n  echo( $1 ); \n  echo(`')<br>    .replace(expr, '`); \n $1 \n  echo(`');<br><br>  template = 'echo(`' + template + '`);';<br><br>  var script =<br>  `(function parse(data){<br>    var output = "";<br><br>    function echo(html){<br>      output += html;<br>    }<br><br>    ${ template }<br><br>    return output;<br>  })`;<br><br>  return script;<br>}<br>```<br><br>`compile`函数的用法如下。<br><br>```javascript<br>var parse = eval(compile(template));<br>div.innerHTML = parse({ supplies: [ "broom", "mop", "cleaner" ] });<br>//   <ul><br>//     <li>broom</li><br>//     <li>mop</li><br>//     <li>cleaner</li><br>//   </ul><br>```<br><br>## 标签模板<br><br>模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。<br><br>```javascript<br>alert`123`<br>// 等同于<br>alert(123)<br>```<br><br>标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。<br><br>但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。<br><br>```javascript<br>var a = 5;<br>var b = 10;<br><br>tag`Hello ${ a + b } world ${ a * b }`;<br>// 等同于<br>tag(['Hello ', ' world ', ''], 15, 50);<br>```<br><br>上面代码中，模板字符串前面有一个标识名`tag`，它是一个函数。整个表达式的返回值，就是`tag`函数处理模板字符串后的返回值。<br><br>函数`tag`依次会接收到多个参数。<br><br>```javascript<br>function tag(stringArr, value1, value2){<br>  // ...<br>}<br><br>// 等同于<br><br>function tag(stringArr, ...values){<br>  // ...<br>}<br>```<br><br>`tag`函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。<br><br>`tag`函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此`tag`会接受到`value1`和`value2`两个参数。<br><br>`tag`函数所有参数的实际值如下。<br><br>- 第一个参数：`['Hello ', ' world ', '']`<br>- 第二个参数: 15<br>- 第三个参数：50<br><br>也就是说，`tag`函数实际上以下面的形式调用。<br><br>```javascript<br>tag(['Hello ', ' world ', ''], 15, 50)<br>```<br><br>我们可以按照需要编写`tag`函数的代码。下面是`tag`函数的一种写法，以及运行结果。<br><br>```javascript<br>var a = 5;<br>var b = 10;<br><br>function tag(s, v1, v2) {<br>  console.log(s[0]);<br>  console.log(s[1]);<br>  console.log(s[2]);<br>  console.log(v1);<br>  console.log(v2);<br><br>  return "OK";<br>}<br><br>tag`Hello ${ a + b } world ${ a * b}`;<br>// "Hello "<br>// " world "<br>// ""<br>// 15<br>// 50<br>// "OK"<br>```<br><br>下面是一个更复杂的例子。<br><br>```javascript<br>var total = 30;<br>var msg = passthru`The total is ${total} (${total*1.05} with tax)`;<br><br>function passthru(literals) {<br>  var result = '';<br>  var i = 0;<br><br>  while (i < literals.length) {<br>    result += literals[i++];<br>    if (i < arguments.length) {<br>      result += arguments[i];<br>    }<br>  }<br><br>  return result;<br>}<br><br>msg // "The total is 30 (31.5 with tax)"<br>```<br><br>上面这个例子展示了，如何将各个参数按照原来的位置拼合回去。<br><br>`passthru`函数采用rest参数的写法如下。<br><br>```javascript<br>function passthru(literals, ...values) {<br>  var output = "";<br>  for (var index = 0; index < values.length; index++) {<br>    output += literals[index] + values[index];<br>  }<br><br>  output += literals[index]<br>  return output;<br>}<br>```<br><br>“标签模板”的一个重要应用，就是过滤HTML字符串，防止用户输入恶意内容。<br><br>```javascript<br>var message =<br>  SaferHTML`<p>${sender} has sent you a message.</p>`;<br><br>function SaferHTML(templateData) {<br>  var s = templateData[0];<br>  for (var i = 1; i < arguments.length; i++) {<br>    var arg = String(arguments[i]);<br><br>    // Escape special characters in the substitution.<br>    s += arg.replace(/&/g, "&amp;")<br>            .replace(/</g, "&lt;")<br>            .replace(/>/g, "&gt;");<br><br>    // Don't escape special characters in the template.<br>    s += templateData[i];<br>  }<br>  return s;<br>}<br>```<br><br>上面代码中，`sender`变量往往是用户提供的，经过`SaferHTML`函数处理，里面的特殊字符都会被转义。<br><br>```javascript<br>var sender = '<script>alert('abc")</script>'; // 恶意代码<br>var message = SaferHTML`<p>${sender} has sent you a message.</p>`;<br><br>message<br>// <p>&lt;script&gt;alert("abc")&lt;/script&gt; has sent you a message.</p><br>```<br><br><br>标签模板的另一个应用，就是多语言转换（国际化处理）。<br><br>```javascript<br>i18n`Welcome to ${siteName}, you are visitor number ${visitorNumber}!`<br>// "欢迎访问xxx，您是第xxxx位访问者！"<br>```<br><br>模板字符串本身并不能取代Mustache之类的模板库，因为没有条件判断和循环处理功能，但是通过标签函数，你可以自己添加这些功能。<br><br>```javascript<br>// 下面的hashTemplate函数<br>// 是一个自定义的模板处理函数<br>var libraryHtml = hashTemplate`<br>  <ul><br>    #for book in ${myBooks}<br>      <li><i>#{book.title}</i> by #{book.author}</li><br>    #end<br>  </ul><br>`;<br>```<br><br>除此之外，你甚至可以使用标签模板，在JavaScript语言之中嵌入其他语言。<br><br>```javascript<br>jsx`<br>  <div><br>    <input<br>      ref='input'<br>      onChange='${this.handleChange}'<br>      defaultValue='${this.state.value}' /><br>      ${this.state.value}<br>   </div><br>`<br>```<br><br>上面的代码通过`jsx`函数，将一个DOM字符串转为React对象。你可以在Github找到`jsx`函数的[具体实现](https://gist.github.com/lygaret/a68220defa69174bdec5)。<br><br>下面则是一个假想的例子，通过`java`函数，在JavaScript代码之中运行Java代码。<br><br>```javascript<br>java`<br>class HelloWorldApp {<br>  public static void main(String[] args) {<br>    System.out.println(“Hello World!”); // Display the string.<br>  }<br>}<br>`<br>HelloWorldApp.main();<br>```<br><br>模板处理函数的第一个参数（模板字符串数组），还有一个`raw`属性。<br><br>```javascript<br>console.log`123`<br>// ["123", raw: Array[1]]<br>```<br><br>上面代码中，`console.log`接受的参数，实际上是一个数组。该数组有一个`raw`属性，保存的是转义后的原字符串。<br><br>请看下面的例子。<br><br>```javascript<br>tag`First line\nSecond line`<br><br>function tag(strings) {<br>  console.log(strings.raw[0]);<br>  // "First line\\nSecond line"<br>}<br>```<br><br>上面代码中，`tag`函数的第一个参数`strings`，有一个`raw`属性，也指向一个数组。该数组的成员与`strings`数组完全一致。比如，`strings`数组是`["First line\nSecond line"]`，那么`strings.raw`数组就是`["First line\\nSecond line"]`。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，strings.raw数组会将`\n`视为`\\`和`n`两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。<br><br>## String.raw()<br><br>ES6还为原生的String对象，提供了一个`raw`方法。<br><br>`String.raw`方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。<br><br>```javascript<br>String.raw`Hi\n${2+3}!`;<br>// "Hi\\n5!"<br><br>String.raw`Hi\u000A!`;<br>// 'Hi\\u000A!'<br>```<br><br>如果原字符串的斜杠已经转义，那么`String.raw`不会做任何处理。<br><br>```javascript<br>String.raw`Hi\\n`<br>// "Hi\\n"<br>```<br><br>`String.raw`的代码基本如下。<br><br>```javascript<br>String.raw = function (strings, ...values) {<br>  var output = "";<br>  for (var index = 0; index < values.length; index++) {<br>    output += strings.raw[index] + values[index];<br>  }<br><br>  output += strings.raw[index]<br>  return output;<br>}<br>```<br><br>`String.raw`方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。<br><br>`String.raw`方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有`raw`属性的对象，且`raw`属性的值应该是一个数组。<br><br>```javascript<br>String.raw({ raw: 'test' }, 0, 1, 2);<br>// 't0e1s2t'<br><br>// 等同于<br>String.raw({ raw: ['t','e','s','t'] }, 0, 1, 2);<br>```<br><br>## 模板字符串的限制<br><br>前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，因此导致了无法嵌入其他语言。<br><br>举例来说，在标签模板里面可以嵌入Latex语言。<br><br>```javascript<br>function latex(strings) {<br>  // ...<br>}<br><br>let document = latex`<br>\newcommand{\fun}{\textbf{Fun!}}  // 正常工作<br>\newcommand{\unicode}{\textbf{Unicode!}} // 报错<br>\newcommand{\xerxes}{\textbf{King!}} // 报错<br><br>Breve over the h goes \u{h}ere // 报错<br>`<br>```<br><br>上面代码中，变量`document`内嵌的模板字符串，对于Latex语言来说完全是合法的，但是JavaScript引擎会报错。原因就在于字符串的转义。<br><br>模板字符串会将`\u00FF`和`\u{42}`当作Unicode字符进行转义，所以`\unicode`解析时报错；而`\x56`会被当作十六进制字符串转义，所以`\xerxes`会报错。<br><br>为了解决这个问题，现在有一个[提案](https://tc39.github.io/proposal-template-literal-revision/)，放松对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回`undefined`，而不是报错，并且从`raw`属性上面可以得到原始字符串。<br><br>```javascript<br>function tag(strs) {<br>  strs[0] === undefined<br>  strs.raw[0] === "\\unicode and \\u{55}";<br>}<br>tag`\unicode and \u{55}`<br>```<br><br>上面代码中，模板字符串原本是应该报错的，但是由于放松了对字符串转义的限制，所以不报错了，JavaScript引擎将第一个字符设置为`undefined`，但是`raw`属性依然可以得到原始字符串，因此`tag`函数还是可以对原字符串进行处理。<br><br>注意，这种对字符串转义的放松，只在标签模板解析字符串时生效，不是标签模板的场合，依然会报错。<br><br>```javascript<br>let bad = `bad escape sequence: \unicode`; // 报错<br>```<br></div></div>
			<nav>
				<ul class="pager">
				<li class='previous'><a href='3.html'>&larr; 变量的解构赋值</a></li>
			<li class='next'><a href='5.html'>正则的扩展&rarr;</a></li>
				</ul>
			</nav>
</div>
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
			<!-- /.row -->
			  <hr>
        <!-- Footer -->
        <footer>
            <div class="row">
                <div class="col-xs-12">
                    <p>Copyright &copy; 小龙软件工作室 2016 粤icp备16103410</p>
                </div>
            </div>
        </footer>

    </div>
    <!-- /.container -->

    <!-- jQuery -->
    <script src="../../js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="../../js/bootstrap.min.js"></script>

</body>

</html>
