<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="content-type" content="text/html;charset=utf-8">
    <meta charset="utf-8">
<meta name="360-site-verification" content="cabcfb5a0f4c0d28d604e8a69e6c0cdb" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="baidu-site-verification" content="HknqsD2zhn" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>ECMAScript 6入门-编码助手网</title>
      <meta content="为编码人员提供在线文档、模板等帮助，提升解决问题效率" name="description">
			<meta content="ECMAScript 6入门 Java, spring, tomcat, servlet, jsp, api doc, bootstrap" name="keywords">
<meta name="sogou_site_verification" content="42nApEZFKO"/>


    <!-- Bootstrap Core CSS -->
    <link href="../../css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="../../css/heroic-features.css" rel="stylesheet">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
		<script>
		var _hmt = _hmt || [];
		(function() {
		  var hm = document.createElement("script");
		  hm.src = "//hm.baidu.com/hm.js?dd1361ca20a10cc161e72d4bc4fef6df";
		  var s = document.getElementsByTagName("script")[0];
		  s.parentNode.insertBefore(hm, s);
		})();
		</script>

</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">编码助手网</a>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav">
                    <li>
                        <a href="/">首页</a>
                    </li>
										<li>
                        <a href="/template.html">模板</a>
                    </li>
										<li>
												<a href="/doc.html">文档</a>
										</li>
                    <li>
                        <a href="/contact.html">联系我们</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Content -->
    <div class="container">

			<div class="row">
					<div class="col-xs-4">
						<h4>ECMAScript 6入门</h4>
						<h6>感谢Ruan YiFeng提供内容</h6>
<ul><li><a href='./0.html'>前言</a></li><li><a href='./1.html'>ECMAScript 6简介</a></li><li><a href='./2.html'>let和const命令</a></li><li><a href='./3.html'>变量的解构赋值</a></li><li><a href='./4.html'>字符串的扩展</a></li><li><a href='./5.html'>正则的扩展</a></li><li><a href='./6.html'>数值的扩展</a></li><li><a href='./7.html'>数组的扩展</a></li><li><a href='./8.html'>函数的扩展</a></li><li><a href='./9.html'>对象的扩展</a></li><li><a href='./10.html'>Symbol</a></li><li><a href='./11.html'>Proxy和Reflect</a></li><li><a href='./12.html'>Set和Map数据结构</a></li><li><a href='./13.html'>Iterator和for...of循环</a></li><li><a href='./14.html'>Generator函数</a></li><li><a href='./15.html'>Promise对象</a></li><li><a href='./16.html'>异步操作和Async函数</a></li><li><a href='./17.html'>Class</a></li><li><a href='./18.html'>Decorator</a></li><li><a href='./19.html'>Module</a></li><li><a href='./20.html'>编程风格</a></li><li><a href='./21.html'>读懂规格</a></li><li><a href='./22.html'>二进制数组</a></li><li><a href='./23.html'>SIMD</a></li><li><a href='./24.html'>参考链接</a></li><li></li>
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
<div class="col-xs-8">
	<nav>
		<ul class="pager">
			<li class='previous'><a href='8.html'>&larr; 函数的扩展</a></li>
		<li class='next'><a href='10.html'>Symbol&rarr;</a></li>
		</ul>
	</nav>
			<div class="row"><div class="col-xs-12"># 对象的扩展<br><br>## 属性的简洁表示法<br><br>ES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。<br><br>```javascript<br>var foo = 'bar';<br>var baz = {foo};<br>baz // {foo: "bar"}<br><br>// 等同于<br>var baz = {foo: foo};<br>```<br><br>上面代码表明，ES6允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。下面是另一个例子。<br><br>```javascript<br>function f(x, y) {<br>  return {x, y};<br>}<br><br>// 等同于<br><br>function f(x, y) {<br>  return {x: x, y: y};<br>}<br><br>f(1, 2) // Object {x: 1, y: 2}<br>```<br><br>除了属性简写，方法也可以简写。<br><br>```javascript<br>var o = {<br>  method() {<br>    return "Hello!";<br>  }<br>};<br><br>// 等同于<br><br>var o = {<br>  method: function() {<br>    return "Hello!";<br>  }<br>};<br>```<br><br>下面是一个实际的例子。<br><br>```javascript<br>var birth = '2000/01/01';<br><br>var Person = {<br><br>  name: '张三',<br><br>  //等同于birth: birth<br>  birth,<br><br>  // 等同于hello: function ()...<br>  hello() { console.log('我的名字是', this.name); }<br><br>};<br>```<br><br>这种写法用于函数的返回值，将会非常方便。<br><br>```javascript<br>function getPoint() {<br>  var x = 1;<br>  var y = 10;<br>  return {x, y};<br>}<br><br>getPoint()<br>// {x:1, y:10}<br>```<br><br>CommonJS模块输出变量，就非常合适使用简洁写法。<br><br>```javascript<br>var ms = {};<br><br>function getItem (key) {<br>  return key in ms ? ms[key] : null;<br>}<br><br>function setItem (key, value) {<br>  ms[key] = value;<br>}<br><br>function clear () {<br>  ms = {};<br>}<br><br>module.exports = { getItem, setItem, clear };<br>// 等同于<br>module.exports = {<br>  getItem: getItem,<br>  setItem: setItem,<br>  clear: clear<br>};<br>```<br><br>属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法。<br><br>```javascript<br>var cart = {<br>  _wheels: 4,<br><br>  get wheels () {<br>    return this._wheels;<br>  },<br><br>  set wheels (value) {<br>    if (value < this._wheels) {<br>      throw new Error('数值太小了！');<br>    }<br>    this._wheels = value;<br>  }<br>}<br>```<br><br>注意，简洁写法的属性名总是字符串，这会导致一些看上去比较奇怪的结果。<br><br>```javascript<br>var obj = {<br>  class () {}<br>};<br><br>// 等同于<br><br>var obj = {<br>  'class': function() {}<br>};<br>```<br><br>上面代码中，`class`是字符串，所以不会因为它属于关键字，而导致语法解析报错。<br><br>如果某个方法的值是一个Generator函数，前面需要加上星号。<br><br>```javascript<br>var obj = {<br>  * m(){<br>    yield 'hello world';<br>  }<br>};<br>```<br><br>## 属性名表达式<br><br>JavaScript语言定义对象的属性，有两种方法。<br><br>```javascript<br>// 方法一<br>obj.foo = true;<br><br>// 方法二<br>obj['a' + 'bc'] = 123;<br>```<br><br>上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。<br><br>但是，如果使用字面量方式定义对象（使用大括号），在ES5中只能使用方法一（标识符）定义属性。<br><br>```javascript<br>var obj = {<br>  foo: true,<br>  abc: 123<br>};<br>```<br><br>ES6允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。<br><br>```javascript<br>let propKey = 'foo';<br><br>let obj = {<br>  [propKey]: true,<br>  ['a' + 'bc']: 123<br>};<br>```<br><br>下面是另一个例子。<br><br>```javascript<br>var lastWord = 'last word';<br><br>var a = {<br>  'first word': 'hello',<br>  [lastWord]: 'world'<br>};<br><br>a['first word'] // "hello"<br>a[lastWord] // "world"<br>a['last word'] // "world"<br>```<br><br>表达式还可以用于定义方法名。<br><br>```javascript<br>let obj = {<br>  ['h'+'ello']() {<br>    return 'hi';<br>  }<br>};<br><br>obj.hello() // hi<br>```<br><br>注意，属性名表达式与简洁表示法，不能同时使用，会报错。<br><br>```javascript<br>// 报错<br>var foo = 'bar';<br>var bar = 'abc';<br>var baz = { [foo] };<br><br>// 正确<br>var foo = 'bar';<br>var baz = { [foo]: 'abc'};<br>```<br><br>## 方法的name属性<br><br>函数的`name`属性，返回函数名。对象方法也是函数，因此也有`name`属性。<br><br>```javascript<br>var person = {<br>  sayName() {<br>    console.log(this.name);<br>  },<br>  get firstName() {<br>    return "Nicholas";<br>  }<br>};<br><br>person.sayName.name   // "sayName"<br>person.firstName.name // "get firstName"<br>```<br><br>上面代码中，方法的`name`属性返回函数名（即方法名）。如果使用了取值函数，则会在方法名前加上`get`。如果是存值函数，方法名的前面会加上`set`。<br><br>有两种特殊情况：`bind`方法创造的函数，`name`属性返回“bound”加上原函数的名字；`Function`构造函数创造的函数，`name`属性返回“anonymous”。<br><br>```javascript<br>(new Function()).name // "anonymous"<br><br>var doSomething = function() {<br>  // ...<br>};<br>doSomething.bind().name // "bound doSomething"<br>```<br><br>如果对象的方法是一个Symbol值，那么`name`属性返回的是这个Symbol值的描述。<br><br>```javascript<br>const key1 = Symbol('description');<br>const key2 = Symbol();<br>let obj = {<br>  [key1]() {},<br>  [key2]() {},<br>};<br>obj[key1].name // "[description]"<br>obj[key2].name // ""<br>```<br><br>上面代码中，`key1`对应的Symbol值有描述，`key2`没有。<br><br>## Object.is()<br><br>ES5比较两个值是否相等，只有两个运算符：相等运算符（`==`）和严格相等运算符（`===`）。它们都有缺点，前者会自动转换数据类型，后者的`NaN`不等于自身，以及`+0`等于`-0`。JavaScript缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。<br><br>ES6提出“Same-value equality”（同值相等）算法，用来解决这个问题。`Object.is`就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。<br><br>```javascript<br>Object.is('foo', 'foo')<br>// true<br>Object.is({}, {})<br>// false<br>```<br><br>不同之处只有两个：一是`+0`不等于`-0`，二是`NaN`等于自身。<br><br>```javascript<br>+0 === -0 //true<br>NaN === NaN // false<br><br>Object.is(+0, -0) // false<br>Object.is(NaN, NaN) // true<br>```<br><br>ES5可以通过下面的代码，部署`Object.is`。<br><br>```javascript<br>Object.defineProperty(Object, 'is', {<br>  value: function(x, y) {<br>    if (x === y) {<br>      // 针对+0 不等于 -0的情况<br>      return x !== 0 || 1 / x === 1 / y;<br>    }<br>    // 针对NaN的情况<br>    return x !== x && y !== y;<br>  },<br>  configurable: true,<br>  enumerable: false,<br>  writable: true<br>});<br>```<br><br>## Object.assign()<br><br>### 基本用法<br><br>`Object.assign`方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。<br><br>```javascript<br>var target = { a: 1 };<br><br>var source1 = { b: 2 };<br>var source2 = { c: 3 };<br><br>Object.assign(target, source1, source2);<br>target // {a:1, b:2, c:3}<br>```<br><br>`Object.assign`方法的第一个参数是目标对象，后面的参数都是源对象。<br><br>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。<br><br>```javascript<br>var target = { a: 1, b: 1 };<br><br>var source1 = { b: 2, c: 2 };<br>var source2 = { c: 3 };<br><br>Object.assign(target, source1, source2);<br>target // {a:1, b:2, c:3}<br>```<br><br>如果只有一个参数，`Object.assign`会直接返回该参数。<br><br>```javascript<br>var obj = {a: 1};<br>Object.assign(obj) === obj // true<br>```<br><br>如果该参数不是对象，则会先转成对象，然后返回。<br><br>```javascript<br>typeof Object.assign(2) // "object"<br>```<br><br>由于`undefined`和`null`无法转成对象，所以如果它们作为参数，就会报错。<br><br>```javascript<br>Object.assign(undefined) // 报错<br>Object.assign(null) // 报错<br>```<br><br>如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果`undefined`和`null`不在首参数，就不会报错。<br><br>```javascript<br>let obj = {a: 1};<br>Object.assign(obj, undefined) === obj // true<br>Object.assign(obj, null) === obj // true<br>```<br><br>其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。<br><br>```javascript<br>var v1 = 'abc';<br>var v2 = true;<br>var v3 = 10;<br><br>var obj = Object.assign({}, v1, v2, v3);<br>console.log(obj); // { "0": "a", "1": "b", "2": "c" }<br>```<br><br>上面代码中，`v1`、`v2`、`v3`分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。<br><br>```javascript<br>Object(true) // {[[PrimitiveValue]]: true}<br>Object(10)  //  {[[PrimitiveValue]]: 10}<br>Object('abc') // {0: "a", 1: "b", 2: "c", length: 3, [[PrimitiveValue]]: "abc"}<br>```<br><br>上面代码中，布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性`[[PrimitiveValue]]`上面，这个属性是不会被`Object.assign`拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。<br><br>`Object.assign`拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（`enumerable: false`）。<br><br>```javascript<br>Object.assign({b: 'c'},<br>  Object.defineProperty({}, 'invisible', {<br>    enumerable: false,<br>    value: 'hello'<br>  })<br>)<br>// { b: 'c' }<br>```<br><br>上面代码中，`Object.assign`要拷贝的对象只有一个不可枚举属性`invisible`，这个属性并没有被拷贝进去。<br><br>属性名为Symbol值的属性，也会被`Object.assign`拷贝。<br><br>```javascript<br>Object.assign({ a: 'b' }, { [Symbol('c')]: 'd' })<br>// { a: 'b', Symbol(c): 'd' }<br>```<br><br>### 注意点<br><br>`Object.assign`方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。<br><br>```javascript<br>var obj1 = {a: {b: 1}};<br>var obj2 = Object.assign({}, obj1);<br><br>obj1.a.b = 2;<br>obj2.a.b // 2<br>```<br><br>上面代码中，源对象`obj1`的`a`属性的值是一个对象，`Object.assign`拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。<br><br>对于这种嵌套的对象，一旦遇到同名属性，`Object.assign`的处理方法是替换，而不是添加。<br><br>```javascript<br>var target = { a: { b: 'c', d: 'e' } }<br>var source = { a: { b: 'hello' } }<br>Object.assign(target, source)<br>// { a: { b: 'hello' } }<br>```<br><br>上面代码中，`target`对象的`a`属性被`source`对象的`a`属性整个替换掉了，而不会得到`{ a: { b: 'hello', d: 'e' } }`的结果。这通常不是开发者想要的，需要特别小心。<br><br>有一些函数库提供`Object.assign`的定制版本（比如Lodash的`_.defaultsDeep`方法），可以解决浅拷贝的问题，得到深拷贝的合并。<br><br>注意，`Object.assign`可以用来处理数组，但是会把数组视为对象。<br><br>```javascript<br>Object.assign([1, 2, 3], [4, 5])<br>// [4, 5, 3]<br>```<br><br>上面代码中，`Object.assign`把数组视为属性名为0、1、2的对象，因此目标数组的0号属性`4`覆盖了原数组的0号属性`1`。<br><br>### 常见用途<br><br>`Object.assign`方法有很多用处。<br><br>**（1）为对象添加属性**<br><br>```javascript<br>class Point {<br>  constructor(x, y) {<br>    Object.assign(this, {x, y});<br>  }<br>}<br>```<br><br>上面方法通过`Object.assign`方法，将`x`属性和`y`属性添加到`Point`类的对象实例。<br><br>**（2）为对象添加方法**<br><br>```javascript<br>Object.assign(SomeClass.prototype, {<br>  someMethod(arg1, arg2) {<br>    ···<br>  },<br>  anotherMethod() {<br>    ···<br>  }<br>});<br><br>// 等同于下面的写法<br>SomeClass.prototype.someMethod = function (arg1, arg2) {<br>  ···<br>};<br>SomeClass.prototype.anotherMethod = function () {<br>  ···<br>};<br>```<br><br>上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用assign方法添加到SomeClass.prototype之中。<br><br>**（3）克隆对象**<br><br>```javascript<br>function clone(origin) {<br>  return Object.assign({}, origin);<br>}<br>```<br><br>上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。<br><br>不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。<br><br>```javascript<br>function clone(origin) {<br>  let originProto = Object.getPrototypeOf(origin);<br>  return Object.assign(Object.create(originProto), origin);<br>}<br>```<br><br>**（4）合并多个对象**<br><br>将多个对象合并到某个对象。<br><br>```javascript<br>const merge =<br>  (target, ...sources) => Object.assign(target, ...sources);<br>```<br><br>如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。<br><br>```javascript<br>const merge =<br>  (...sources) => Object.assign({}, ...sources);<br>```<br><br>**（5）为属性指定默认值**<br><br>```javascript<br>const DEFAULTS = {<br>  logLevel: 0,<br>  outputFormat: 'html'<br>};<br><br>function processContent(options) {<br>  options = Object.assign({}, DEFAULTS, options);<br>}<br>```<br><br>上面代码中，`DEFAULTS`对象是默认值，`options`对象是用户提供的参数。`Object.assign`方法将`DEFAULTS`和`options`合并成一个新对象，如果两者有同名属性，则`option`的属性值会覆盖`DEFAULTS`的属性值。<br><br>注意，由于存在深拷贝的问题，`DEFAULTS`对象和`options`对象的所有属性的值，都只能是简单类型，而不能指向另一个对象。否则，将导致`DEFAULTS`对象的该属性不起作用。<br><br>## 属性的可枚举性<br><br>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。`Object.getOwnPropertyDescriptor`方法可以获取该属性的描述对象。<br><br>```javascript<br>let obj = { foo: 123 };<br>Object.getOwnPropertyDescriptor(obj, 'foo')<br>//  {<br>//    value: 123,<br>//    writable: true,<br>//    enumerable: true,<br>//    configurable: true<br>//  }<br>```<br><br>描述对象的`enumerable`属性，称为”可枚举性“，如果该属性为`false`，就表示某些操作会忽略当前属性。<br><br>ES5有三个操作会忽略`enumerable`为`false`的属性。<br><br>- `for...in`循环：只遍历对象自身的和继承的可枚举的属性<br>- `Object.keys()`：返回对象自身的所有可枚举的属性的键名<br>- `JSON.stringify()`：只串行化对象自身的可枚举的属性<br><br>ES6新增了一个操作`Object.assign()`，会忽略`enumerable`为`false`的属性，只拷贝对象自身的可枚举的属性。<br><br>这四个操作之中，只有`for...in`会返回继承的属性。实际上，引入`enumerable`的最初目的，就是让某些属性可以规避掉`for...in`操作。比如，对象原型的`toString`方法，以及数组的`length`属性，就通过这种手段，不会被`for...in`遍历到。<br><br>```javascript<br>Object.getOwnPropertyDescriptor(Object.prototype, 'toString').enumerable<br>// false<br><br>Object.getOwnPropertyDescriptor([], 'length').enumerable<br>// false<br>```<br><br>上面代码中，`toString`和`length`属性的`enumerable`都是`false`，因此`for...in`不会遍历到这两个继承自原型的属性。<br><br>另外，ES6规定，所有Class的原型的方法都是不可枚举的。<br><br>```javascript<br>Object.getOwnPropertyDescriptor(class {foo() {}}.prototype, 'foo').enumerable<br>// false<br>```<br><br>总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用`for...in`循环，而用`Object.keys()`代替。<br><br>## 属性的遍历<br><br>ES6一共有5种方法可以遍历对象的属性。<br><br>**（1）for...in**<br><br>`for...in`循环遍历对象自身的和继承的可枚举属性（不含Symbol属性）。<br><br>**（2）Object.keys(obj)**<br><br>`Object.keys`返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）。<br><br>**（3）Object.getOwnPropertyNames(obj)**<br><br>`Object.getOwnPropertyNames`返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）。<br><br>**（4）Object.getOwnPropertySymbols(obj)**<br><br>`Object.getOwnPropertySymbols`返回一个数组，包含对象自身的所有Symbol属性。<br><br>**（5）Reflect.ownKeys(obj)**<br><br>`Reflect.ownKeys`返回一个数组，包含对象自身的所有属性，不管是属性名是Symbol或字符串，也不管是否可枚举。<br><br>以上的5种方法遍历对象的属性，都遵守同样的属性遍历的次序规则。<br><br>- 首先遍历所有属性名为数值的属性，按照数字排序。<br>- 其次遍历所有属性名为字符串的属性，按照生成时间排序。<br>- 最后遍历所有属性名为Symbol值的属性，按照生成时间排序。<br><br>```javascript<br>Reflect.ownKeys({ [Symbol()]:0, b:0, 10:0, 2:0, a:0 })<br>// ['2', '10', 'b', 'a', Symbol()]<br>```<br><br>上面代码中，`Reflect.ownKeys`方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性`2`和`10`，其次是字符串属性`b`和`a`，最后是Symbol属性。<br><br>## `__proto__`属性，Object.setPrototypeOf()，Object.getPrototypeOf()<br><br>**（1）`__proto__`属性**<br><br>`__proto__`属性（前后各两个下划线），用来读取或设置当前对象的`prototype`对象。目前，所有浏览器（包括IE11）都部署了这个属性。<br><br>```javascript<br>// es6的写法<br>var obj = {<br>  method: function() { ... }<br>};<br>obj.__proto__ = someOtherObj;<br><br>// es5的写法<br>var obj = Object.create(someOtherObj);<br>obj.method = function() { ... };<br>```<br><br>该属性没有写入ES6的正文，而是写入了附录，原因是`__proto__`前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的API，只是由于浏览器广泛支持，才被加入了ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的`Object.setPrototypeOf()`（写操作）、`Object.getPrototypeOf()`（读操作）、`Object.create()`（生成操作）代替。<br><br>在实现上，`__proto__`调用的是`Object.prototype.__proto__`，具体实现如下。<br><br>```javascript<br>Object.defineProperty(Object.prototype, '__proto__', {<br>  get() {<br>    let _thisObj = Object(this);<br>    return Object.getPrototypeOf(_thisObj);<br>  },<br>  set(proto) {<br>    if (this === undefined || this === null) {<br>      throw new TypeError();<br>    }<br>    if (!isObject(this)) {<br>      return undefined;<br>    }<br>    if (!isObject(proto)) {<br>      return undefined;<br>    }<br>    let status = Reflect.setPrototypeOf(this, proto);<br>    if (!status) {<br>      throw new TypeError();<br>    }<br>  },<br>});<br>function isObject(value) {<br>  return Object(value) === value;<br>}<br>```<br><br>如果一个对象本身部署了`__proto__`属性，则该属性的值就是对象的原型。<br><br>```javascript<br>Object.getPrototypeOf({ __proto__: null })<br>// null<br>```<br><br>**（2）Object.setPrototypeOf()**<br><br>`Object.setPrototypeOf`方法的作用与`__proto__`相同，用来设置一个对象的`prototype`对象。它是ES6正式推荐的设置原型对象的方法。<br><br>```javascript<br>// 格式<br>Object.setPrototypeOf(object, prototype)<br><br>// 用法<br>var o = Object.setPrototypeOf({}, null);<br>```<br><br>该方法等同于下面的函数。<br><br>```javascript<br>function (obj, proto) {<br>  obj.__proto__ = proto;<br>  return obj;<br>}<br>```<br><br>下面是一个例子。<br><br>```javascript<br>let proto = {};<br>let obj = { x: 10 };<br>Object.setPrototypeOf(obj, proto);<br><br>proto.y = 20;<br>proto.z = 40;<br><br>obj.x // 10<br>obj.y // 20<br>obj.z // 40<br>```<br><br>上面代码将proto对象设为obj对象的原型，所以从obj对象可以读取proto对象的属性。<br><br>**（3）Object.getPrototypeOf()**<br><br>该方法与setPrototypeOf方法配套，用于读取一个对象的prototype对象。<br><br>```javascript<br>Object.getPrototypeOf(obj);<br>```<br><br>下面是一个例子。<br><br>```javascript<br>function Rectangle() {<br>}<br><br>var rec = new Rectangle();<br><br>Object.getPrototypeOf(rec) === Rectangle.prototype<br>// true<br><br>Object.setPrototypeOf(rec, Object.prototype);<br>Object.getPrototypeOf(rec) === Rectangle.prototype<br>// false<br>```<br><br>## Object.values()，Object.entries()<br><br>### Object.keys()<br><br>ES5引入了`Object.keys`方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。<br><br>```javascript<br>var obj = { foo: "bar", baz: 42 };<br>Object.keys(obj)<br>// ["foo", "baz"]<br>```<br><br>目前，ES7有一个[提案](https://github.com/tc39/proposal-object-values-entries)，引入了跟`Object.keys`配套的`Object.values`和`Object.entries`。<br><br>```javascript<br>let {keys, values, entries} = Object;<br>let obj = { a: 1, b: 2, c: 3 };<br><br>for (let key of keys(obj)) {<br>  console.log(key); // 'a', 'b', 'c'<br>}<br><br>for (let value of values(obj)) {<br>  console.log(value); // 1, 2, 3<br>}<br><br>for (let [key, value] of entries(obj)) {<br>  console.log([key, value]); // ['a', 1], ['b', 2], ['c', 3]<br>}<br>```<br><br>### Object.values()<br><br>`Object.values`方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。<br><br>```javascript<br>var obj = { foo: "bar", baz: 42 };<br>Object.values(obj)<br>// ["bar", 42]<br>```<br><br>返回数组的成员顺序，与本章的《属性的遍历》部分介绍的排列规则一致。<br><br>```javascript<br>var obj = { 100: 'a', 2: 'b', 7: 'c' };<br>Object.values(obj)<br>// ["b", "c", "a"]<br>```<br><br>上面代码中，属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回的顺序是`b`、`c`、`a`。<br><br>`Object.values`只返回对象自身的可遍历属性。<br><br>```javascript<br>var obj = Object.create({}, {p: {value: 42}});<br>Object.values(obj) // []<br>```<br><br>上面代码中，`Object.create`方法的第二个参数添加的对象属性（属性`p`），如果不显式声明，默认是不可遍历的。`Object.values`不会返回这个属性。<br><br>`Object.values`会过滤属性名为Symbol值的属性。<br><br>```javascript<br>Object.values({ [Symbol()]: 123, foo: 'abc' });<br>// ['abc']<br>```<br><br>如果`Object.values`方法的参数是一个字符串，会返回各个字符组成的一个数组。<br><br>```javascript<br>Object.values('foo')<br>// ['f', 'o', 'o']<br>```<br><br>上面代码中，字符串会先转成一个类似数组的对象。字符串的每个字符，就是该对象的一个属性。因此，`Object.values`返回每个属性的键值，就是各个字符组成的一个数组。<br><br>如果参数不是对象，`Object.values`会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，`Object.values`会返回空数组。<br><br>```javascript<br>Object.values(42) // []<br>Object.values(true) // []<br>```<br><br>### Object.entries<br><br>`Object.entries`方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。<br><br>```javascript<br>var obj = { foo: 'bar', baz: 42 };<br>Object.entries(obj)<br>// [ ["foo", "bar"], ["baz", 42] ]<br>```<br><br>除了返回值不一样，该方法的行为与`Object.values`基本一致。<br><br>如果原对象的属性名是一个Symbol值，该属性会被省略。<br><br>```javascript<br>Object.entries({ [Symbol()]: 123, foo: 'abc' });<br>// [ [ 'foo', 'abc' ] ]<br>```<br><br>上面代码中，原对象有两个属性，`Object.entries`只输出属性名非Symbol值的属性。将来可能会有`Reflect.ownEntries()`方法，返回对象自身的所有属性。<br><br>`Object.entries`的基本用途是遍历对象的属性。<br><br>```javascript<br>let obj = { one: 1, two: 2 };<br>for (let [k, v] of Object.entries(obj)) {<br>  console.log(`${JSON.stringify(k)}: ${JSON.stringify(v)}`);<br>}<br>// "one": 1<br>// "two": 2<br>```<br><br>`Object.entries`方法的一个用处是，将对象转为真正的`Map`结构。<br><br>```javascript<br>var obj = { foo: 'bar', baz: 42 };<br>var map = new Map(Object.entries(obj));<br>map // Map { foo: "bar", baz: 42 }<br>```<br><br>自己实现`Object.entries`方法，非常简单。<br><br>```javascript<br>// Generator函数的版本<br>function* entries(obj) {<br>  for (let key of Object.keys(obj)) {<br>    yield [key, obj[key]];<br>  }<br>}<br><br>// 非Generator函数的版本<br>function entries(obj) {<br>  let arr = [];<br>  for (let key of Object.keys(obj)) {<br>    arr.push([key, obj[key]]);<br>  }<br>  return arr;<br>}<br>```<br><br>## 对象的扩展运算符<br><br>目前，ES7有一个[提案](https://github.com/sebmarkbage/ecmascript-rest-spread)，将Rest运算符（解构赋值）/扩展运算符（`...`）引入对象。Babel转码器已经支持这项功能。<br><br>**（1）解构赋值**<br><br>对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。<br><br>```javascript<br>let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };<br>x // 1<br>y // 2<br>z // { a: 3, b: 4 }<br>```<br><br>上面代码中，变量`z`是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（`a`和`b`），将它们连同值一起拷贝过来。<br><br>由于解构赋值要求等号右边是一个对象，所以如果等号右边是`undefined`或`null`，就会报错，因为它们无法转为对象。<br><br>```javascript<br>let { x, y, ...z } = null; // 运行时错误<br>let { x, y, ...z } = undefined; // 运行时错误<br>```<br><br>解构赋值必须是最后一个参数，否则会报错。<br><br>```javascript<br>let { ...x, y, z } = obj; // 句法错误<br>let { x, ...y, ...z } = obj; // 句法错误<br>```<br><br>上面代码中，解构赋值不是最后一个参数，所以会报错。<br><br>注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。<br><br>```javascript<br>let obj = { a: { b: 1 } };<br>let { ...x } = obj;<br>obj.a.b = 2;<br>x.a.b // 2<br>```<br><br>上面代码中，`x`是解构赋值所在的对象，拷贝了对象`obj`的`a`属性。`a`属性引用了一个对象，修改这个对象的值，会影响到解构赋值对它的引用。<br><br>另外，解构赋值不会拷贝继承自原型对象的属性。<br><br>```javascript<br>let o1 = { a: 1 };<br>let o2 = { b: 2 };<br>o2.__proto__ = o1;<br>let o3 = { ...o2 };<br>o3 // { b: 2 }<br>```<br><br>上面代码中，对象`o3`是`o2`的拷贝，但是只复制了`o2`自身的属性，没有复制它的原型对象`o1`的属性。<br><br>下面是另一个例子。<br><br>```javascript<br>var o = Object.create({ x: 1, y: 2 });<br>o.z = 3;<br><br>let { x, ...{ y, z } } = o;<br>x // 1<br>y // undefined<br>z // 3<br>```<br><br>上面代码中，变量`x`是单纯的解构赋值，所以可以读取继承的属性；解构赋值产生的变量`y`和`z`，只能读取对象自身的属性，所以只有变量`z`可以赋值成功。<br><br>解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。<br><br>```javascript<br>function baseFunction({ a, b }) {<br>  // ...<br>}<br>function wrapperFunction({ x, y, ...restConfig }) {<br>  // 使用x和y参数进行操作<br>  // 其余参数传给原始函数<br>  return baseFunction(restConfig);<br>}<br>```<br><br>上面代码中，原始函数`baseFunction`接受`a`和`b`作为参数，函数`wrapperFunction`在`baseFunction`的基础上进行了扩展，能够接受多余的参数，并且保留原始函数的行为。<br><br>**（2）扩展运算符**<br><br>扩展运算符（`...`）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。<br><br>```javascript<br>let z = { a: 3, b: 4 };<br>let n = { ...z };<br>n // { a: 3, b: 4 }<br>```<br><br>这等同于使用`Object.assign`方法。<br><br>```javascript<br>let aClone = { ...a };<br>// 等同于<br>let aClone = Object.assign({}, a);<br>```<br><br>扩展运算符可以用于合并两个对象。<br><br>```javascript<br>let ab = { ...a, ...b };<br>// 等同于<br>let ab = Object.assign({}, a, b);<br>```<br><br>如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。<br><br>```javascript<br>let aWithOverrides = { ...a, x: 1, y: 2 };<br>// 等同于<br>let aWithOverrides = { ...a, ...{ x: 1, y: 2 } };<br>// 等同于<br>let x = 1, y = 2, aWithOverrides = { ...a, x, y };<br>// 等同于<br>let aWithOverrides = Object.assign({}, a, { x: 1, y: 2 });<br>```<br><br>上面代码中，`a`对象的`x`属性和`y`属性，拷贝到新对象后会被覆盖掉。<br><br>这用来修改现有对象部分的部分属性就很方便了。<br><br>```javascript<br>let newVersion = {<br>  ...previousVersion,<br>  name: 'New Name' // Override the name property<br>};<br>```<br><br>上面代码中，`newVersion`对象自定义了`name`属性，其他属性全部复制自`previousVersion`对象。<br><br>如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。<br><br>```javascript<br>let aWithDefaults = { x: 1, y: 2, ...a };<br>// 等同于<br>let aWithDefaults = Object.assign({}, { x: 1, y: 2 }, a);<br>// 等同于<br>let aWithDefaults = Object.assign({ x: 1, y: 2 }, a);<br>```<br><br>扩展运算符的参数对象之中，如果有取值函数`get`，这个函数是会执行的。<br><br>```javascript<br>// 并不会抛出错误，因为x属性只是被定义，但没执行<br>let aWithXGetter = {<br>  ...a,<br>  get x() {<br>    throws new Error('not thrown yet');<br>  }<br>};<br><br>// 会抛出错误，因为x属性被执行了<br>let runtimeError = {<br>  ...a,<br>  ...{<br>    get x() {<br>      throws new Error('thrown now');<br>    }<br>  }<br>};<br>```<br><br>如果扩展运算符的参数是`null`或`undefined`，这个两个值会被忽略，不会报错。<br><br>```javascript<br>let emptyObject = { ...null, ...undefined }; // 不报错<br>```<br><br>## Object.getOwnPropertyDescriptors()<br><br>ES5有一个`Object.getOwnPropertyDescriptor`方法，返回某个对象属性的描述对象（descriptor）。<br><br>```javascript<br>var obj = { p: 'a' };<br><br>Object.getOwnPropertyDescriptor(obj, 'p')<br>// Object { value: "a",<br>//   writable: true,<br>//   enumerable: true,<br>//   configurable: true<br>// }<br>```<br><br>ES7有一个提案，提出了`Object.getOwnPropertyDescriptors`方法，返回指定对象所有自身属性（非继承属性）的描述对象。<br><br>```javascript<br>const obj = {<br>  foo: 123,<br>  get bar() { return 'abc' }<br>};<br><br>Object.getOwnPropertyDescriptors(obj)<br>// { foo:<br>//    { value: 123,<br>//      writable: true,<br>//      enumerable: true,<br>//      configurable: true },<br>//   bar:<br>//    { get: [Function: bar],<br>//      set: undefined,<br>//      enumerable: true,<br>//      configurable: true } }<br>```<br><br>`Object.getOwnPropertyDescriptors`方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。<br><br>该方法的实现非常容易。<br><br>```javascript<br>function getOwnPropertyDescriptors(obj) {<br>  const result = {};<br>  for (let key of Reflect.ownKeys(obj)) {<br>    result[key] = Object.getOwnPropertyDescriptor(obj, key);<br>  }<br>  return result;<br>}<br>```<br><br>该方法的提出目的，主要是为了解决`Object.assign()`无法正确拷贝`get`属性和`set`属性的问题。<br><br>```javascript<br>const source = {<br>  set foo(value) {<br>    console.log(value);<br>  }<br>};<br><br>const target1 = {};<br>Object.assign(target1, source);<br><br>Object.getOwnPropertyDescriptor(target1, 'foo')<br>// { value: undefined,<br>//   writable: true,<br>//   enumerable: true,<br>//   configurable: true }<br>```<br><br>上面代码中，`source`对象的`foo`属性的值是一个赋值函数，`Object.assign`方法将这个属性拷贝给`target1`对象，结果该属性的值变成了`undefined`。这是因为`Object.assign`方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。<br><br>这时，`Object.getOwnPropertyDescriptors`方法配合`Object.defineProperties`方法，就可以实现正确拷贝。<br><br>```javascript<br>const source = {<br>  set foo(value) {<br>    console.log(value);<br>  }<br>};<br><br>const target2 = {};<br>Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));<br>Object.getOwnPropertyDescriptor(target2, 'foo')<br>// { get: undefined,<br>//   set: [Function: foo],<br>//   enumerable: true,<br>//   configurable: true }<br>```<br><br>上面代码中，将两个对象合并的逻辑提炼出来，就是下面这样。<br><br>```javascript<br>const shallowMerge = (target, source) => Object.defineProperties(<br>  target,<br>  Object.getOwnPropertyDescriptors(source)<br>);<br>```<br><br>`Object.getOwnPropertyDescriptors`方法的另一个用处，是配合`Object.create`方法，将对象属性克隆到一个新对象。这属于浅拷贝。<br><br>```javascript<br>const clone = Object.create(Object.getPrototypeOf(obj),<br>  Object.getOwnPropertyDescriptors(obj));<br><br>// 或者<br><br>const shallowClone = (obj) => Object.create(<br>  Object.getPrototypeOf(obj),<br>  Object.getOwnPropertyDescriptors(obj)<br>);<br>```<br><br>上面代码会克隆对象`obj`。<br><br>另外，`Object.getOwnPropertyDescriptors`方法可以实现，一个对象继承另一个对象。以前，继承另一个对象，常常写成下面这样。<br><br>```javascript<br>const obj = {<br>  __proto__: prot,<br>  foo: 123,<br>};<br>```<br><br>ES6规定`__proto__`只有浏览器要部署，其他环境不用部署。如果去除`__proto__`，上面代码就要改成下面这样。<br><br>```javascript<br>const obj = Object.create(prot);<br>obj.foo = 123;<br><br>// 或者<br><br>const obj = Object.assign(<br>  Object.create(prot),<br>  {<br>    foo: 123,<br>  }<br>);<br>```<br><br>有了`Object.getOwnPropertyDescriptors`，我们就有了另一种写法。<br><br>```javascript<br>const obj = Object.create(<br>  prot,<br>  Object.getOwnPropertyDescriptors({<br>    foo: 123,<br>  })<br>);<br>```<br><br>`Object.getOwnPropertyDescriptors`也可以用来实现Mixin（混入）模式。<br><br>```javascript<br>let mix = (object) => ({<br>  with: (...mixins) => mixins.reduce(<br>    (c, mixin) => Object.create(<br>      c, Object.getOwnPropertyDescriptors(mixin)<br>    ), object)<br>});<br><br>// multiple mixins example<br>let a = {a: 'a'};<br>let b = {b: 'b'};<br>let c = {c: 'c'};<br>let d = mix(c).with(a, b);<br>```<br><br>上面代码中，对象`a`和`b`被混入了对象`c`。<br><br>出于完整性的考虑，`Object.getOwnPropertyDescriptors`进入标准以后，还会有`Reflect.getOwnPropertyDescriptors`方法。<br></div></div>
			<nav>
				<ul class="pager">
				<li class='previous'><a href='8.html'>&larr; 函数的扩展</a></li>
			<li class='next'><a href='10.html'>Symbol&rarr;</a></li>
				</ul>
			</nav>
</div>
							<!-- <h3 style="padding:10px">在线文档</h3> -->
					</div>
			<!-- /.row -->
			  <hr>
        <!-- Footer -->
        <footer>
            <div class="row">
                <div class="col-xs-12">
                    <p>Copyright &copy; 小龙软件工作室 2016 粤icp备16103410</p>
                </div>
            </div>
        </footer>

    </div>
    <!-- /.container -->

    <!-- jQuery -->
    <script src="../../js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="../../js/bootstrap.min.js"></script>

</body>

</html>
